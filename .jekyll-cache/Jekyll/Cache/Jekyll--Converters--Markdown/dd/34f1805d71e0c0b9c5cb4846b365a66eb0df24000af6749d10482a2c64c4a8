I"s<h1 id="lambda表达式addthen的理解">Lambda表达式addThen的理解</h1>

<p>先定义一个接口类</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface   SYInterface {
	
	int add(int a);
	
	default SYInterface addThen(SYInterface after)
	{
		return (s) -&gt; {
			int a = add(s);
			return after.add(a);
		};
//   或者
//		return s-&gt; {
//			return after.add(add(s));
//		};
	}

}
</code></pre></div></div>

<p>测试类里面</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class SYAddThenDemo {
	public static void main(String[] args) {
		
		SYInterface s1 = a -&gt; a + 2 ;
		SYInterface s2 = a -&gt; a + 3 ;

		test1(a -&gt; a + 100);
		test2(s -&gt;  s + 16,s -&gt;  s + 1);
		
		test1(s1);
		test2(s1,s2);
		
	}
	static void test1(SYInterface ic)
	{
		int r = ic.add(15);
		System.out.println(r);

	}
	static void test2(SYInterface s1,SYInterface s2)
	{
	// int a = s1.addThen(s2).add(15);
		SYInterface c3 =  s1.addThen(s2);
		int r1 = c3.add(15);
		System.out.println(r1);
	}

}
</code></pre></div></div>

<p>每次看到这段代码我都是一脸懵逼 <code class="language-plaintext highlighter-rouge">int a = s1.addThen(s2).add(15);</code>，为什么它会先调用 <code class="language-plaintext highlighter-rouge">s1</code> 的 <code class="language-plaintext highlighter-rouge">add</code> 方法，然后调用 <code class="language-plaintext highlighter-rouge">s2</code> 的 <code class="language-plaintext highlighter-rouge">add</code> 方法。
天资愚钝，思考了一晚上和一个上午，终于理解了，现在记录下推导过程，以防后面再次迷糊。</p>

<p>先来看一段代码</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	test1(new SYInterface() {
		@Override
		public int add(int a) {
			
			return a + 15;
		}
	});
</code></pre></div></div>

<p>这里使用了匿名类来实现，没什么问题，当 <code class="language-plaintext highlighter-rouge">test1</code> 方法里面 <code class="language-plaintext highlighter-rouge">SYInterface ic</code> 调用 <code class="language-plaintext highlighter-rouge">ic.add()</code> 的时候就是调用 匿名类里面的 <code class="language-plaintext highlighter-rouge">add</code> 方法。</p>

<p>根据规则，我们可以把匿名类这段实现修改为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    test1(a -&gt; a + 15);
    
    其实就是
    SYInterface ic = a -&gt; a + 15;
    test1(ic);
    然后当 ic 调用 add 的时候，其实就是 调用 a + 15;
</code></pre></div></div>

<p>这段具体的规则就不讲了，继续往下</p>

<p>上面的理解以后，我们调用接口 SYInterface 的 add 方法的时候，其实就是调用</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int add(int a) {
    return a + 15
}
</code></pre></div></div>

<p>然后我们看下 addThen 的实现</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	default SYInterface addThen(SYInterface after)
	{
		return (s) -&gt; {
			int a = add(s);
			return after.add(a);
		};
//   或者
//		return s-&gt; {
//			return after.add(add(s));
//		};
	}
</code></pre></div></div>

<p>是传入一个 <code class="language-plaintext highlighter-rouge">SYInterface</code> 参数返回一个 <code class="language-plaintext highlighter-rouge">SYInterface</code> 的结果。
所以 伪代码</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> SYInterface s1 = a -&gt; a + 2 ;
 SYInterface s2 = a -&gt; a + 3 ;
 
 s1.add(5) = {
 	return 5 + 2;
 }
 s2.add(5) = {
 	return 5 + 3;
 }
 
 SYInterface c3 = s1.addThen(s2) = s -&gt; {
	  int a = s1.add(s);
	  reurn s2.add(a);
  }	 
  
  所以 c3.add(15) 等于 调用了 
  {
  		//s = 15
  		int a = s1.add(s);
	  	reurn s2.add(a);
  }
</code></pre></div></div>

<p><img src="/media/Lambda_Java/Lambda.png" alt="" /></p>
:ET