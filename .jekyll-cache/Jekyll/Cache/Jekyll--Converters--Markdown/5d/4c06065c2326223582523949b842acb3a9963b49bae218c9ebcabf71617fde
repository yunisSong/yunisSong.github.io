I"_<<h1 id="ios-基础知识之autorelease">iOS 基础知识之–autorelease</h1>

<h4 id="先来看一个问题">先来看一个问题</h4>

<p>分别在在 <code class="language-plaintext highlighter-rouge">MRC</code> 和 <code class="language-plaintext highlighter-rouge">ARC</code> 情况下，下面的两段代码，会不会会引起内存的暴涨？</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">demo2</span><span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">yunis</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Yunis"</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">demo3</span><span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">yunisAlloc</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFormat</span><span class="p">:</span><span class="s">@"YunisAlloc"</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p><img src="/media/15208165720124/Jordan.jpeg" alt="老流氓手动分割问题答案" /></p>

<hr />

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>测试环境： Xcode 9.1</td>
        <td>iPhone 8 Plus(模拟器)</td>
        <td>iOS 11.1</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<hr />

<p>公布答案：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MRC</code> 下：
    <ol>
      <li>
        <p>demo2 
 <img src="/media/15208165720124/15208195864460.jpg" alt="" /></p>
      </li>
      <li>
        <p>demo3
 <img src="/media/15208165720124/15208196265833.jpg" alt="" /></p>
      </li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ARC</code> 下：
    <ol>
      <li>
        <p>demo2
 <img src="/media/15208165720124/15208195271081.jpg" alt="" /></p>
      </li>
      <li>
        <p>demo3
  <img src="/media/15208165720124/15208194888044.jpg" alt="" /></p>
      </li>
    </ol>
  </li>
</ul>

<p>在 <code class="language-plaintext highlighter-rouge">ARC</code> 下，内存差别是不大的，但是在 <code class="language-plaintext highlighter-rouge">MRC</code> 的情况下，<code class="language-plaintext highlighter-rouge">demo3</code> 的代码会导致内存疯狂增长。为什么呢？
这里我们猜想：是因为 <code class="language-plaintext highlighter-rouge">stringWithFormat</code> 方法返回的对象是有一个 <code class="language-plaintext highlighter-rouge">_autorelease</code> 属性修饰的。所以 <code class="language-plaintext highlighter-rouge">demo2</code> 中的 <code class="language-plaintext highlighter-rouge">yunis</code>，会自动释放，这就是为什么 <code class="language-plaintext highlighter-rouge">demo2</code> 在 <code class="language-plaintext highlighter-rouge">ARC</code> 和 <code class="language-plaintext highlighter-rouge">MRC</code> 下内存都变化不大的原因，而 ` alloc] initWithFormat ` 返回的对象是没有 <code class="language-plaintext highlighter-rouge">_autorelease</code> 修饰的，所以他不会自动释放，需要我们手动调用 <code class="language-plaintext highlighter-rouge">autorelease</code> ，才能释放。真的是因为这样吗？</p>

<h4 id="初识-autorelease">初识 <code class="language-plaintext highlighter-rouge">autorelease</code></h4>

<p>接着上一个问题，在 <code class="language-plaintext highlighter-rouge">MRC</code> 下，我们小小的修改下 <code class="language-plaintext highlighter-rouge">demo3</code> 代码，变为：</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">demo3</span><span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">yunisAlloc</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFormat</span><span class="p">:</span><span class="s">@"YunisAlloc"</span><span class="p">];</span>
        <span class="p">[</span><span class="n">yunisAlloc</span> <span class="nf">autorelease</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再来看下内存的情况：</p>

<p><img src="/media/15208165720124/15208201049553.jpg" alt="" /></p>

<p>额，内存依然在疯狂的增长，如果我们把 <code class="language-plaintext highlighter-rouge">autorelease</code> 换为 <code class="language-plaintext highlighter-rouge">release</code> 呢？</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">demo3</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">yunisAlloc</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFormat</span><span class="p">:</span><span class="s">@"YunisAlloc"</span><span class="p">];</span>
        <span class="p">[</span><span class="n">yunisAlloc</span> <span class="nf">release</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><img src="/media/15208165720124/15208204179320.jpg" alt="" /></p>

<p>这时我们发现，内存回到一个正常的状态。</p>

<p>那么问题来了？为什么 <code class="language-plaintext highlighter-rouge">autorelease</code> 没用使内存降下来，而 <code class="language-plaintext highlighter-rouge">release</code> 可以呢？</p>

<p>难道跟传说中的自动释放池有关系？</p>

<p>进一步的，我们再次修改下 <code class="language-plaintext highlighter-rouge">demo3</code> 代码：</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">demo3</span> <span class="p">{</span>
    
    <span class="k">@autoreleasepool</span><span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">NSString</span> <span class="o">*</span><span class="n">yunisAlloc</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFormat</span><span class="p">:</span><span class="s">@"YunisAlloc"</span><span class="p">];</span>
            <span class="p">[</span><span class="n">yunisAlloc</span> <span class="nf">autorelease</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>


</code></pre></div></div>

<p><img src="/media/15208165720124/15208334393921.jpg" alt="" /></p>

<p>握草！！！ 我都加了  <code class="language-plaintext highlighter-rouge">autorelease</code> 和 <code class="language-plaintext highlighter-rouge">@autoreleasepool</code>了，为什么内存还是没有降下去？？</p>

<p>然后我去读了经典书籍：<code class="language-plaintext highlighter-rouge">《Objective-C高级编程：iOS与OS X多线程和内存管理》</code>。</p>

<hr />

<p><img src="/media/15208165720124/rc.jpg" alt="人丑就要多读书" /></p>

<p>我读书回来了。</p>

<p><img src="/media/15208165720124/zb.jpg" alt="我回来装逼了" /></p>

<h4 id="autorelease-对象什么时候释放"><code class="language-plaintext highlighter-rouge">autorelease</code> 对象什么时候释放？</h4>

<p>在 <code class="language-plaintext highlighter-rouge">《Objective-C高级编程：iOS与OS X多线程和内存管理》</code> 是这样说的：</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">NSAutoreleasePool</code> 对象的生存周期相当于 C 语言变量的作用域。对于调用 <code class="language-plaintext highlighter-rouge">autorelease</code> 实例方法的对象，在废弃 <code class="language-plaintext highlighter-rouge">NSAutoreleasePool</code> 对象时，都将调用 <code class="language-plaintext highlighter-rouge">release</code> 实例方法。</p>
</blockquote>

<p>那么现在来看为什么我们的 demo3 加了 <code class="language-plaintext highlighter-rouge">NSAutoreleasePool</code> 和  <code class="language-plaintext highlighter-rouge">autorelease</code> 后内存依然没有降低的原因就清晰明了了。修改代码：</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">demo3</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">@autoreleasepool</span> <span class="p">{</span>
            <span class="n">NSString</span> <span class="o">*</span><span class="n">yunisAlloc</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFormat</span><span class="p">:</span><span class="s">@"YunisAlloc"</span><span class="p">];</span>
            <span class="p">[</span><span class="n">yunisAlloc</span> <span class="nf">autorelease</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

</code></pre></div></div>
<p><img src="media/15208165720124/15209243952932.jpg" alt="" /></p>

<p>内存回到一个正常的状态。</p>

<p>OK ，让我们来理一下思路。</p>

<p>对于 demo2 中的代码，因为返回的是一个使用 <code class="language-plaintext highlighter-rouge">_autorelease</code> 修饰的对象，已经自动加入释放池了，所以内存没有显著的增长。</p>

<p>但是对于一个 <code class="language-plaintext highlighter-rouge">alloc init</code> 生成的实例变量，在 <code class="language-plaintext highlighter-rouge">MRC</code> 下需要用户手动的管理引用计数，同时对于短时间大量生成的局部变量，应及时的释放其内存。对于调用 <code class="language-plaintext highlighter-rouge">autorelease</code> 实例方法的实例对象，会在自动释放池 <code class="language-plaintext highlighter-rouge">drain</code> 后，才调用实例对象的 <code class="language-plaintext highlighter-rouge">release</code> 实例方法。
那么，在 <code class="language-plaintext highlighter-rouge">ARC</code> 下，系统对 <code class="language-plaintext highlighter-rouge">demo3</code> 为我们做了什么？跟我们自己在 <code class="language-plaintext highlighter-rouge">MRC</code> 编写的代码逻辑一致吗？</p>

<p>同时，返回 <code class="language-plaintext highlighter-rouge">_autorelease</code> 修饰的实例是加入了那个自动释放池？这个自动释放池的生存周期又是什么样的？它为什么没有造成大量的内存增长？</p>

<p><img src="/media/15208165720124/15209960318680.jpg" alt="" /></p>

<p><strong>这个结论对 <code class="language-plaintext highlighter-rouge">UIView</code> 好像不成立！！！！！</strong>
<strong>这个结论对 <code class="language-plaintext highlighter-rouge">UIView</code> 好像不成立！！！！！</strong>
<strong>这个结论对 <code class="language-plaintext highlighter-rouge">UIView</code> 好像不成立！！！！！</strong>
<strong>这个结论对 <code class="language-plaintext highlighter-rouge">UIView</code> 好像不成立！！！！！</strong>
<strong>这个结论对 <code class="language-plaintext highlighter-rouge">UIView</code> 好像不成立！！！！！</strong>
<strong>这个结论对 <code class="language-plaintext highlighter-rouge">UIView</code> 好像不成立！！！！！</strong></p>

<p><strong>挖槽 这个问题挖下去 好像 还得看看 runLoop ！！！</strong></p>

<ol>
  <li>为什么 uiview 在 autoreleasepool 不生效？</li>
  <li>_autorelease 修饰的实例 是存在于那个 autoreleasepool？</li>
</ol>

<p><strong>我TM好像给自己挖了一个深坑！！！！！！</strong></p>

<p>去 孙源大神的博客研究下：</p>

<p>https://blog.sunnyxx.com/2014/10/15/behind-autorelease/</p>

:ET