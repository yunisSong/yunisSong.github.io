<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- layout:     post title:      为什么使用weak修饰的变量会自动设置为nil subtitle:   在不断填坑中前进。。 date:       2017-06-26 author:     三十一 header-img: img/post-bg-nextgen-web-pwa.jpg header-mask: 0.3 catalog:    true tags:    - 内功    - iOS ---
</code></pre></div></div>

<h1 id="为什么使用weak修饰的变量会自动设置为nil">为什么使用weak修饰的变量会自动设置为nil</h1>

<blockquote>
  <p>Objective-C高级编程 iOS与OS X多线程和内存管理 读书笔记</p>
</blockquote>

<h3 id="为什么使用weak修饰的变量会自动设置为nil-1">为什么使用weak修饰的变量会自动设置为nil</h3>

<p>我们知道：</p>

<ul>
  <li>当使用<code class="language-plaintext highlighter-rouge">__weak</code>修饰符的变量的 引用对象 被废弃时，则将nil赋值给该变量。</li>
  <li>使用附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量，即是使用注册到 <code class="language-plaintext highlighter-rouge">autoreleasepool</code> 中的对象。</li>
</ul>

<h3 id="系统是如何实现的">系统是如何实现的？</h3>

<p>先看下面的代码：</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">{</span>
        <span class="n">id</span> <span class="n">__weak</span> <span class="n">obj1</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>经过编译器会装换为下面的代码;</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">id</span> <span class="n">obj1</span><span class="p">;</span>
    <span class="n">objc_initWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">objc_destroyWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
</code></pre></div></div>
<p>其中 <code class="language-plaintext highlighter-rouge">objc_initWeak</code> 函数初始化附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量，在变量作用域结束后通过 <code class="language-plaintext highlighter-rouge">objc_destroyWeak</code> 函数释放该变量。</p>

<p><code class="language-plaintext highlighter-rouge">objc_initWeak</code> 实现：</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">objc_destroyWeak</code> 实现:</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

</code></pre></div></div>

<p>所以以上的代码与下面的源代码相同：</p>

<div class="language-objective_c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">id</span> <span class="n">obj1</span><span class="p">;</span>
    <span class="n">obj1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">objc_storeWeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">objc_storeWeak</code> 函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量的地址注册到 <code class="language-plaintext highlighter-rouge">weak</code> 表中。</p>

<p><em>*{obj:&amp;obj1} 等同 {“key”:”Value”}*</em></p>

<p><code class="language-plaintext highlighter-rouge">weak</code> 表 是作为一个散列表实现的。
当 变量 废弃时，使用该对象的地址作为键进行查找，就能快速的获取对应的 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量的地址。另外，由于一个对象可以同时赋值给多个 附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量中，所以对于一个键，可注册多个变量的地址。</p>

<p>释放对象时，废弃谁都不持有的对象的同时，程序的动作是怎么样的呢？</p>

<ol>
  <li>objc_release</li>
  <li>因为引用计数为0所以执行 dealloc</li>
  <li>_onjc_rootDealloc</li>
  <li>objc_dispose</li>
  <li>objc_destrucInstance</li>
  <li>objc_clear_deallocating</li>
</ol>

<p>对象废弃时 最后调用的 <code class="language-plaintext highlighter-rouge">objc_clear_deallocating</code> 函数动作如下：</p>

<ol>
  <li>从 <code class="language-plaintext highlighter-rouge">weak</code> 表中获取废弃对象的地址为键值的记录</li>
  <li>将包含在记录中的所有附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符变量的地址，赋值为 <code class="language-plaintext highlighter-rouge">nil</code></li>
  <li>从 <code class="language-plaintext highlighter-rouge">weak</code> 表中删除该记录</li>
  <li>从引用计数表中删除废弃对象的地址为键值的记录。</li>
</ol>

<p>所以如果附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量 所引用的对象废弃后，将 nil 赋值给改变量的步骤是在这里实现的。</p>

<p>由此可知，如果大量的使用附有 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符的变量，会消耗对应的 <code class="language-plaintext highlighter-rouge">CPU</code> 资源。良策是只在需要避免循环引用时使用 <code class="language-plaintext highlighter-rouge">__weak</code> 修饰符。</p>

<h3 id="最后总结">最后总结</h3>

<p>简单来说就是：</p>
<ol>
  <li>使用 __weak 修饰符的变量 A ，A 引用变量 B ，这时系统会把 B 的地址作为Key ，A的地址作为 Value ，存储在一个系统的散列表中；</li>
  <li>当对象 B 被释放时，会先调用 release 然后引用计数为0；</li>
  <li>然后调用 dealloc ；</li>
  <li>接着会调用一个名为<code class="language-plaintext highlighter-rouge">objc_clear_deallocating</code>的函数，这个函数的作用就是查找以 B 的地址为 key 的 Value，然后将改这些 Value 赋值为 nil，在把这些 Key 、Value 从散列表中删除；</li>
  <li>最后在引用计数表中将以 B 的地址为键值的记录删除。</li>
</ol>

