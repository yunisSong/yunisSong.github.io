<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三十一</title>
    <description>潜心修行中。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 12 Sep 2017 11:41:23 +0800</pubDate>
    <lastBuildDate>Tue, 12 Sep 2017 11:41:23 +0800</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>Swift30Projects</title>
        <description>&lt;h1 id=&quot;swift30projects&quot;&gt;Swift30Projects&lt;/h1&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;0-goodasoldphones&quot;&gt;0 GoodAsOldPhones&lt;/h2&gt;

&lt;h3 id=&quot;使用-storyboard-默认加载-tabbar&quot;&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;storyboard&lt;/code&gt; 默认加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;tabbar&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;storyboard&lt;/code&gt; 加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;tabbar&lt;/code&gt; 时，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Embed In&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Tab Bar Controller&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/media/15048621506323/15048622289028.jpg&quot; alt=&quot;tabbar&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;为-tabbar-添加控制器&quot;&gt;为 &lt;code class=&quot;highlighter-rouge&quot;&gt;tabbar&lt;/code&gt; 添加控制器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;把 &lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 加入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;tabbar&lt;/code&gt; 控制器，需要先选择  &lt;code class=&quot;highlighter-rouge&quot;&gt;tabbar&lt;/code&gt; 控制器，然后 按着 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt; 键 拖线到  &lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;,选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;View controllers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/media/15048621506323/q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;类-和-结构-的区别&quot;&gt;类 和 结构 的区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类 和 结构 的区别
    &lt;ol&gt;
      &lt;li&gt;Structures
        &lt;ol&gt;
          &lt;li&gt;Useful for representing values
            &lt;ul&gt;
              &lt;li&gt;Implicit copying of values&lt;/li&gt;
              &lt;li&gt;Data is immutable&lt;/li&gt;
              &lt;li&gt;Fast memory allocation (stack)
    * Classes&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Useful for representing objects
            &lt;ul&gt;
              &lt;li&gt;Implicit sharing of objects&lt;/li&gt;
              &lt;li&gt;Data is mutable&lt;/li&gt;
              &lt;li&gt;Slower memory allocation (heap)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;guard-语句&quot;&gt;guard 语句&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func fooGuard(x: Int?) {
    guard let x = x where x &amp;gt; 0 else {
        // 变量不符合条件判断时，执行下面代码
        return
    }

    // 使用x
    x.description
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 08 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/09/08/Swift30Projects/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/09/08/Swift30Projects/</guid>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>命令行软件</title>
        <description>&lt;h1 id=&quot;命令行软件&quot;&gt;命令行软件&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mac&lt;/code&gt; 下安装命令行软件 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install&lt;/code&gt;，譬如 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;tree&lt;/code&gt; ，就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install tree&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tree&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tree&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;列出文件层级&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15046854241597/shell_tree.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;shellcheck&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shellcheck&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;检查脚本的错误&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15046854241597/15046866221935.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;thefuck&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;thefuck&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;安装后，记得替换别名&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alias fuck='eval $(thefuck $(fc -ln -1)); history -r'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15046854241597/15046870856588.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cloc&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cloc&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;代码统计神器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15046854241597/15046872073389.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cowsay&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cowsay&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;额，其实就是个恶趣味，挺有趣的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15046854241597/15046872820303.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/09/06/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BD%AF%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/09/06/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BD%AF%E4%BB%B6/</guid>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>单元测试</title>
        <description>&lt;h1 id=&quot;单元测试&quot;&gt;单元测试&lt;/h1&gt;
&lt;h3 id=&quot;为什么要写单元测试&quot;&gt;为什么要写单元测试&lt;/h3&gt;
&lt;h3 id=&quot;如何写单元测试&quot;&gt;如何写单元测试&lt;/h3&gt;
&lt;h4 id=&quot;那些应该写单元测试那些不应该&quot;&gt;那些应该写单元测试。那些不应该&lt;/h4&gt;

&lt;p&gt;为了更方便地进行单元测试，业务代码应避免以下情况：&lt;/p&gt;

&lt;p&gt;存在太多条件逻辑
构造函数中做的事情太多
存在太多全局状态
混杂了太多无关的逻辑
存在太多静态方法
存在过多外部依赖&lt;/p&gt;

&lt;p&gt;http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html&lt;/p&gt;

&lt;p&gt;http://www.hollischuang.com/archives/972&lt;/p&gt;

&lt;p&gt;单元测试在实际工作无法推进的原因，无外乎以下两点：缺乏实施动力和缺少实战经验。&lt;/p&gt;

&lt;p&gt;http://xiangwangfeng.com/2016/10/17/%E8%B5%B0%E5%87%BA-iOS-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9B%B0%E5%A2%83/&lt;/p&gt;

&lt;p&gt;SDWeb 如何写单元测试&lt;/p&gt;

&lt;p&gt;http://www.uml.org.cn/Test/201306072.asp&lt;/p&gt;

&lt;p&gt;https://www.wangjiawen.com/ios/ios-unit-testing-of-kiwi&lt;/p&gt;

&lt;p&gt;http://tmq.qq.com/2017/07/ios/&lt;/p&gt;

&lt;p&gt;http://draveness.me/ios-kai-fa-zhong-de-zhong-gou.html&lt;/p&gt;

&lt;p&gt;https://doc.yonyoucloud.com/doc/FunctionalReactiveProgrammingOniOS/chapter6/testing_viewModels.html&lt;/p&gt;

&lt;p&gt;https://charminglee1973.wordpress.com/2015/06/02/ios%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8Bviewcontroller%E7%AF%87/&lt;/p&gt;

</description>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/31/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/31/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>NSAssert简单使用</title>
        <description>&lt;h1 id=&quot;nsassert简单使用&quot;&gt;NSAssert简单使用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSAssert&lt;/code&gt; 的定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define NSAssert(condition, desc, ...)	\
    do {				\
	__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
	if (!(condition)) {		\
        NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \
            __assert_file__ = __assert_file__ ? __assert_file__ : @&quot;&amp;lt;Unknown File&amp;gt;&quot;; \
	    [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \
		object:self file:__assert_file__ \
	    	lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
	}				\
        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
    } while(0)
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;condition&lt;/code&gt; 判断条件为 &lt;code class=&quot;highlighter-rouge&quot;&gt;假&lt;/code&gt; 的时候，程序终止，提示错误，提示语为 &lt;code class=&quot;highlighter-rouge&quot;&gt;desc&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;condition&lt;/code&gt; 判断条件为 &lt;code class=&quot;highlighter-rouge&quot;&gt;真&lt;/code&gt; 的时候，程序继续运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; NSAssert(self.umPushAppKey != nil, @&quot;请设置友盟key&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey != nil&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;假&lt;/code&gt;，程序终止，提示 &lt;code class=&quot;highlighter-rouge&quot;&gt;请设置友盟key&lt;/code&gt;。
    &lt;ul&gt;
      &lt;li&gt;提示语为： &lt;code class=&quot;highlighter-rouge&quot;&gt;Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '请设置友盟key'&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey&lt;/code&gt; 不为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey != nil&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;真&lt;/code&gt;，程序继续运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; NSAssert(self.umPushAppKey, @&quot;请设置友盟key&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;假&lt;/code&gt;，程序终止，提示 &lt;code class=&quot;highlighter-rouge&quot;&gt;请设置友盟key&lt;/code&gt;。
    &lt;ul&gt;
      &lt;li&gt;提示语为： &lt;code class=&quot;highlighter-rouge&quot;&gt;Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '请设置友盟key'&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey&lt;/code&gt; 不为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.umPushAppKey&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;真&lt;/code&gt;，程序继续运行。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 28 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/28/NSAssert%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/28/NSAssert%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
        
        
      </item>
    
      <item>
        <title>iOS应用架构谈学习笔记</title>
        <description>&lt;h1 id=&quot;ios应用架构谈学习笔记&quot;&gt;iOS应用架构谈学习笔记&lt;/h1&gt;

&lt;p&gt;本文是学习 &lt;a href=&quot;https://casatwy.com/&quot;&gt;反革命工程师&lt;/a&gt; 关于架构的的一系列博文的笔记。&lt;/p&gt;

&lt;p&gt;原博文链接：
&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html&quot;&gt;iOS应用架构谈 开篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html&quot;&gt;iOS应用架构谈 view层的组织和调用方案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html&quot;&gt;iOS应用架构谈 网络层设计方案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html&quot;&gt;iOS应用架构谈 本地持久化方案及动态部署&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://casatwy.com/iOS-Modulization.html&quot;&gt;iOS应用架构谈 组件化方案&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;view层的组织和调用方案&quot;&gt;view层的组织和调用方案&lt;/h2&gt;

&lt;h3 id=&quot;代码布局&quot;&gt;代码布局&lt;/h3&gt;
&lt;p&gt;代码布局的大概样式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma mark - Life Cycle

- (void)viewDidLoad {
    [super viewDidLoad];
    //加载页面
}
- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];
    //布局
}
- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    //监听事件
}
- (void)dealloc
{
    
}
#pragma mark - Intial Methods
//初始化数据
- (void)assignDate
{
    
}
- (void)settingAppearance
{
    
}
- (void)loadSubViews
{
    
}
#pragma mark - Target Methods
//点击事件或通知事件

#pragma mark - Network Methods
//网络请求

#pragma mark - Public Method
//外部方法

#pragma mark - Private Method
//本类方法

#pragma mark - Delegate
//代理方法


#pragma mark - Lazy Loads
//懒加载 Getter方法

#pragma mark - set
//Setter方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;在ios开发领域中怎样才算是mvc划分的正确姿势&quot;&gt;在iOS开发领域中，怎样才算是MVC划分的正确姿势？&lt;/h3&gt;

&lt;p&gt;M应该做的事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给ViewController提供数据&lt;/li&gt;
  &lt;li&gt;给ViewController存储数据提供接口&lt;/li&gt;
  &lt;li&gt;提供经过抽象的业务基本组件，供Controller调度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C应该做的事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;管理View Container的生命周期&lt;/li&gt;
  &lt;li&gt;负责生成所有的View实例，并放入View Container&lt;/li&gt;
  &lt;li&gt;监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;V应该做的事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。&lt;/li&gt;
  &lt;li&gt;界面元素表达&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;拆分的心法&quot;&gt;拆分的心法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一心法：保留最重要的任务，拆分其它不重要的任务&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在iOS开发领域内，UIViewController承载了非常多的事情，比如View的初始化，业务逻辑，事件响应，数据加工等等，当然还有更多我现在也列举不出来，但是我们知道有一件事情Controller肯定逃不掉要做：协调V和M。也就是说，不管怎么拆，协调工作是拆不掉的。那么剩下的事情我们就可以拆了，比如    UITableView的DataSource。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二心法：拆分后的模块要尽可能提高可复用性，尽量做到DRY&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;根据第一心法拆开来的东西，很有可能还是强业务相关的，这种情况有的时候无法避免。但我们拆也要拆得好看，拆出来的部分最好能够归成某一类对象，然后最好能够抽象出一个通用逻辑出来，使他能够复用。即使不能抽出通用逻辑，那也尽量抽象出一个protocol，来实现IOP。这里有篇关于&lt;a href=&quot;https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html&quot;&gt;IOP的文章&lt;/a&gt;，大家看了就明白优越性了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三心法：要尽可能提高拆分模块后的抽象度&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;尽量高层级的抽象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;设计心法&quot;&gt;设计心法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;第一心法：尽可能减少继承层级，涉及苹果原生对象的尽量不要继承
    &lt;ul&gt;
      &lt;li&gt;继承是罪恶，尽量不要继承。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二心法：做好代码规范，规定好代码在文件中的布局，尤其是ViewController
    &lt;ul&gt;
      &lt;li&gt;这主要是为了提高可维护性。在一个文件非常大的对象中，尤其要限制好不同类型的代码在文件中的布局。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第三心法：能不放在Controller做的事情就尽量不要放在Controller里面去做&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;小总结&quot;&gt;小总结&lt;/h4&gt;

&lt;p&gt;其实针对View层的架构设计，还是要做好三点：&lt;code class=&quot;highlighter-rouge&quot;&gt;代码规范&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;架构模式&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;工具集&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;代码规范对于View层来说意义重大，毕竟View层非常重业务，如果代码布局混乱，后来者很难接手，也很难维护。&lt;/p&gt;

&lt;p&gt;架构模式具体如何选择，完全取决于业务复杂度。如果业务相当相当复杂，那就可以使用VIPER，如果相对简单，那就直接MVC稍微改改就好了。每一种已经成为定式的架构模式不见得都适合各自公司对应的业务，所以需要各位架构师根据情况去做一些拆分或者改变。拆分一般都不会出现问题，改变的时候，只要别把MVC三个角色搞混就好了，M该做啥做啥，C该做啥做啥，V该做啥做啥，不要乱来。关于大部分的架构模式应该是什么样子，这篇文章里都已经说过了，不过我认为最重要的还是后面的心法，模式只是招术，熟悉了心法才能大巧不工。&lt;/p&gt;

&lt;p&gt;View层的工具集主要还是集中在如何对View进行布局，以及一些特定的View，比如带搜索提示的搜索框这种。这篇文章只提到了View布局的工具集，其它的工具集相对而言是更加取决于各自公司的业务的，各自实现或者使用CocoaPods里现成的都不是很难。&lt;/p&gt;

&lt;p&gt;对于小规模或者中等规模iOS开发团队来说，做好以上三点就足够了。在大规模团队中，有一个额外问题要考虑，就是跨业务页面调用方案的设计。&lt;/p&gt;

</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/23/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/23/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>runtime 可以做什么</title>
        <description>&lt;h1 id=&quot;runtime-可以做什么&quot;&gt;runtime 可以做什么&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;这篇文字不扯淡，不讲runtime是什么，只总结下runtime 可以用来干什么。
这几篇文章写的很好：
&lt;a href=&quot;http://tech.glowing.com/cn/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://tech.glowing.com/cn/method-swizzling-aop/&quot;&gt;Method Swizzling 和 AOP 实践&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/categories/objectivec/&quot;&gt;南大(南锋子)的一系列文章&lt;/a&gt;（打开稍慢）&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sps900608/article/details/51863147&quot;&gt;精通Objective-C进阶技巧：使用运行时系统API&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;然后饶神总结的也不错,里面好多干货
&lt;a href=&quot;http://www.jianshu.com/p/64a7c9f7f6b2&quot;&gt;iOS 基础知识点网址&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;美团技术团队
&lt;a href=&quot;http://tech.meituan.com/DiveIntoCategory.html&quot;&gt;深入理解Objective-C：Category&lt;/a&gt;
&lt;a href=&quot;http://tech.meituan.com/DiveIntoMethodCache.html&quot;&gt;深入理解Objective-C：方法缓存&lt;/a&gt;
&lt;a href=&quot;http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html&quot;&gt;Obj-C Optimization: IMP Cacheing Deluxe&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;杨小鱼（玉令天下）
&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;1获取类属性列表值方法&quot;&gt;1，获取类属性列表、值、方法&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yunisSong/RunTimeDemo/blob/master/RunTimeDemo/NSObject%2BProperty.m&quot;&gt;获取model的属性、属性值、方法列表 demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2替换已有函数包括系统方法&quot;&gt;2，替换已有函数(包括系统方法)&lt;/h4&gt;
&lt;p&gt;可以把系统方法替换为我们自己的方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yunisSong/RunTimeDemo/blob/master/RunTimeDemo/UIAlertController%2BexchangeMethod.m&quot;&gt;替换系统弹框方法，统一修改弹框标题  demo地址&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;3动态挂载对象&quot;&gt;3，动态挂载对象&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yunisSong/RunTimeDemo/blob/master/RunTimeDemo/UIView%2BredDot.m&quot;&gt;为View 加一个小红点的公用方法  demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;4动态创建类-kvo-底层实现原理&quot;&gt;4,动态创建类 KVO 底层实现原理&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/6305af232100&quot;&gt;KVO的底层实现原理&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;5自动归档归档解档&quot;&gt;5，自动归档、归档解档&lt;/h4&gt;

&lt;p&gt;           &lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[coder encodeObject:value forKey:propertyName];

[self setValue:value forKey:propertyName];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yunisSong/RunTimeDemo/blob/master/RunTimeDemo/NSObject%2Bencode.m&quot;&gt;统一为property添加方法 不用一个个的写 demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;6给分类添加属性&quot;&gt;6，给分类添加属性&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yunisSong/RunTimeDemo/blob/master/RunTimeDemo/UIView%2BredDot.m&quot;&gt;为View 加一个小红点的公用方法  demo地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;7字典转模型&quot;&gt;7，字典转模型&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yunisSong/RunTimeDemo/blob/master/RunTimeDemo/NSObject%2BdicToModel.m&quot;&gt;同样是获取类的属性，然后调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[instance setValue:value forKey:key]&lt;/code&gt; 赋值  demo地址&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/21/runtime-%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/21/runtime-%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/</guid>
        
        <category>iOS</category>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>如果做一个展示进度的刻度盘</title>
        <description>&lt;h1 id=&quot;如果做一个展示进度的刻度盘&quot;&gt;如果做一个展示进度的刻度盘&lt;/h1&gt;

&lt;p&gt;先上效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Pane/Pane0.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/in-post/Pane/Pane17.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/in-post/Pane/PaneAngle.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/in-post/Pane/PaneAngle70.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1如何绘制弧形间隔的刻度线&quot;&gt;1，如何绘制弧形间隔的刻度线。&lt;/h3&gt;
&lt;p&gt;首先是如何绘制一个连续的弧形的线条，这个很简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    UIBezierPath *tickPath = [UIBezierPath bezierPathWithArcCenter:cneter radius:radius - 12 startAngle:startAngle endAngle:endAngle clockwise:YES];
    CAShapeLayer *perLayer = [CAShapeLayer layer];
    perLayer.strokeColor = strokeColor.CGColor;;
    perLayer.fillColor = [UIColor clearColor].CGColor;
    perLayer.allowsEdgeAntialiasing=YES;
    perLayer.contentsScale = [UIScreen mainScreen].scale;
    perLayer.lineWidth   = 0.6;
    perLayer.path = tickPath.CGPath;
    [self.layer addSublayer:perLayer];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实带有间隔的刻度线原理是跟这个一致的，我们只需要想着每个分割的刻度是一个连续的圆弧线，只不过它的 &lt;code class=&quot;highlighter-rouge&quot;&gt;startAngle&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;endAngle&lt;/code&gt; 差值很小。然后外面其实的一段段的绘制一个个 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAShapeLayer&lt;/code&gt; 的弧线。&lt;/p&gt;

&lt;p&gt;具体的代码就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    CGPoint cneter = self.center;
    CGFloat radius = self.radius;
    CGFloat perAngle = (endAngle - startAngle)/scaleLineCount;
    UIColor *strokeColor = self.normalColor;
    //绘制最外围刻度列表
    for (NSInteger i = 0; i&amp;lt;= scaleLineCount; i++) {
        CGFloat startAngel = (startAngle+ perAngle * i);
        CGFloat endAngel   = startAngel + perAngle/5;
        UIBezierPath *tickPath = [UIBezierPath bezierPathWithArcCenter:cneter radius:radius startAngle:startAngel endAngle:endAngel clockwise:YES];
        CAShapeLayer *perLayer = [CAShapeLayer layer];
        perLayer.strokeColor = strokeColor.CGColor;;
        perLayer.allowsEdgeAntialiasing=YES;
        perLayer.contentsScale = [UIScreen mainScreen].scale;
        perLayer.lineWidth   = scaleLineWidth;
        perLayer.path = tickPath.CGPath;
        [self.layer addSublayer:perLayer];
        [self.layerViewsArray addObject:perLayer];

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;scaleLineCount&lt;/code&gt; 是要分成多少刻度。&lt;/p&gt;

&lt;h3 id=&quot;2如何给进度加上动画&quot;&gt;2，如何给进度加上动画&lt;/h3&gt;
&lt;p&gt;动画就简单粗暴了，一个个修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAShapeLayer&lt;/code&gt; 的背景色。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAShapeLayer *perLayer = self.layerViewsArray[self.index];
perLayer.strokeColor = self.hightColor.CGColor;;
[self.layerHeightViewsArray addObject:perLayer];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;demo  已上传 &lt;a href=&quot;https://github.com/yunisSong/SYPanView/tree/master&quot;&gt;SYPanView&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 18 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/18/%E5%A6%82%E6%9E%9C%E5%81%9A%E4%B8%80%E4%B8%AA%E5%B1%95%E7%A4%BA%E8%BF%9B%E5%BA%A6%E7%9A%84%E5%88%BB%E5%BA%A6%E7%9B%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/18/%E5%A6%82%E6%9E%9C%E5%81%9A%E4%B8%80%E4%B8%AA%E5%B1%95%E7%A4%BA%E8%BF%9B%E5%BA%A6%E7%9A%84%E5%88%BB%E5%BA%A6%E7%9B%98/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>使用wkhtmltopdf将Markdown转为带有标签的PDF</title>
        <description>&lt;h1 id=&quot;使用-wkhtmltopdf-将-markdown-文件转为带有标签的-pdf-文件&quot;&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wkhtmltopdf&lt;/code&gt; 将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Markdown&lt;/code&gt; 文件转为带有标签的 PDF 文件&lt;/h1&gt;

&lt;h3 id=&quot;1使用-mweb-编写-markdown-文档&quot;&gt;1，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MWeb&lt;/code&gt; 编写 &lt;code class=&quot;highlighter-rouge&quot;&gt;Markdown&lt;/code&gt; 文档&lt;/h3&gt;
&lt;p&gt;。。。。&lt;/p&gt;
&lt;h3 id=&quot;2导出为-html&quot;&gt;2，导出为 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/markDownToHtml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3编辑-html-样式&quot;&gt;3，编辑 HTML 样式&lt;/h3&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sublime text&lt;/code&gt; 打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 文件我这边主要修改了宽度、代码背景色、字体大小和粗体字体颜色。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.markdown-body {
  min-width: 200px;
  max-width: none;/* 修改 */
  margin: 0 auto;
  padding: 20px;

  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333;
  overflow: hidden;
  font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Segoe UI&quot;, Arial, freesans, sans-serif;
  font-size: 58px;/* 修改 */
  line-height: 1.6;
  word-wrap: break-word;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: #e8f2fb;/* 修改 */
  border-radius: 3px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #e8f2fb;/* 修改 */
  border-radius: 3px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.markdown-body strong {
  font-weight: bold;
  color: #0a366f;/* 修改 */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;4下载-wkhtmltopdf&quot;&gt;4，下载 &lt;code class=&quot;highlighter-rouge&quot;&gt;wkhtmltopdf&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;下载地址为 &lt;a href=&quot;https://wkhtmltopdf.org/downloads.html&quot;&gt;wkhtmltopdf&lt;/a&gt;.
建议打开 VPN ，不然下载速度好慢的。&lt;/p&gt;
&lt;h3 id=&quot;4使用-wkhtmltopdf-转换为-pdf&quot;&gt;4，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;wkhtmltopdf&lt;/code&gt; 转换为 PDF&lt;/h3&gt;
&lt;p&gt;进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 文件所在目录，使用命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$-&amp;gt; wkhtmltopdf  index.html 编码规范.pdf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 为刚才导出的文件 ，&lt;code class=&quot;highlighter-rouge&quot;&gt;编码规范.pdf&lt;/code&gt; 为你要生成的PDF 文件&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一定要到&lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 文件所在目录执行这个命令。我因为这个原因傻逼的找了半天错误原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;样式大概是这个样子的：
&lt;img src=&quot;/img/in-post/wkhtmltopdfDemo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 17 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/17/%E4%BD%BF%E7%94%A8wkhtmltopdf%E5%B0%86MarkDown%E8%BD%AC%E4%B8%BA%E5%B8%A6%E6%9C%89%E6%A0%87%E7%AD%BE%E7%9A%84PDF/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/17/%E4%BD%BF%E7%94%A8wkhtmltopdf%E5%B0%86MarkDown%E8%BD%AC%E4%B8%BA%E5%B8%A6%E6%9C%89%E6%A0%87%E7%AD%BE%E7%9A%84PDF/</guid>
        
        
      </item>
    
      <item>
        <title>Shell sed 的简单使用</title>
        <description>&lt;h1 id=&quot;shell-sed-的简单使用&quot;&gt;Shell sed 的简单使用&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sed -i &quot;&quot; 's/aaa/bbbb/g' /Users/Yunis/Desktop/XXX.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这句 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 命令的意思是，查找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;aaa&lt;/code&gt; 把它替换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;bbbb&lt;/code&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/Yunis/Desktop/XXX.py&lt;/code&gt; 是要替换文本的路径。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt; 表示要备份的路径，为空表示不备份。
&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; :替换
&lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt; :全部替换标记&lt;/p&gt;

</description>
        <pubDate>Thu, 17 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/17/Shell-sed-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/17/Shell-sed-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
        
        <category>Shell</category>
        
        
      </item>
    
      <item>
        <title>小团队的iOS代码规范</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;小团队的ios代码规范&quot;&gt;小团队的iOS代码规范&lt;/h1&gt;

&lt;p&gt;本文摘抄自&lt;a font=&quot;24px&quot;&gt;&lt;a href=&quot;https://knightsj.github.io/2017/06/14/iOS%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/#more&quot;&gt;iOS 代码规范&lt;/a&gt;&lt;/a&gt;，稍加修改。&lt;/p&gt;

&lt;h2 id=&quot;1-核心原则&quot;&gt;1 核心原则&lt;/h2&gt;
&lt;h3 id=&quot;11-代码应该简洁易懂逻辑清晰&quot;&gt;1.1 代码应该简洁易懂，逻辑清晰&lt;/h3&gt;
&lt;p&gt;因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不要过分追求技巧，降低程序的可读性。&lt;/li&gt;
  &lt;li&gt;简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-编程时首先达到正确性其次考虑效率&quot;&gt;1.2 编程时首先达到正确性，其次考虑效率&lt;/h3&gt;
&lt;p&gt;在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。&lt;/li&gt;
  &lt;li&gt;先写出可用的代码，反复推敲，再考虑是否需要重用的问题。&lt;/li&gt;
  &lt;li&gt;先写出可用，简单，明显没有bug的代码，再考虑测试的问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-面向变化编程而不是面向需求编程&quot;&gt;1.3 面向变化编程，而不是面向需求编程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;不要相信产品说的话，要时刻做好需求会改的准备。&lt;/strong&gt;
&lt;strong&gt;不要相信产品说的话，要时刻做好需求会改的准备。&lt;/strong&gt;
&lt;strong&gt;不要相信产品说的话，要时刻做好需求会改的准备。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。&lt;/p&gt;
&lt;h2 id=&quot;2-具体规范&quot;&gt;2 具体规范&lt;/h2&gt;
&lt;h3 id=&quot;21-变量属性&quot;&gt;2.1 变量、属性&lt;/h3&gt;
&lt;h6 id=&quot;211-命名必须使用驼峰格式&quot;&gt;2.1.1 命名必须使用驼峰格式&lt;/h6&gt;
&lt;p&gt;类，协议使用大驼峰&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HomePageViewController.h
&amp;lt;HeaderViewDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对象等局部变量使用小驼峰：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *personName = @&quot;&quot;;
NSUInteger totalCount = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;212-变量的名称必须同时包含功能与类型&quot;&gt;2.1.2 变量的名称必须同时包含功能与类型&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIButton *addBtn //添加按钮
UILabel *nameLbl //名字标签
NSString *addressStr//地址字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;213-系统常用类作实例变量声明时加入后缀&quot;&gt;2.1.3 系统常用类作实例变量声明时加入后缀&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;后缀&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;UIViewController&lt;/td&gt;
      &lt;td&gt;VC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UIView&lt;/td&gt;
      &lt;td&gt;View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UILabel&lt;/td&gt;
      &lt;td&gt;Lbl&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UIButton&lt;/td&gt;
      &lt;td&gt;Btn&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UIImage&lt;/td&gt;
      &lt;td&gt;Img&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UIImageView&lt;/td&gt;
      &lt;td&gt;ImagView&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSArray&lt;/td&gt;
      &lt;td&gt;Array&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSMutableArray&lt;/td&gt;
      &lt;td&gt;Marray&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSDictionary&lt;/td&gt;
      &lt;td&gt;Dict&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSMutableDictionary&lt;/td&gt;
      &lt;td&gt;Mdict&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSString&lt;/td&gt;
      &lt;td&gt;Str&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSMutableString&lt;/td&gt;
      &lt;td&gt;MStr&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSSet&lt;/td&gt;
      &lt;td&gt;Set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSMutableSet&lt;/td&gt;
      &lt;td&gt;Mset&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;213-下划线不应出现在局部变量&quot;&gt;2.1.3 下划线不应出现在局部变量&lt;/h4&gt;
&lt;p&gt;推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDictionary *notificationInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDictionary *_notificationInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;214-定义指针类型的变量&quot;&gt;2.1.4 定义指针类型的变量&lt;/h4&gt;
&lt;p&gt;定义指针类型的变量时,&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;放在变量前，与类型保持一个空格。
推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDictionary *notificationInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDictionary*notificationInfo;
NSDictionary* notificationInfo;
NSDictionary * notificationInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;215-不要出现仅依靠大小写区分的命名&quot;&gt;2.1.5 不要出现仅依靠大小写区分的命名&lt;/h4&gt;
&lt;p&gt;程序中不要出现仅靠大小区分的相似的标识符。
不推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSDictionary *notificationInfo;
NSDictionary *NotificationInfo;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;216-私有属性应放到匿名分类中&quot;&gt;2.1.6 私有属性应放到匿名分类中&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RWTDetailViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GADBannerView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;googleAdView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ADBannerView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iAdView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UIWebView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adXWebView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;217-形容词性的bool属性的getter应该加上is前缀&quot;&gt;2.1.7 形容词性的BOOL属性的getter应该加上is前缀&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEditable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;editable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;218-使用getter方法做懒加载&quot;&gt;2.1.8 使用getter方法做懒加载&lt;/h4&gt;

&lt;p&gt;实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//推荐这样写
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demoView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demoView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_demoView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_demoView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bounds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backgroundColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UIColor&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;redColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_demoView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是也有对这种做法的争议，但是整体利大于弊，推荐使用。&lt;/p&gt;

&lt;h4 id=&quot;219-除了-init-和-dealloc-方法建议都使用点语法访问属性&quot;&gt;2.1.9 除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt; 方法，建议都使用点语法访问属性&lt;/h4&gt;

&lt;p&gt;使用点语法的好处：
&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt; 会遵守内存管理语义(&lt;code class=&quot;highlighter-rouge&quot;&gt;strong&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;)。&lt;/li&gt;
  &lt;li&gt;通过在内部设置断点，有助于调试bug。&lt;/li&gt;
  &lt;li&gt;可以过滤一些外部传入的值。&lt;/li&gt;
  &lt;li&gt;捕捉 &lt;code class=&quot;highlighter-rouge&quot;&gt;KVO&lt;/code&gt; 通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;允许子类化。&lt;/li&gt;
  &lt;li&gt;通过在内部设置断点，有助于调试bug。&lt;/li&gt;
  &lt;li&gt;实现懒加载（&lt;code class=&quot;highlighter-rouge&quot;&gt;lazy initialization&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写 &lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt; 方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dealloc&lt;/code&gt; 方法里面使用点语法的后果是：因为没有绕过 &lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt; ，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt; 里面可能会有很多其他的操作。而且如果它的子类重载了它的 &lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt; 方法，那么就可能导致该子类调用其他的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2110-属性声明严把权限&quot;&gt;2.1.10 属性声明严把权限&lt;/h4&gt;

&lt;p&gt;对不需要外部修改的属性使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt; 。&lt;/p&gt;

&lt;h4 id=&quot;2111-尽量使用不可变对象&quot;&gt;2.1.11 尽量使用不可变对象&lt;/h4&gt;
&lt;p&gt;建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在头文件中，设置对象属性为 &lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在实现文件中设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;readwrite&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-函数&quot;&gt;2.2 函数&lt;/h3&gt;

&lt;h4 id=&quot;221-函数保持单一性&quot;&gt;2.2.1 函数保持单一性&lt;/h4&gt;
&lt;p&gt;函数是为一特定功能而编写，不是万能工具箱，保持单一性，一个函数只做一件事情。&lt;/p&gt;

&lt;h4 id=&quot;222-函数名与形参不能留空格返回类型与函数标识符有一个空格&quot;&gt;2.2.2 函数名与形参不能留空格，返回类型与函数标识符有一个空格&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)someMethod:(id)parameter;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;223-如果参数过长则每个参数一行以冒号对齐&quot;&gt;2.2.3 如果参数过长，则每个参数一行，以冒号对齐。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)someMethod:(id)parameter
        parameter1:(id)parameter1
        parameter2:(id)parameter2;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;224-如果函数名比参数名短则每个参数占用一行垂直对齐非冒号对齐&quot;&gt;2.2.4 如果函数名比参数名短，则每个参数占用一行,垂直对齐（非冒号对齐）&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)someMethod:(id)parameter
        a:(id)parameter1
        b:(id)parameter2;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;225-函数名用小写字母开头的单词组合而成&quot;&gt;2.2.5 函数名用小写字母开头的单词组合而成&lt;/h4&gt;

&lt;p&gt;函数名力求清晰、明了、通过函数名就能够判断函数的主要功能。函数名中不同意义字段之间不要用下划线连接，而要把每个字段的首字母大写以示区分。&lt;/p&gt;

&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)descriptionWithLocale:(id)locale;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)DescriptionWithLocale:(id)locale;
- (NSString *)description_locale:(id)locale;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;226-避免函数有太多的参数参数个数尽量控制在5个以内&quot;&gt;2.2.6 避免函数有太多的参数，参数个数尽量控制在5个以内&lt;/h4&gt;
&lt;p&gt;如果参数的确比较多，考虑这些参数定义成一个结构（或一个类）。&lt;/p&gt;

&lt;h4 id=&quot;227-对输入参数的正确性和有效性进行检查&quot;&gt;2.2.7 对输入参数的正确性和有效性进行检查&lt;/h4&gt;
&lt;p&gt;很多程序错误和崩溃是由非法参数引起的。对外提供的函数接口，一定要检查输入参数。
对输入参数的正确性和有效性进行检查，参数错误立即返回。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void function(param1,param2)
{
      if(param1 is unavailable) {
           return;
      }
    
      if(param2 is unavailable) {
           return;
      }
     //Do some right thing
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;228-函数方法体的规模不能太大&quot;&gt;2.2.8 函数（方法）体的规模不能太大&lt;/h4&gt;
&lt;p&gt;函数（方法）体的规模不能太大，尽量控制在可以在一屏幕内显示。&lt;/p&gt;

&lt;h4 id=&quot;229-对于有返回值的函数方法每一个分支都必须有返回值&quot;&gt;2.2.9 对于有返回值的函数（方法），每一个分支都必须有返回值&lt;/h4&gt;

&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int function()
{
    if(condition1) {
        return count1
    }
    else if(condition2) {
        return count2
    }
    else {
       return defaultCount
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int function()
{
    if(condition1) {
        return count1
    }
    else if(condition2) {
        return count2
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2210-如果在不同的函数内部有相同的功能&quot;&gt;2.2.10 如果在不同的函数内部有相同的功能&lt;/h4&gt;
&lt;p&gt;如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数&lt;/p&gt;

&lt;h4 id=&quot;2211-方法名前缀&quot;&gt;2.2.11 方法名前缀&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;刷新视图的方法名要以 &lt;code class=&quot;highlighter-rouge&quot;&gt;refresh&lt;/code&gt; 为首。&lt;/li&gt;
  &lt;li&gt;更新数据的方法名要以 &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 为首。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)refreshHeaderViewWithCount:(NSUInteger)count;

- (void)updateDataSourceWithViewModel:(ViewModel *)viewModel;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2212-函数之间保留一个空行&quot;&gt;2.2.12 函数之间保留一个空行&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)refreshHeaderViewWithCount:(NSUInteger)count;

- (void)updateDataSourceWithViewModel:(ViewModel *)viewModel;

- (void)refreshHeaderViewWithCount:(NSUInteger)count
{
}

- (void)updateDataSourceWithViewModel:(ViewModel *)viewModel
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2213-初始化方法&quot;&gt;2.2.13 初始化方法&lt;/h4&gt;
&lt;p&gt;初始化方法返回类型必须是 &lt;code class=&quot;highlighter-rouge&quot;&gt;instancetype&lt;/code&gt; ，不能是 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (instancetype)init { 
    self = [super init]; // call the designated initializer 
    if (self) { 
        // Custom initialization 
    } 
    return self; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;23-if-语句&quot;&gt;2.3 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句&lt;/h3&gt;

&lt;h4 id=&quot;231-必须列出所有分支穷举所有的情况而且每个分支都必须给出明确的结果&quot;&gt;2.3.1 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var hintStr;
if (count &amp;lt; 3) {
  hintStr = &quot;Good&quot;;
} 
else {
  hintStr = &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var hintStr;
if (count &amp;lt; 3) {
 hintStr = &quot;Good&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;232-不要使用过多的分支要善于使用-return-来提前返回错误的情况&quot;&gt;2.3.2 不要使用过多的分支，要善于使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; 来提前返回错误的情况&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)someMethod { 
  if (!goodCondition) {
    return;
  }
  //Do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)someMethod { 
  if (goodCondition) {
    //Do something
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;233-条件表达式如果很长则需要将他们提取出来赋给一个-bool-值&quot;&gt;2.3.3 条件表达式如果很长，则需要将他们提取出来赋给一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;BOOL&lt;/code&gt; 值&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nameContainsSwift = sessionName.hasPrefix(&quot;Swift&quot;)
let isCurrentYear = sessionDateCompontents.year == 2014
let isSwiftSession = nameContainsSwift &amp;amp;&amp;amp; isCurrentYear
if (isSwiftSession) { 
   // Do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ( sessionName.hasPrefix(&quot;Swift&quot;) &amp;amp;&amp;amp; (sessionDateCompontents.year == 2014) ) { 
    // Do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;234-条件语句的判断应该是变量在左常量在右&quot;&gt;2.3.4 条件语句的判断应该是变量在左，常量在右&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ( count == 6 ) {
}

if ( count == 6 ) {
}

if ( object == nil ) {
}

if ( !object ) {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ( 6 == count ) {
}

if ( nil == object ) {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;235-每个分支的实现代码都必须被大括号包围&quot;&gt;2.3.5 每个分支的实现代码都必须被大括号包围&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ( !error ) {
  return success;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ( !error )
    return success;

if ( !error ) return success;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;236--条件过多过长的时候应该换行&quot;&gt;2.3.6  条件过多，过长的时候应该换行&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (condition1() &amp;amp;&amp;amp; 
    condition2() &amp;amp;&amp;amp; 
    condition3() &amp;amp;&amp;amp; 
    condition4()) {
  // Do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (condition1() &amp;amp;&amp;amp; condition2() &amp;amp;&amp;amp; condition3() &amp;amp;&amp;amp; condition4()) {
  // Do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;24-注释&quot;&gt;2.4 注释&lt;/h3&gt;
&lt;p&gt;推荐写注释，但不是必须的，有以下几种情况是必须写注释的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。&lt;/li&gt;
  &lt;li&gt;涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。&lt;/li&gt;
  &lt;li&gt;容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;每次修改代码后，要相应的修改注释。
每次修改代码后，要相应的修改注释。
每次修改代码后，要相应的修改注释。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;25-运算符&quot;&gt;2.5 运算符&lt;/h3&gt;

&lt;h4 id=&quot;251-一元运算符与变量之间没有空格&quot;&gt;2.5.1 一元运算符与变量之间没有空格&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!bValue
~iValue
++iCount
*strSource
&amp;amp;fSum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;252-二元运算符与变量之间必须有空格&quot;&gt;2.5.2 二元运算符与变量之间必须有空格&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fWidth = 5 + 5;
fLength = fWidth * 2;
fHeight = fWidth + fLength;
for(int i = 0; i &amp;lt; 10; i++)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;253-多个不同的运算符同时存在时应该使用括号来明确优先级&quot;&gt;2.5.3 多个不同的运算符同时存在时应该使用括号来明确优先级&lt;/h4&gt;

&lt;p&gt;在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。
因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。&lt;/p&gt;
&lt;h3 id=&quot;26-switch-语句&quot;&gt;2.6 &lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; 语句&lt;/h3&gt;

&lt;h4 id=&quot;261-每个分支都必须用大括号括起来&quot;&gt;2.6.1 每个分支都必须用大括号括起来&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch (integer) {  
  case 1:  {
    // ...  
    break;  
   }
  case 2: {  
    // ...  
    break;  
  }  
  case 3: {
    // ...  
    break; 
  }
  default:{
    // ...  
    break; 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;262--使用枚举类型时不能有-default-分支-除了使用枚举类型以外都必须有-default-分支&quot;&gt;2.6.2  使用枚举类型时，不能有 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 分支， 除了使用枚举类型以外，都必须有 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 分支&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;  
switch (menuType) {  
  case RWTLeftMenuTopItemMain: {
    // ...  
    break; 
   }
  case RWTLeftMenuTopItemShows: {
    // ...  
    break; 
  }
  case RWTLeftMenuTopItemSchedule: {
    // ...  
    break; 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;27-单例模式&quot;&gt;2.7 单例模式&lt;/h3&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)sharedInstance {
    static id sharedInstance = nil;
    static dispatch_once_t onceToken = 0;
    dispatch_once(&amp;amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;不推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)sharedInstance {
    static id sharedInstance;
    @synchronized(self) {
        if (sharedInstance == nil) {
            sharedInstance = [[MyClass alloc] init];
        } }
    return sharedInstance; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;28-文件目录&quot;&gt;2.8 文件目录&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 工程文件的物理路径要和逻辑路径保持一致。&lt;/p&gt;
&lt;h3 id=&quot;29-字面量&quot;&gt;2.9 字面量&lt;/h3&gt;
&lt;p&gt;在编码中应多用字面量语法，少用与之等价的方法。&lt;/p&gt;

&lt;h4 id=&quot;291-声明时的字面量语法&quot;&gt;2.9.1 声明时的字面量语法&lt;/h4&gt;
&lt;p&gt;在声明 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSNumber&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSArray&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt; 时，应该尽量使用简洁字面量语法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSNumber *intNumber = @1;
NSNumber *floatNumber = @2.5f;
NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;,@&quot;mouse&quot;, @&quot;badger&quot;];
Dictionary *dict = @{@&quot;animal&quot;:@&quot;tiger&quot;,@&quot;phone&quot;:@&quot;iPhone 6&quot;};

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;292-集合类取下标的字面量语法&quot;&gt;2.9.2 集合类取下标的字面量语法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *cat = animals[0];
NSString *iphone = dict[@&quot;phone&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;210-nsarray-和-nsdictionary&quot;&gt;2.10 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSArray&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&quot;2101-尽可能的使用字面量初始化&quot;&gt;2.10.1 尽可能的使用字面量初始化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;,@&quot;mouse&quot;, @&quot;badger&quot;];
Dictionary *dict = @{@&quot;animal&quot;:@&quot;tiger&quot;,@&quot;phone&quot;:@&quot;iPhone 6&quot;};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2102-使用泛型&quot;&gt;2.10.2 使用泛型&lt;/h4&gt;
&lt;p&gt;在定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSArray&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt; 时使用泛型，可以保证程序的安全性，而且在使用 枚举块 函数时会自动识别 &lt;strong&gt;item&lt;/strong&gt; 类型&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray &amp;lt;NSString *&amp;gt;*testArr = [NSArray arrayWithObjects:@&quot;Hello&quot;, @&quot;world&quot;, nil];
NSDictionary &amp;lt;NSString *, NSNumber *&amp;gt;*dic = @{@&quot;key&quot;:@(1), @&quot;age&quot;:@(10)};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2103-判断边界&quot;&gt;2.10.3 判断边界&lt;/h4&gt;
&lt;p&gt;数组取下标的时候尽可能的判断是否越界。&lt;/p&gt;

&lt;h4 id=&quot;2104-取第一个元素或最后一个元素的时候使用系统提供的方法&quot;&gt;2.10.4 取第一个元素或最后一个元素的时候使用系统提供的方法&lt;/h4&gt;
&lt;p&gt;取第一个元素或最后一个元素的时候使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;firtstObject&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;lastObject&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;2105--非空判断&quot;&gt;2.10.5  非空判断&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;addObject&lt;/code&gt; 之前要非空判断。&lt;/p&gt;

&lt;h4 id=&quot;2106-多用枚举块&quot;&gt;2.10.6 多用枚举块&lt;/h4&gt;
&lt;p&gt;当遍历集合元素时，建议使用块枚举，因为相对于传统的 &lt;strong&gt;for&lt;/strong&gt; 循环，它更加高效，而且简洁,还能获取到用传统的 &lt;strong&gt;for&lt;/strong&gt; 循环无法提供的值.&lt;/p&gt;

&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray &amp;lt;SYPushUserModel *&amp;gt;*sourceArray = @[...];
[sourceArray enumerateObjectsUsingBlock:^(SYPushUserModel * obj, NSUInteger idx, BOOL * stop) {
            
}];

NSDictionary &amp;lt;NSString *,SYPushUserModel *&amp;gt;*sourceDic = @{...};
[sourceDic enumerateKeysAndObjectsUsingBlock:^(NSString * key, SYPushUserModel * obj, BOOL * stop) {
        
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;211-类&quot;&gt;2.11 类&lt;/h3&gt;

&lt;h4 id=&quot;2111-类的布局&quot;&gt;2.11.1 类的布局&lt;/h4&gt;
&lt;p&gt;推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma mark - Life Cycle
- (instancetype)init;

- (void)viewDidLoad;

- (void)viewWillAppear:(BOOL)animated;

- (void)viewDidAppear:(BOOL)animated;

- (void)dealloc

#pragma mark - Intial Methods
//初始化数据
- (void)assignDate

- (void)settingAppearance

- (void)loadSubViews

#pragma mark - Target Methods
//点击事件或通知事件

#pragma mark - Network Methods
//网络请求

#pragma mark - Public Method
//外部方法

#pragma mark - Private Method
//本类方法

#pragma mark - Delegate
//代理方法

#pragma mark - Lazy Loads
//懒加载 Getter方法

#pragma mark - set
//Setter方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2112-在类声明中包含多个-protocol&quot;&gt;2.11.2 在类声明中包含多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;如果在类声明中包含多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;，每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Protocol&lt;/code&gt; 占用一行，与第一个对齐，保持清晰易读。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface SYNotificationTool : NSObject&amp;lt;UNUserNotificationCenterDelegate,
                                         UITableViewDelegate,
                                         UITableViewDataSource,
                                         UITabBarControllerDelegate,
                                         UIContentSizeCategoryAdjusting&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果第一行显示不完全，推荐&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface SYOpenMessageListNotificationTool : NSObject
&amp;lt;
UNUserNotificationCenterDelegate,
UITableViewDelegate,
UITableViewDataSource,
UITabBarControllerDelegate,
UIContentSizeCategoryAdjusting
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2113-把类的实现代码分散到便于管理的多个分类中&quot;&gt;2.11.3 把类的实现代码分散到便于管理的多个分类中&lt;/h4&gt;
&lt;p&gt;一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用 &lt;strong&gt;Objecctive-C&lt;/strong&gt; 的分类机制，将类的这些方法按一定的逻辑划入几个分区中。使得代码逻辑清晰，便于维护。&lt;/p&gt;

&lt;h3 id=&quot;212-枚举&quot;&gt;2.12 枚举&lt;/h3&gt;
&lt;p&gt;要多使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;NS_ENUM&lt;/code&gt;,尽量少使用 C 语言风格的&lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;2121-用枚举表示状态选项状态码&quot;&gt;2.12.1 用枚举表示状态，选项，状态码&lt;/h4&gt;
&lt;p&gt;推荐使用用枚举表示状态，选项，状态码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSUInteger, EOCConnectionState) {
  EOCConnectionStateDisconnected,
  EOCConnectionStateConnecting,
  EOCConnectionStateConnected,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2122-使用枚举类型时不能有-default-分支&quot;&gt;2.12.2 使用枚举类型时，不能有 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 分支&lt;/h4&gt;
&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; 语句使用枚举类型时，不能有 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 分支， 除了使用枚举类型以外，都必须有 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 分支
在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; 语句使用枚举类型的时候，如果使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 分支，在将来就无法通过编译器来检查新增的枚举类型了。&lt;/p&gt;

&lt;h3 id=&quot;213-大括号该不该换行&quot;&gt;2.13 大括号该不该换行&lt;/h3&gt;
&lt;p&gt;仁者见仁，智者见智的问题。&lt;/p&gt;

&lt;p&gt;程序的分界符 &lt;strong&gt;{&lt;/strong&gt; 和 &lt;strong&gt;}&lt;/strong&gt; 在 &lt;strong&gt;if&lt;/strong&gt;、&lt;strong&gt;else&lt;/strong&gt;、&lt;strong&gt;else if&lt;/strong&gt;、&lt;strong&gt;for&lt;/strong&gt;、&lt;strong&gt;while&lt;/strong&gt;、&lt;strong&gt;do&lt;/strong&gt;等语句时， &lt;strong&gt;{&lt;/strong&gt; 前添加空格紧跟语句后，空格分割。在方法（函数）应独占一行并且位于同一列，同时与引用他们的语句对齐。 &lt;strong&gt;{}&lt;/strong&gt; 之内的代码块使用缩进规则对齐。&lt;/p&gt;

&lt;p&gt;推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dealloc
{
    // Do Something
}

if (isUpdated) {
    // Do Something
}

if (user.isHappy) {
    //Do something
}
else {
    //Do something else
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;214-常量&quot;&gt;2.14 常量&lt;/h3&gt;

&lt;h4 id=&quot;2141-常量应该以相关类名作为前缀&quot;&gt;2.14.1 常量应该以相关类名作为前缀&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;推荐：
static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4;
不推荐：
static const NSTimeInterval fadeOutTime = 0.4;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2142-建议使用类型常量不建议使用-define-预处理命令&quot;&gt;2.14.2 建议使用类型常量，不建议使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt; 预处理命令&lt;/h4&gt;
&lt;p&gt;首先比较一下这两种声明常量的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。&lt;/li&gt;
  &lt;li&gt;类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不具备类型信息。&lt;/li&gt;
  &lt;li&gt;可以被任意修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2143-对外公开某个常量&quot;&gt;2.14.3 对外公开某个常量&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;推荐：
//头文件
extern NSString *const ZOCCacheControllerDidClearCacheNotification;
//实现文件
static NSString * const ZOCCacheControllerDidClearCacheNotification = @&quot;ZOCCacheControllerDidClearCacheNotification&quot;;
static const CGFloat ZOCImageThumbnailHeight = 50.0f;

不推荐：
#define CompanyName @&quot;Apple Inc.&quot; 
#define magicNumber 42
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;215-宏&quot;&gt;2.15 宏&lt;/h3&gt;

&lt;h4 id=&quot;2151-宏常量名都要使用大写字母用下划线-_-分割单词&quot;&gt;2.15.1 宏、常量名都要使用大写字母，用下划线 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 分割单词。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define URL_GAIN_QUOTE_LIST @&quot;/v1/quote/list&quot;
#define URL_UPDATE_QUOTE_LIST @&quot;/v1/quote/update&quot;
#define URL_LOGIN  @&quot;/v1/user/login”
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2152-宏定义中如果包含表达式或变量表达式和变量必须用小括号括起来&quot;&gt;2.15.2 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define MY_MIN(A, B)  ((A)&amp;gt;(B)?(B):(A))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;216-其他&quot;&gt;2.16 其他&lt;/h3&gt;

&lt;h4 id=&quot;2161-小括号内联复合表达式&quot;&gt;2.16.1 小括号内联复合表达式&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;A compound statement enclosed in parentheses&lt;/em&gt;。推荐使用，形式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RETURN_VALUE_RECEIVER = {(
    // Do whatever you want
    RETURN_VALUE; // 返回值
)};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化时推荐使用，有点像&lt;strong&gt;block&lt;/strong&gt;和内联函数的结合体，它最大的意义在于将代码整理分块，将同一个逻辑层级的代码包在一起；逻辑清晰，也方便拷贝使用。
推荐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIView *backgroundView = ({
    UIView *view = [[UIView alloc] initWithFrame:self.view.bounds];
    view.backgroundColor = [UIColor redColor];
    view.alpha = 0.8f;
    view;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2162-源代码中关系较为紧密的代码应尽可能相邻&quot;&gt;2.16.2 源代码中关系较为紧密的代码应尽可能相邻&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGFloat fWidth;
CGFloat fLength;
CGFloat fHeight;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2163-相关的赋值语句等号对齐&quot;&gt;2.16.3 相关的赋值语句等号对齐&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promotionsEntity.promotionImageStr   = activityItemDict[@&quot;promotion_image&quot;];
promotionsEntity.promotionIdNum      = activityItemDict[@&quot;promotion_id&quot;];
promotionsEntity.promotionNameStr    = activityItemDict[@&quot;promotion_name&quot;];
promotionsEntity.promotionColorStr   = activityItemDict[@&quot;promotion_color&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 11 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/11/%E5%B0%8F%E5%9B%A2%E9%98%9F%E7%9A%84iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/11/%E5%B0%8F%E5%9B%A2%E9%98%9F%E7%9A%84iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
        
        
      </item>
    
  </channel>
</rss>
