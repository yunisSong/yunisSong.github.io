<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三十一</title>
    <description>潜心修行中。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 11 May 2017 14:04:15 +0800</pubDate>
    <lastBuildDate>Thu, 11 May 2017 14:04:15 +0800</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>Javascrpt高级程序设计(第3版)读书笔记01</title>
        <description>&lt;h1 id=&quot;javascrpt高级程序设计第3版读书笔记01&quot;&gt;Javascrpt高级程序设计(第3版)读书笔记01&lt;/h1&gt;

&lt;h3 id=&quot;script-元素&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 元素&lt;/h3&gt;
&lt;p&gt;向 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 页面加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 的主要方法，就是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 。
包括6个属性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 可选。表示立即下载脚本，但不妨碍页面的其他操作，比如下载其他资源或者脚本。只对外部脚本文件有效。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;charset&lt;/code&gt; 可选。 表示通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本有效。IE7 级更早的版本对嵌入脚本也支持这个属性。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;language&lt;/code&gt; 已废弃。用来表示编写代码使用的脚本语言。（如JavaScript、VBScript）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 可选。表示包含要执行代码的外部文件。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt; 可选。可以看成是 language 的替代属性。 表示编写代码使用脚本语言的类型（也称为MIME类型）。虽然 &lt;code class=&quot;highlighter-rouge&quot;&gt;text/javascript&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;text/ecmascript&lt;/code&gt; 都已经不被推荐使用,但人们一直以来使用个还是 &lt;code class=&quot;highlighter-rouge&quot;&gt;text/javascript&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 的方式有两种在：直接在页面中嵌入 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 代码和包含外部 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;包含在 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 内部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 的代码会被从上到下依次解释。浏览器会先解析完不使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; 的属性的 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 元素中的代码，然后再解析后面的内容，所以一般应该把 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 元素放在页面最后，即主要内容后面，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;标签前面。
带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; 属性的 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 标签会忽略 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 标签之间包含的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 代码。&lt;/p&gt;

&lt;h4 id=&quot;应当尽量使用外部文件&quot;&gt;应当尽量使用外部文件&lt;/h4&gt;
&lt;p&gt;虽然直接在 &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 元素 中直接嵌入 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 代码没什么问题，但是一般认为最好的做法还是尽可能的使用外部文件来包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 代码，好处包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可维护性 避免 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 页面过于臃肿，同时把 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 文件放在一个文件夹下面，利于维护。&lt;/li&gt;
  &lt;li&gt;可缓存 浏览器能够根据具体的设置 缓存链接的所有外部 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 文件。也就是如果两个页面使用同一个文件，就无需再次下载。加快了页面的加载速度。&lt;/li&gt;
  &lt;li&gt;适应未来 通过外部文件来包含 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 无需使用 XHTML 或注释hack。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;noscript-元素&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;noscript&lt;/code&gt; 元素&lt;/h3&gt;
&lt;p&gt;兼容早期不支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 的浏览器，这个元素可以包含能够出现在 &lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt; 的任何 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt; 元素 （&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 除外），包含在 &lt;code class=&quot;highlighter-rouge&quot;&gt;noscript&lt;/code&gt; 元素的内容会在下面两张情况显示：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;浏览器不支持脚本；&lt;/li&gt;
  &lt;li&gt;浏览器支持脚本，但是脚本被禁止。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;h4 id=&quot;语法&quot;&gt;语法&lt;/h4&gt;
&lt;h5 id=&quot;区分大小写&quot;&gt;区分大小写&lt;/h5&gt;
&lt;p&gt;变量、函数名、操作符、语言中的一切，都区分大小写。&lt;/p&gt;
&lt;h5 id=&quot;标识符&quot;&gt;标识符&lt;/h5&gt;
&lt;p&gt;标识符指的是变量、函数、属性的名字，或者函数的参数。有以下规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一个字符必须是一个字母、下划线（_）或者一个美元符号（$）；&lt;/li&gt;
  &lt;li&gt;其他字符可以是字母、下划线、美元符号或者数字；&lt;/li&gt;
  &lt;li&gt;惯例是采用驼峰命名法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;注释&quot;&gt;注释&lt;/h5&gt;
&lt;p&gt;// 单行注释
/* */ 多行注释&lt;/p&gt;

&lt;h5 id=&quot;严格模式&quot;&gt;严格模式&lt;/h5&gt;
&lt;p&gt;目前来说就是对一些不确定的行为进行处理、对某些不安全的操作抛出错误。 还不是很理解。启用的话 需要在函数体前面加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;use strict&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&quot;语句&quot;&gt;语句&lt;/h5&gt;
&lt;p&gt;语句已一个分号结尾，如果没有分号，由编译器决定什么时间结尾。&lt;/p&gt;

&lt;h5 id=&quot;变量&quot;&gt;变量&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 中的变量是松散类型，就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符。未初始化的变量，会保存一个特殊值 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;。变量在初始化后，可以改变变量的类型，虽然并不推荐，但是这样做是可以的。&lt;/p&gt;

&lt;h4 id=&quot;数据类型&quot;&gt;数据类型&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 中包括5种简单的数据类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;Undefined、Null、Boolean、Number、String&lt;/code&gt;。简单数据类型值无法被改变，每次赋值的时候，都是赋值一份新的值。还有一种复杂的数据类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 本质是有一组无序的键值对组成的。&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 不支持任何创建自定义类型的机制，所有值的最终都将是上述6种数据类型之一。好像只有6种数据类型不能表示所有的数据，但是，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt; 数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。&lt;/p&gt;

&lt;h5 id=&quot;typeof-操作符&quot;&gt;typeof 操作符&lt;/h5&gt;
&lt;p&gt;typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。
它返回值是一个字符串，该字符串说明运算数的类型。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于数字类型的操作数而言， typeof 返回的值是 number。&lt;/li&gt;
  &lt;li&gt;对于字符串类型， typeof 返回的值是 string。&lt;/li&gt;
  &lt;li&gt;对于布尔类型， typeof 返回的值是 boolean 。&lt;/li&gt;
  &lt;li&gt;对于对象、数组、null 返回的值是 object 。&lt;/li&gt;
  &lt;li&gt;对于函数类型，返回的值是 function。&lt;/li&gt;
  &lt;li&gt;如果运算数是没有定义的（比如说不存在的变量、函数或者undefined），将返回undefined。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;undefined-类型&quot;&gt;Undefined 类型&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Undefined&lt;/code&gt; 类型只有一个值，即特殊的 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;， 一个没有被赋值的变量会有个默认值 &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;null-类型&quot;&gt;Null 类型&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Null&lt;/code&gt; 是第二个只有一个值的数据类型，这个特殊的值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;。从逻辑角度来看， &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 值表示一个空对象的指针，而这也正是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;typeof&lt;/code&gt; 操作符检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; 值时会返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt; 的原因。
如果一个变量准备保存对象，那么最好将该变量初始化为 null 而不是其他值。这样一来只需要检查 null 值就可以判断变量是否已经保存了一个对象的引用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (car != null){
    //   car         
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;undefined 值是派生自 null。因此比较 null 和 undefined 是返回值是 true。&lt;/p&gt;
&lt;h5 id=&quot;boolean-类型&quot;&gt;Boolean 类型&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt; 类型 只有两个字面值： &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;number-类型&quot;&gt;Number 类型&lt;/h5&gt;
&lt;h6 id=&quot;浮点数值&quot;&gt;浮点数值&lt;/h6&gt;
&lt;p&gt;浮点数值，就是数值中必须包含一个小数点，且小数点后面必须至少有以为数字。如果浮点数本身表示是一个整数（如1.0或者1.），会被转换为整数（1）。
对于那些极大或者极小的数，可以使用科学计数法表示：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;3.125e7 表示31250000  计算方法为：3.125 * 10^7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;数值范围&quot;&gt;数值范围&lt;/h6&gt;
&lt;p&gt;Number.MIN_VALUE 表示最小数，一般为 5e-324，Number.MAX_VALUE 表示最大数,一般为1.7976931348623157e+308。如果超出这个范围，会被转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Infinity&lt;/code&gt;，将无法再参与计算。判断一个数值是个超出范围，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;isFinite()&lt;/code&gt; 函数。&lt;/p&gt;

&lt;h6 id=&quot;nan&quot;&gt;NaN&lt;/h6&gt;

&lt;p&gt;NaN,非数值的一个特殊的数值。这个数值用来表示本来要返回数值的操作数未返回数值的情况（这样做的好处是不会抛出错误）。
NaN 本身有两个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任何涉及 NaN 的操作，都会返回 NaN，&lt;/li&gt;
  &lt;li&gt;NaN 与任何值都不等，包括 NaN本身。判断是否是 NaN 需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;isNaN()&lt;/code&gt; 函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;数值转换&quot;&gt;数值转换&lt;/h6&gt;

&lt;p&gt;有3个函数可以把非数值转换为数值：&lt;code class=&quot;highlighter-rouge&quot;&gt;Number() parseInt()  parseFloat()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Number()&lt;/code&gt; 转换有如下规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果是 Boolean 值，true 和 false 分别转换为 1 和 0；&lt;/li&gt;
  &lt;li&gt;如果是数字值，只是简单的传入传出；&lt;/li&gt;
  &lt;li&gt;如果是 null，返回 0；&lt;/li&gt;
  &lt;li&gt;如果是 undefined ，返回 NaN；&lt;/li&gt;
  &lt;li&gt;如果是字符串，有以下规则：
    &lt;ol&gt;
      &lt;li&gt;如果字符串只包含数字，转换为十进制的数值。（”1” -&amp;gt; 1,”011”-&amp;gt; 11）&lt;/li&gt;
      &lt;li&gt;如果字符串中包含有效的浮点格式，转换为对应的浮点数值。&lt;/li&gt;
      &lt;li&gt;如果对象包含有效的十六进制格式，转换为相同大小的十进制整数值。(“1.1” -&amp;gt; 1.1)&lt;/li&gt;
      &lt;li&gt;如果字符串是空的（不包含任何字符），转为 0；(“”-&amp;gt;0)&lt;/li&gt;
      &lt;li&gt;如果字符串中包含上述格式之外的字符，转换为 NaN。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果是对象，调用对象的 valueOf()，然后依据前面的规则转换返回值。如果转换的结果是NaN，调用对象的 toString()方法，然后在依次调用前面的规则转换返回的字符串值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt()&lt;/code&gt; 函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;忽略字符串前面的空格，直到找到第一非空格的字符。&lt;/li&gt;
  &lt;li&gt;如果第一个字符不是数字或者负号，返回NaN；&lt;/li&gt;
  &lt;li&gt;空字符串返回NaN&lt;/li&gt;
  &lt;li&gt;如果第一个字符就是数字，继续解析下面的字符，直到完全解析完或者遇到了非数字字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;``` parseInt(“1234blue”); //1234
parseInt(“”); //NaN
parseInt(“0xA”); //10 (16进制)
parseInt(22.5); //22
parseInt(“070”) //56(8进制)
parseInt(“70”); //70
parseInt(“0xf”); //15(16进制)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

`parseFloat()` 函数：


```parseFloat(&quot;1234blue&quot;); //1234
parseFloat(&quot;0xA&quot;); //0
parseFloat(&quot;22.5&quot;); //22.5
parseFloat(&quot;22.34.5&quot;); //22.34
parseFloat(&quot;0908.5&quot;); 908.5
parseFloat(&quot;3.125e7&quot;); //31250000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;string-类型&quot;&gt;String 类型&lt;/h5&gt;

&lt;p&gt;可以使用单引号和双引号来表示字符串，”hello” 和 ‘hello’都是正确的，但是不能使用一个单引号和一个双引号。&lt;/p&gt;

&lt;h6 id=&quot;字符字面量&quot;&gt;字符字面量&lt;/h6&gt;
&lt;p&gt;String 数据类型包含一些特殊的字符字面量，也就转义序列，用于表示非打印字符，或者具有其他用途的字符。&lt;/p&gt;

&lt;p&gt;```\n 换行
\t 制表
\b 空格
\r 回车
\f 换页 
\ 斜杠
' 单引号
&quot; 双引号
\xnn 16进制 n 为 （0 -F）例： \x41 表示为 A
\unnn 以16进制代码 nnnn 表示的 Unicode 字符，其中n 为 0 - F ，例如\u03a3 表示希腊字符Σ。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;###### 字符串的特点
字符串的值类型，是不可变的。要改变某个变量保存的值，必须先销毁原来的字符串，然后创建新的字符串填充给变量。
###### 转换为字符串
要把一个值转换为字符串有两种方法：

* 第一种是几乎每个值都有的 toString() 方法。
* 在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用 String() ，这个函数可以将任何类型转换为字符串。String() 函数遵循以下规则：
    1. 如果值有 toString() 方法，使用 toString() 方法并返回响应结果；
    2. 如果值是 null ，则返回 &quot;null&quot;;
    3. 如果值是 undefined ，则返回 &quot;undefined&quot;



例子：

```JavaScript
var age = 11;
var ageAsString = age.toString(); //    &quot;11&quot; var found = true;
var foundAsString = found.toString(); //    &quot;true&quot;


var num = 10;
alert(num.toString());// &quot;10&quot;
alert(num.toString(2));// &quot;1010&quot;
alert(num.toString(8));// &quot;12&quot;
alert(num.toString(10));// &quot;10&quot;
alert(num.toString(16));// &quot;a&quot;


var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1));// &quot;10&quot;
alert(String(value2));// &quot;true&quot;
alert(String(value3));// &quot;null&quot;
alert(String(value4));// &quot;undefined&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;object-类型&quot;&gt;Object 类型&lt;/h5&gt;

&lt;p&gt;ECMAScript 中对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型名称来创建。
object 的每一个实例都有如下方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;constructor 保存着用于创建当前对象的函数&lt;/li&gt;
  &lt;li&gt;hasOwnProperty(propertyName) 用于检测 propertyName 是否在当前实例的属性中。&lt;/li&gt;
  &lt;li&gt;isPrototypeOf(object) 用于检测传入的对象 object 是否是当前本对象的原型，表示指定的对象是否在本对象的原型链中。&lt;/li&gt;
  &lt;li&gt;propertyIsEnumerable(propertyName) 判断指定属性是否可枚举，内部属性设置参见 ECMAScript DontEnum attribute&lt;/li&gt;
  &lt;li&gt;toLocaleString() 返回对象的字符串表示，该字符串与执行环境的地区对应。&lt;/li&gt;
  &lt;li&gt;toString() 返回对象的字符串表示&lt;/li&gt;
  &lt;li&gt;valueOf() 返回对象的字符串、数值、布尔值表示 。通常与 toString() 方法的返回值一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;操作符&quot;&gt;操作符&lt;/h4&gt;

</description>
        <pubDate>Wed, 10 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/10/Javascrpt%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC3%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-01/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/10/Javascrpt%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC3%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-01/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScript学习01</title>
        <description>&lt;h1 id=&quot;javascript学习01&quot;&gt;JavaScript学习01&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;开始观看这系列文章 
  &lt;a href=&quot;https://yq.aliyun.com/articles/30980&quot;&gt;从零开始学_JavaScript_系列（一）初步概念、工具选择、简单内容输出、加载js文件&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;script-标签&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; 标签&lt;/h3&gt;
&lt;p&gt;HTML的脚本必须位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 之中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;

JS脚本

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;标签&quot;&gt;标签&lt;/h3&gt;
&lt;p&gt;成对出现的&amp;lt;&amp;gt;（共2组）就是标签。
如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;文本&amp;lt;/p&amp;gt;&lt;/code&gt; 就是一组标签。&lt;/p&gt;

&lt;p&gt;标签可以加id，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p id=&quot;abc&quot;&amp;gt;文本&amp;lt;/p&amp;gt;&lt;/code&gt; ，id用于之后寻找其使用。&lt;/p&gt;

&lt;p&gt;寻找id使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;getElementById(&quot;abc&quot;)&lt;/code&gt; 这样的办法。&lt;/p&gt;

&lt;p&gt;然后在这样的命令后面加对应的东西，如innerHTML（文本替换），value（得到值）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p id=&quot;abc&quot;&amp;gt;abc&amp;lt;/p&amp;gt;

&amp;lt;button type=&quot;button&quot; onclick=&quot;run()&quot;&amp;gt;点击&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;

function run()
{
document.getElementById(&quot;abc&quot;).innerHTML=&quot;ppp&quot;;

}

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;像这样的代码，在执行时，用ppp文本替换abc文本。&lt;/p&gt;

&lt;p&gt;第一行是输出文字abc，然后给他一个id（用来找她）。&lt;/p&gt;

&lt;p&gt;第二行是输出一个按钮（button），按钮上面的文字是点击。&lt;/p&gt;

&lt;p&gt;第三行到最后 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 是js脚本。这个脚本里面包含了一个函数（function）；&lt;/p&gt;

&lt;p&gt;函数的效果是，在标签id为abc的地方（通过getElementById获得），用文本ppp替换之。&lt;/p&gt;

&lt;h3 id=&quot;输出时间&quot;&gt;输出时间&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p id=&quot;time&quot;&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;script&amp;gt;

var nowtime=new Date(); //获得时间

localtime=nowtime.toString(); //将时间转为字符串

document.getElementById(&quot;time&quot;).innerHTML=localtime; //在id为time的地方输出时间，注意，time需要在这行之前才可以

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;关于时间的其他函数&quot;&gt;关于时间的其他函数：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hour=nowtime.getHours(); //将小时赋给hour

min=nowtime.getMinutes(); //分钟

second=nowtime.getSeconds(); //秒

day=nowtime.getDate(); //天

mon=nowtime.getMonth(); //月

year=nowtime.getFullYear(); //年

datashow=year+&quot;年&quot;+mon+&quot;月&quot;+day+&quot;日&quot;+hour+&quot;时&quot;+min+&quot;分&quot;+second+&quot;秒&quot;;

document.getElementById(&quot;time&quot;).innerHTML=datashow; //在id为time的地方输出时间，注意，time需要在这行之前才可以
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;导入一个js文件&quot;&gt;导入一个js文件&lt;/h3&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script src=&quot;time.js&quot;&amp;gt;&lt;/code&gt; //读取time.js这个JavaScript文件内容&lt;/p&gt;

&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;

&lt;p&gt;然后可以将之前的关于time的js命令，放入time.js文件内（无需加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签）即可。&lt;/p&gt;

&lt;h3 id=&quot;事件处理程序&quot;&gt;事件处理程序&lt;/h3&gt;

&lt;p&gt;在发生某种事件时，怎么处理。&lt;/p&gt;

&lt;p&gt;先上代码：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;01.png&quot; onmouseover=&quot;src='02.png'&quot; onmouseout=&quot;src='01.png'&quot;&amp;gt; &amp;lt;!-- 这行的意思是，插入一个图片，初始是01.png，鼠标移动上去后，是02.png，移动走又变回01.png了--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;位置是在第一个标签之中，类型有（似乎对大小写并不敏感，即onMouseOver和onmouseover是一样的）&lt;/p&gt;

&lt;p&gt;①按下时：onclick=”执行的语句”;&lt;/p&gt;

&lt;p&gt;②鼠标移动到上面时：onMouseOver=”执行的语句”;&lt;/p&gt;

&lt;p&gt;③鼠标离开：onMouseOut=”执行的语句”;&lt;/p&gt;

&lt;p&gt;④点击后生效：onClick=”执行的语句”;（仅限鼠标左键）&lt;/p&gt;

&lt;p&gt;⑤鼠标按下后生效：onMouseDown=”执行的语句”;（左右键都有用）&lt;/p&gt;

&lt;p&gt;⑥增加条件判断（初始1#图片，第一次点击更换为2#图片，再次点击更换为1#图片，然后交替）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img id=&quot;01png&quot; src=&quot;01.png&quot;onclick=&quot;png01()&quot;&amp;gt;

&amp;lt;script&amp;gt;

i=0;//需要在外面声明才行

function png01()

{

if(i==0){i=1;document.getElementById(&quot;01png&quot;).src=&quot;02.png&quot;;}//判断更改图片

else{i=0;document.getElementById(&quot;01png&quot;).src=&quot;01.png&quot;;}//判断更改图片

}

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;⑦鼠标在上面是一个鼠标，鼠标离开又是另外一个图片&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img id=&quot;01png&quot; src=&quot;01.png&quot; onmouseover=&quot;src='02.png'&quot; onmouseout=&quot;src='01.png'&quot;&amp;gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;⑧判断路径中，文件名是否有某个关键词；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function mouseover()

{

png=document.getElementById(&quot;01png&quot;);

if(png.src.match(&quot;01.png&quot;)) //如果路径中有关键词01，

{

png.src=&quot;02.png&quot;;

}

else

{

png.src=&quot;01.png&quot;;

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;
&lt;p&gt;html注释的语法是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; &amp;lt;!--这里面写注释--&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;js注释的语法：&lt;/p&gt;

&lt;p&gt;js标签之内（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 之间的部分），可以像c++那样用双斜线。&lt;/p&gt;

&lt;h3 id=&quot;图片&quot;&gt;图片&lt;/h3&gt;

&lt;p&gt;①标签&amp;lt;img src=”图片链接”&amp;gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;http://s1.sinaimg.cn/middle/60de1da3n796eef141460&amp;amp;690&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;②限制高度和宽度（会导致图片变形）：width=””和height=””;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;http://s1.sinaimg.cn/middle/60de1da3n796eef141460&amp;amp;690&quot; width=&quot;100&quot; heigth=&quot;100&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;③在文字之中插入图片：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;右边是一个美女图片&amp;lt;img id=&quot;01png&quot; src=&quot;http://s1.sinaimg.cn/middle/60de1da3n796eef141460&amp;amp;690&quot;  width=&quot;200&quot; height=&quot;200&quot; onmouseover=&quot;mouseover()&quot; onmouseout=&quot;mouseover()&quot;&amp;gt; 左边是美女图片&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;超链接&quot;&gt;超链接&lt;/h3&gt;

&lt;p&gt;在使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a href=”链接地址”&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt; 即可，将触发链接的内容加入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 中间如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;http://baidu.com&quot; target=&quot;_blank&quot;&amp;gt; &amp;lt;!--加入target=&quot;_blank&quot;表示是新窗口，不加则是在之前的窗口--&amp;gt;

    &amp;lt;img id=&quot;01png&quot; src=&quot;01.png&quot;  width=&quot;100&quot; height=&quot;100&quot; onmouseover=&quot;mouseover()&quot; onmouseout=&quot;mouseover()&quot;&amp;gt;

&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;①如果是链接到本地（或者网站某个地址），则使用相对路径；&lt;/p&gt;

&lt;p&gt;②链接到同一个页面的不同位置，参考链接：http://www.w3school.com.cn/tiy/t.asp?f=html_link_locations&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#C4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;查看 Chapter 4。&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 3&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C4&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Chapter 4&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 5&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 6&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 7&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 8&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 9&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 10&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 11&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 12&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 13&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 14&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 15&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 16&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Chapter 17&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This chapter explains ba bla bla&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;③如果图片不能存在的话，用文本替代：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;不存在的图片.png&quot; alt=&quot;这里是不存在的图片&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用div来布局&quot;&gt;使用div来布局&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 布局的好处是，提前把网站页面划分为若干个区域，然后设置好每个区域的大小。&lt;/p&gt;

&lt;p&gt;如图片，先将页面分为3个区域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160331173243153&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在每个区域中再细分。
①一般在div中使用class属性：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=”某个样式”&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后这个div则使用class的这个样式了。&lt;/p&gt;

&lt;p&gt;②一个div实际上是一行（也就是说不同div之间是换行），但貌似可以通过class来让其位于不同的位置。&lt;/p&gt;

&lt;p&gt;更深的话，是跟DOM有关的。&lt;/p&gt;

</description>
        <pubDate>Wed, 10 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/10/JavaScript%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/10/JavaScript%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>(转)Tips:取消UICollectionView的隐式动画</title>
        <description>&lt;h1 id=&quot;转tips取消uicollectionview的隐式动画&quot;&gt;(转)Tips:取消UICollectionView的隐式动画&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;原文地址在串哥的博客 &lt;a href=&quot;http://adad184.com/2015/11/10/disable-uicollectionview-implicit-animation/&quot;&gt;Tips:取消UICollectionView的隐式动画&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;UICollectionView在 &lt;code class=&quot;highlighter-rouge&quot;&gt;reloadItems&lt;/code&gt; 的时候 默认会附加一个隐式的fade动画 有时候很讨厌 尤其是当你的cell是复合cell的情况下 (比如cell使用到了UIStackView)&lt;/p&gt;

&lt;p&gt;下面几种方法都可以帮你去除这些动画&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//方法一
[UIView performWithoutAnimation:^{

    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
}];

//方法二
[UIView animateWithDuration:0 animations:^{
    [collectionView performBatchUpdates:^{
        [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
    } completion:nil];
}];
    
//方法三
[UIView setAnimationsEnabled:NO];
[self.trackPanel performBatchUpdates:^{
    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:^(BOOL finished) {
    [UIView setAnimationsEnabled:YES];
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果你的APP只支持iOS7+ 推荐使用第一种方式 &lt;code class=&quot;highlighter-rouge&quot;&gt;performWithoutAnimation&lt;/code&gt; (感谢@sunnyxx的tip) 简单方便&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;but&lt;/p&gt;

&lt;p&gt;问题还没有结束 上面介绍的方法只能解决UIView的Animation 如果你的cell中还包含有CALayer的动画 比如这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)layoutSubviews
{
    [super layoutSubviews];
    
    self.frameLayer.frame = self.frameView.bounds;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述情况多用于自定义控件使用了layer.mask的情况 如果有这种情况 上面提到的方法是无法取消CALayer的动画的 但是解决办法也很简单&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)layoutSubviews
{
    [super layoutSubviews];
    
    [CATransaction begin];
    [CATransaction setDisableActions:YES];
    
    self.frameLayer.frame = self.frameView.bounds;
    
    [CATransaction commit];
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;done!&lt;/p&gt;

</description>
        <pubDate>Tue, 09 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/09/Tips-%E5%8F%96%E6%B6%88UICollectionView%E7%9A%84%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/09/Tips-%E5%8F%96%E6%B6%88UICollectionView%E7%9A%84%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB/</guid>
        
        <category>动画</category>
        
        <category>Tips</category>
        
        
      </item>
    
      <item>
        <title>关于 App Store 审核的一些事</title>
        <description>&lt;h1 id=&quot;关于-app-store-审核的一些事&quot;&gt;关于 App Store 审核的一些事&lt;/h1&gt;

&lt;h4 id=&quot;事情经过&quot;&gt;事情经过&lt;/h4&gt;
&lt;p&gt;因为一个功能应不应该使用内购，跟苹果爸爸来回周旋了一个月，其间又是邮件又是电话，直到最后申诉，苹果爸爸才正视我的述求，最终通过了审核。
当我几次 态度明确的 通过邮件、视频回复审核人员，我们基于付费的功能是与 app 的使用没有关系的，对方打来电话，告诉我：您这个 app 我们也是几次商讨后才认为是需要使用内购的，巴拉巴拉一堆话。我就说根据你们的审核条例：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;3.1.5 App 之外的实物商品和服务：如果 app 允许用户购买将在 app 之外使用的商品或服务，则必须使用 IAP 以外的购买方式来收取相应款项，如 Apple Pay 或传统的信用卡入口。App 可支持获批虚拟货币的流通（如比特币、狗币），前提条件是，在该 app 能够正常使用的地区，前述做法必须遵守各州法律和联邦法律。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们这个app是不需要通过内购的。&lt;/p&gt;

&lt;p&gt;审核人员：如果您觉得我们的审核有问题的话，您向审查委员会提起申诉好了，但是我需要告诉您，审查委员会也是我们的人，而且我们之前已经请求过审查委员会的意见，所以如果您提起申诉，结果还是一样的。&lt;/p&gt;

&lt;p&gt;我：难道你们的审核条款是摆设吗（大概是这样的话，有点记不清楚了。）&lt;/p&gt;

&lt;p&gt;审核人员：只要你通过 Apple 这个平台进行推广你的付费服务，就需要使用内购。&lt;/p&gt;

&lt;p&gt;日了狗了！！&lt;/p&gt;

&lt;p&gt;抱着一线生机的提起了申诉，今天早上一来，申诉通过了，并且审核也已经通过了。&lt;/p&gt;
&lt;h4 id=&quot;收获&quot;&gt;收获&lt;/h4&gt;
&lt;p&gt;通过这件事，知道了几点：&lt;/p&gt;
&lt;h5 id=&quot;1苹果审核人员的标准不一致&quot;&gt;1，苹果审核人员的标准不一致。&lt;/h5&gt;

&lt;p&gt;我们的app 是一个上线时间很长的app，之前每次更新基本上第二天就可以审核上线了。但这次扯淡就扯了一个月。猜测是不同的审核人员的审核标准不一致。&lt;/p&gt;
&lt;h5 id=&quot;2审核人员会言语上误导你&quot;&gt;2，审核人员会言语上误导你。&lt;/h5&gt;

&lt;p&gt;审核人员告诉我是经过了审查委员会的意见进行的处理，但是当我提起申诉，app 就通过了审核。要么是审核人员说谎了，要么就是审查委员会之前的标准也是不一致的。&lt;/p&gt;
&lt;h5 id=&quot;3只要你确认你是-app-符合审核规则一定要坚持&quot;&gt;3，只要你确认你是 app 符合审核规则，一定要坚持&lt;/h5&gt;

&lt;p&gt;在审核人员打来电话后，通过她的话语，感觉申诉通过的几率也不是很大，我们这边差点要改一系列的逻辑实现，最后领导拍板，我们的app 符合他们的审核条例，为什么审核不给过，去申诉，先看看申诉结果以后再讨论。&lt;/p&gt;

&lt;h4 id=&quot;最后&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;也许只是因为最近 微信 的打赏功能闹得沸沸扬扬，苹果爸爸审核的严格了。。&lt;/p&gt;

</description>
        <pubDate>Mon, 08 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/08/%E5%85%B3%E4%BA%8E-App-Store-%E5%AE%A1%E6%A0%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/08/%E5%85%B3%E4%BA%8E-App-Store-%E5%AE%A1%E6%A0%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</guid>
        
        <category>App Store</category>
        
        
      </item>
    
      <item>
        <title>让你眼前一亮的代码</title>
        <description>&lt;h1 id=&quot;让你眼前一亮的代码&quot;&gt;让你眼前一亮的代码&lt;/h1&gt;

&lt;p&gt;本文记录一下，我见到的让我觉得眼前一亮的代码，闭门造车了好久，一直在吃老本，没有提升，突然见到这样的代码，真的觉得受益匪浅，就自己重写并记录下，水平有限，请看到的列位大神不要见笑。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;所有的代码都已经上传 ，地址为：&lt;a href=&quot;https://github.com/yunisSong/MagicCode&quot;&gt;MagicCode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;uitableview&quot;&gt;UITableView&lt;/h3&gt;
&lt;h4 id=&quot;uitableview-代理封装&quot;&gt;UITableView 代理封装&lt;/h4&gt;
&lt;p&gt;传统的 &lt;code class=&quot;highlighter-rouge&quot;&gt;UITableView&lt;/code&gt; 使用，会有一大堆代理方法，看起来比较乱，封装后形式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    UITableView *table = ({
        UITableView *baseTableView    = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain];
        baseTableView.estimatedRowHeight = 100;
        baseTableView.rowHeight = UITableViewAutomaticDimension;
        [baseTableView registerClass:[DemoTableViewCell class] forCellReuseIdentifier:PhotoCellIdentifier];
        baseTableView;
    });
    [table addHelper:^(SYTableViewHelper *help)
     {
         help.addItem(source)
         .configureCell(^(DemoTableViewCell *cell, NSString *photo)
                        {
                            cell.textLabel.text = photo;
                        })
         .addSelectCell(^(NSIndexPath *index)
                        {
                            NSLog(@&quot;indexRow = %ld&quot;,(long)index.row);
                        })
         .addCellIdentifier(PhotoCellIdentifier);
         
     }];
    [self.view addSubview:table];
    
    [table mas_makeConstraints:^(MASConstraintMaker *make) {
        make.edges.equalTo(self.view);
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的就是使用一个帮助类，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;UITableView&lt;/code&gt; 的代理都丢到帮助类里面处理，因为最近痴迷于链式语法，就使用链式实现了一遍,一般简单的需求都可以用下，如果需要使用其他的代理方法，就自己再添加了。
&lt;img src=&quot;https://raw.githubusercontent.com/yunisSong/MagicCode/master/Pic/tableviewDemo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;uitableview-一句话空数据占位视图&quot;&gt;UITableView 一句话空数据占位视图&lt;/h4&gt;
&lt;p&gt;开发中，如果请求返回数据为空，需要有一视图提示用户，数据为空。这个是之前看陈一龙的微博看到的，自己就又实现了下。具体代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    if (self.emptyViewTitle)
    {
        [tableView tableViewDisplayEmptyViewWithTitle:self.emptyViewTitle
                               ifNecessaryForRowCount:self.items.count];
    }
    return self.items.count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我这边就显示了一个提示的文字，简单的实现了，如果需要显示美观的视图，自己修改下就可以用了，思路都是一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yunisSong/MagicCode/master/Pic/tableviewEmptyDemo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;uiimageview&quot;&gt;UIImageView&lt;/h3&gt;
&lt;h4 id=&quot;0行代码完成头像设置功能&quot;&gt;0行代码完成头像设置功能&lt;/h4&gt;
&lt;p&gt;最初是在 &lt;a href=&quot;https://github.com/FengDeng/DFHeadImageView&quot;&gt;DFHeadImageView&lt;/a&gt; ,通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView&lt;/code&gt; 封装，使用 &lt;a href=&quot;https://github.com/FengDeng/DFHeadImageView&quot;&gt;DFHeadImageView&lt;/a&gt; 可以直接完成设置头像的功能，不需要再额外写获取图片的方法。最好自己试着仿写了一遍。&lt;/p&gt;

</description>
        <pubDate>Fri, 05 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/05/%E8%AE%A9%E4%BD%A0%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/05/%E8%AE%A9%E4%BD%A0%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
        
        <category>奇巧淫技</category>
        
        
      </item>
    
      <item>
        <title>链式语法学习</title>
        <description>&lt;h1 id=&quot;链式语法学习&quot;&gt;链式语法学习&lt;/h1&gt;

&lt;h4 id=&quot;为什么要写一个链式语法的库&quot;&gt;为什么要写一个链式语法的库&lt;/h4&gt;
&lt;p&gt;最近看了 &lt;a href=&quot;https://github.com/jhurray/JHChainableAnimations&quot;&gt;JHChainableAnimations&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonry&lt;/a&gt; 觉得链式语法写起来用的好爽，就萌生了使用 链式 编写最近使用的一个库，然后又看到了 &lt;a href=&quot;http://www.jianshu.com/u/0cf7d455eb9e&quot;&gt;sindri的小巢&lt;/a&gt; 的这篇文章 &lt;a href=&quot;http://www.jianshu.com/p/031818e48550&quot;&gt;iOS开发-链式实现数据源&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在文章的最后，作者展示了这样的一段代码：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;user/getUserInfo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSDictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;/// request success&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSError&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;/// request failed&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，就写一个网路的链式调用库，当做一次链式语法的实践。&lt;/p&gt;

&lt;h4 id=&quot;具体如何实现&quot;&gt;具体如何实现&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/SYrequest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;提供调用的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (apiAddress )requestURLString;
+ (apiAddress)Get;
+ (apiAddress)Post;
- (apiAddress )requestURLString;
- (apiAddress)Get;
- (apiAddress)Post;

- (head)addHeadersy;
- (params)addParameters;
- (body)addBody;
- (httpMethod)httpMethod;
- (parameterEncoding)addParameterEncoding;

- (startRequest)start;
- (cancelRequest)cancel;
- (suspendRequest)suspend;
- (resumeRequest)resume;


- (response)response;


- (void)clearCompletionBlock;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    SYRequest *requset = [[SYRequest alloc] init];
    requset.requestURLString(@&quot;https://www.metaweather.com/api/location/search/&quot;)
            .httpMethod(SYHTTPMethod_GET)
            .addParameters(@{@&quot;query&quot;:@&quot;sa&quot;})
            .start(^(BOOL sucess,id responseData,NSError *error){
                NSDictionary *jsonDic = [NSJSONSerialization JSONObjectWithData:responseData options:0 error:nil];
                NSLog(@&quot;jsonDic = %@&quot;,jsonDic);
            });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    SYRequest.requestURLString(@&quot;https://www.metaweather.com/api/location/search/&quot;)
    .httpMethod(SYHTTPMethod_GET)
    .addParameters(@{@&quot;query&quot;:@&quot;sa&quot;})
    .start(^(BOOL sucess,id responseData,NSError *error){
        NSDictionary *jsonDic = [NSJSONSerialization JSONObjectWithData:responseData options:0 error:nil];
        NSLog(@&quot;jsonDic = %@&quot;,jsonDic);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的就没什么说的，实现起来就是这样： &lt;code class=&quot;highlighter-rouge&quot;&gt;方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）&lt;/code&gt;,只要按照这个条件写，就可以写出一个自己的链式库。&lt;/p&gt;

&lt;p&gt;具体代码地址 &lt;a href=&quot;https://github.com/yunisSong/SYRequest&quot;&gt;SYRequest&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/25/%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/25/%E9%93%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>链式</category>
        
        
      </item>
    
      <item>
        <title>（转）制作一个苦力</title>
        <description>&lt;h1 id=&quot;转制作一个苦力&quot;&gt;（转）制作一个苦力&lt;/h1&gt;

&lt;p&gt;创造一个工具，为自己，也为他人。&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&quot;https://twitter.com/nixzhu&quot;&gt;@nixzhu&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;现今，几乎所有的 API 都返回 JSON，但 JSON 是一种文本数据，为了使访问更加安全和自然，传递更加方便，我们通常会将它转换为客户端模型，而不仅仅将其当作一个字典来使用。&lt;/p&gt;

&lt;p&gt;通常，我们会有服务器端所提供的 API 的文档，里面会描述每个 API 可能返回的数据。据此，作为客户端开发者，根据这些信息，我们就能设计出适合客户端使用的模型，或者接口、协议等。&lt;/p&gt;

&lt;p&gt;可是，如果 API 很多，那可能模型也会很多。假如我们用结构体来做模型，光是每个模型的属性（以及从字典到模型的转换代码）都够我们写上一段时间，而且这个过程并不有趣。&lt;/p&gt;

&lt;p&gt;有一些框架可以帮助我们做“从字典到模型的转换”这一步，但我们仍然要先定义好结构体（或者类）。&lt;/p&gt;

&lt;p&gt;如果一件事情对人类而言枯燥无趣，通常计算机就会很喜欢。如果我们能让计算机帮我们从 JSON 直接生成模型，然后我们再来对模型做一些修改和调整，那我们应该就像一个人了。&lt;/p&gt;

&lt;p&gt;开发者当然是人，而且是刚好能够用计算机制造工具的人。&lt;/p&gt;

&lt;p&gt;JSON 里有些什么信息呢？足够帮助我们生成模型吗？下面来看一个简单的例子。假如有如下 JSON：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;NIX&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;skills&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Swift on iOS&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C on Linux&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;motto&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Love you love.&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而我们期望得到如下模型：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;skills&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;motto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过观察可知，JSON 就像一个字典，有 key 和 value，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; 为 key，其值 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NIX&quot;&lt;/code&gt; 是一个字符串。对应到模型里即属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;，类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;。其它依次类推即可。其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;skills&lt;/code&gt; 比较特殊，是一个数组，而且其元素是字符串，所以对应到模型属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;skills&lt;/code&gt; 的类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;[String]&lt;/code&gt;。这个 JSON 比较简单，在更复杂的 JSON 里，有可能 key 对应的 value 也是一个字典，数组里也很可能不是基本类型，也是一个个字典。还有 key 可能没有 value，而对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;除了模型结构体的名字 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 外，其它信息都应该能从 JSON 中推断出来。也就是说，我们要写一个解析器，它能将 JSON 里的信息提取出来，用于生成我们需要的结构体。&lt;/p&gt;

&lt;p&gt;那解析器怎么写？不要慌，我们先看看 JSON 的定义：&lt;a href=&quot;http://www.json.org/json-zh.html&quot;&gt;http://www.json.org/json-zh.html&lt;/a&gt;，这份说明很短，应该不难看懂。&lt;/p&gt;

&lt;p&gt;我再节录一点如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSON建构于两种结构：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。&lt;/li&gt;
    &lt;li&gt;值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。
数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;后面还定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;值（value）&lt;/code&gt;的具体类型，如字符串、数组、布尔值、空等。而且要注意，value 还可以是对象或数组，也就是说，JSON 是一种可递归的数据结构，因此它可以表征很复杂的数据。&lt;/p&gt;

&lt;p&gt;总结一下，JSON 里包含的基本单位有这么几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象开始符 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对象结束符 &lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;数组开始符 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;数组结束符 &lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;键值分隔符 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;键值对分隔符 &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;布尔值，真 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;布尔值，假 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;数字 &lt;code class=&quot;highlighter-rouge&quot;&gt;42&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;-0.99&lt;/code&gt; …&lt;/li&gt;
  &lt;li&gt;字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;name&quot;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NIX&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;空 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不要觉得复杂，因为并没有多少种。注意其中的“字符串”既可以用来表示 key，也可以作为 value 的一种。&lt;/p&gt;

&lt;p&gt;很明显，有的基本单位就是一个字符而已，但有的不是，比如布尔值、数字、字符串等。这是一种重要的洞见，这说明我们不该将 JSON 当做一个字符串来看待，而应该将其当做一种“基本单位串”。&lt;/p&gt;

&lt;p&gt;这里的“基本单位”，在计算机科学里，被称为“Token”，也就是说，JSON 是由一个个 Token 串联起来的。当我们能用 Token 串来看待 JSON 时，我们思考解析的过程会更清晰，不用再纠结于字符。&lt;/p&gt;

&lt;p&gt;再看一个更简单的 JSON:&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;NIX&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在计算机“看来”是这样：&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;NIX&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;，一个字符串，包含换行符&lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt;、制表符&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;和空格&lt;code class=&quot;highlighter-rouge&quot;&gt; &lt;/code&gt;（注意这里为了表示方便，并未转义&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;）。
如果我们去除这些空白符，就有：&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;NIX&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;，看起来好多了。&lt;/p&gt;

&lt;p&gt;以我们对 JSON 的理解，我们再对其作分割，就有：&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;name&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NIX&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;age&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;18&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;，共9个独立的部分。
很明显我们的大脑知道如何“正确”分割，这里的正确指的是符合 JSON 的定义。比如，当我们看到&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;时就知道这个 JSON 是一个字典，看到&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;name&quot;&lt;/code&gt;及其后的&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;时，我们就知道 name 是一个 key，再后面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;NIX&quot;&lt;/code&gt; 就是 value 了。看到&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;时就知道这个键值对结束（也预示下一个键值对要开始）。当我们看到&lt;code class=&quot;highlighter-rouge&quot;&gt;18&lt;/code&gt;时，我们除了知道它时一个 value 外，还知道它是一个数字，而不是字符串，因为字符串都有双引号包围。&lt;/p&gt;

&lt;p&gt;这些独立的部分不应该再被分割，不然其意义就不明确了，这种不能被分割的部分就是 Token。&lt;/p&gt;

&lt;p&gt;Swift 的 enum 特别适合用来表示不同的 Token，于是有：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BeginObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// {&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EndObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// }&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BeginArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// [&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EndArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// ]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Colon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// :&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Comma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// ,&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// true or false&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NumberType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NumberType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 42, -0.99&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot;, &quot;NIX&quot;, ...&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Null&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作为一种合理的简化，Number 只考虑整型和简单的浮点型。&lt;/p&gt;

&lt;p&gt;那么上面的9个独立部分就可以表示为：&lt;code class=&quot;highlighter-rouge&quot;&gt;.BeginObject(&quot;{&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.String(&quot;name&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.Colon(&quot;:&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.String(&quot;NIX&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.Comma(&quot;,&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.String(&quot;age&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.Colon(&quot;:&quot;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.Number(.Int(18))&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.EndObject(&quot;}&quot;)&lt;/code&gt;，也就是一个 Token 串了。&lt;/p&gt;

&lt;p&gt;那么，我们的第一步就将 JSON 字符串转换为 Token 串，为后面的解析（所谓解析，是将 Token 串转化为一个中间数据结构，这个结构里有我们最后所要生成的模型所需要的所有信息）做准备。&lt;/p&gt;

&lt;p&gt;通常，在各种介绍“编译原理”的书籍中，会把这个步骤成为“词法分析”。又通常，会进一步介绍“正则表达式”和“状态机”，以便用它们写出做词法分析的工具。&lt;/p&gt;

&lt;p&gt;不过我们还不需要去学它们。对于 JSON 这种比较简单的数据表示，我们可以利用 NSScanner 来帮我们生成 Token 串。NSScanner 的文档&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSScanner_Class/&quot;&gt;在此&lt;/a&gt;，简单来说，它是一个根据一些预定义的模式，从一个字符串中寻找匹配模式的字符串，并在匹配后移动其内部的指针，以便继续扫描，直至结束。在任意一个模式匹配后，我们就可以利用匹配到的信息来生成 Token。&lt;/p&gt;

&lt;p&gt;其用法如下：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;scanner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NSScanner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;{&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;NIX&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;: 18&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanBeginObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scanString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intoString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BeginObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;scanBeginObject&lt;/code&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;scanner&lt;/code&gt;扫描&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;，若能找到，就返回一个 BeginObject Token。类似这样，我们能写出
    &lt;code class=&quot;highlighter-rouge&quot;&gt;scanEndObject&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanBeginArray&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanEndArray&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanColon&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanComma&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanBool&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanNumber&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanString&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;scanNull&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后，我们可以利用一个 while 循环，把 JSON 字符串转换为 Token 串：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateTokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;previousScanLocation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scanLocation&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanBeginObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanEndObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanBeginArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanEndArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanColon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanComma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanBool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scanNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;currentScanLocation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scanLocation&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentScanLocation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previousScanLocation&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Not found valid token&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的函数依然只是看着比较长而已，实质非常简单。注意我们在一次循环里尽可能寻找合法的 Token，若最后 &lt;code class=&quot;highlighter-rouge&quot;&gt;currentScanLocation&lt;/code&gt; 没有大于 &lt;code class=&quot;highlighter-rouge&quot;&gt;previousScanLocation&lt;/code&gt;，那说明当前扫描没有找到合法的 Token，也就是说 JSON 字符串有语法问题。&lt;/p&gt;

&lt;p&gt;经过上面的步骤，我们应该已得到了一个 Token 数组，接下来就是解析了。不过我们首先要明确解析的目的，我们要生成一个中间结构来表示 JSON 的结构，根据前面提及的 JSON 定义，我们也不难写出如下 enum：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;NumberType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NumberType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Null&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;indirect&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;indirect&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Swift&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们将一个 JSON 看作一个 Value，而 Value 本身可以是布尔值、数字、字符串、null 或者递归结构（String: Value 字典，或者 Value 数组），这其实是一种&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95&quot;&gt;上下文无关文法&lt;/a&gt;的表示。我不打算在这里解释上下文无关文法的定义，但简单来说，当我们说一个 Value 是什么的时候，我们知道它可能表示一个布尔值、数字、……、或者与 Value 有关的结构（字典或数组），Value 本身可以作为构建 Value 的基石。&lt;/p&gt;

&lt;p&gt;有了 Value 的定义，那我们的解析函数可如下定义：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateTokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No tokens&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;哈哈，真实的&lt;code class=&quot;highlighter-rouge&quot;&gt;parse()&lt;/code&gt;当然不会这么短，不过我们知道它应该返回一个 Value（或 nil，表示解析失败）。&lt;/p&gt;

&lt;p&gt;有了 tokens，我们再定义一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;var next = 0&lt;/code&gt;，表示我们当前“查看”到哪一个 Token 了，然后我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;parse()&lt;/code&gt;内部定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;parseValue()&lt;/code&gt;，并在最后调用它，如下：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tokens&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateTokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No tokens&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No token for parseValue&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BeginArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;arrayName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nameIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nameToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;arrayName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capitalizedString&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BeginObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseBool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseNull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先，Don’t Panic! 其实上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;parseValue()&lt;/code&gt;也并不复杂，不过是 case 较多（这由 Token 的种类决定）而已。它先用 next 取到当前的 Token，之后就 switch token 来具体处理。例如对于最复杂的&lt;code class=&quot;highlighter-rouge&quot;&gt;.BeginArray&lt;/code&gt;，它利用 next 回退了两个 Token，以拿到这个数组的名字（在这里，我们其实做了一种假设，即 JSON 的“基底”是一个字典，而数组只会出现在字典内部，因此数组一定有一个名字，这个名字对于我们后面的代码生成来说是必要的，而且这种假设也很合理，因为我们通常都会用一个 JSON 字典来表示一个模型），之后增加 next 跳过这个表示中括号的 Token，再调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;parseArray&lt;/code&gt;（我们先不管它是怎么实现的，实际上，在编写解析器的过程中，这种“大局观”很重要，有时候必须从全局看问题）。对于&lt;code class=&quot;highlighter-rouge&quot;&gt;.BeginObject&lt;/code&gt;，它增加 next 以跳过这个表示大括号的 Token，然后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parseObject&lt;/code&gt;，其它类似（注意我们并没有 switch 所有的 case，这也是基于对 JSON 的理解）。&lt;/p&gt;

&lt;p&gt;很明显，我们还会在上面的注释处继续添加函数，其中最复杂的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;parseArray&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;parseObject&lt;/code&gt;，我再稍微描述一下它们：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No token for parseArray&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EndArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EndArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseComma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expect comma&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nextToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isNotEndArray&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Invalid JSON, comma at end of array&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们先准备了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;var array = [Value]()&lt;/code&gt;用来装解析出的 values，然后判断 next 表示的 Token，如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;.EndArray&lt;/code&gt;（右中括号），表示这是一个空的数组，因此立即返回，不然呢，就进入一个 while 循环。在 while 循环中，我们实际上身处第一个 Value，请回忆 Value 里 Array 的定义，Array 就是 Value 的数组（一种递归定义），因此，我们直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parseValue&lt;/code&gt;即可，如果 JSON 没有语法问题，那么我们就能得到表示数组中第一个元素的 value，我们把这个 value 添加到 array 里。然后，我们取下一个 Token，经过前面&lt;code class=&quot;highlighter-rouge&quot;&gt;parseValue&lt;/code&gt;的解析，这一个 token 有这几种可能：右中括号（表示数组结束）、逗号（表示数组里还有更多元素），终究，我们的循环可以处理这些情况，并在合适的时候用 return 跳出循环。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No token for parseObject&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EndObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseColon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expect key : value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;EndObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseComma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Expect comma&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nextToken&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;coolie_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isNotEndObject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Invalid JSON, comma at end of object&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看完上面对&lt;code class=&quot;highlighter-rouge&quot;&gt;parseArray&lt;/code&gt;的分析，我想，&lt;code class=&quot;highlighter-rouge&quot;&gt;parseObject&lt;/code&gt;看起来也不会太难。只不过这次我们先定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;var dictionary = [String: Value]()&lt;/code&gt;来装结果，然后判断下一个 Token 是否表示对象结束（也即是右大括号），不然又进入 while 循环来继续解析，只需注意&lt;code class=&quot;highlighter-rouge&quot;&gt;guard let key = parseString(), _ = parseColon(), value = parseValue()&lt;/code&gt;，我们在其中取到了 key 和 value（中间的逗号被跳过了），确保 key 是一个 String，然后就可以将 value 装入我们早就准备好的 dictionary 里了。然后当然是继续判断，下一个 Token 要么是对象结束，要么是一个逗号。同样，不符合我们预期的 Token 当然表示 JSON 不合法。&lt;/p&gt;

&lt;p&gt;其它诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;parseColon&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;parseComma&lt;/code&gt;等都比较简单，我就不贴代码分析了，感兴趣的读者可直接去&lt;a href=&quot;https://github.com/nixzhu/Coolie&quot;&gt;阅读代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不出意外，我们得到了一个 Value，然后我们只需要根据我们对模型的需求写出一个生成函数，利用它生成模型和模型的构造方法，我们就得到一个苦力了。
目前我写了两个生成函数：&lt;code class=&quot;highlighter-rouge&quot;&gt;generateStruct&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;generateClass&lt;/code&gt;，分别用于生成 Swift struct 或 class（比较琐碎，也不贴代码分析了）。而且因为 Value 是递归的，因此我们生成的模型也是递归的。如果你所用的编程语言不支持递归定义，那可能要稍微麻烦一点。另外，为了方便开发者使用，我还写了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Arguments&lt;/code&gt;模块，用于解析命令行参数，感兴趣的读者可直接到 &lt;a href=&quot;https://github.com/nixzhu/Coolie&quot;&gt;Coolie 的 GitHub Repo&lt;/a&gt; 处研究。&lt;/p&gt;

&lt;p&gt;我想读者大概能够看出，其实 Coolie 是一个迷你的编译器，它有词法分析、语法分析、中间表示、代码生成，因此它能将一个 JSON 文件“编译”为一个 Swift 文件，而且因为其内部有一个中间表示（可看成 AST），所以根据不同的用途，它也可以生成其它语言的模型代码。&lt;/p&gt;

&lt;p&gt;苦力是我在写 &lt;a href=&quot;https://github.com/CatchChat/Yep&quot;&gt;Yep&lt;/a&gt; 的过程中被写模型代码的繁琐逼出来的（我也看了不少编译原理相关的资料），可惜做得太晚，自己倒没怎么用上，不过我希望其他开发者不用再这样受苦。&lt;/p&gt;

&lt;p&gt;===============&lt;/p&gt;

&lt;p&gt;欢迎转载，但请一定注明出处！ &lt;a href=&quot;https://github.com/nixzhu/dev-blog&quot;&gt;https://github.com/nixzhu/dev-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎转发此条&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tweet &lt;a href=&quot;https://twitter.com/nixzhu/status/747964885770735617&quot;&gt;https://twitter.com/nixzhu/status/747964885770735617&lt;/a&gt; 或&lt;/li&gt;
  &lt;li&gt;微博 &lt;a href=&quot;http://weibo.com/2076580237/DCrSs4TbC&quot;&gt;http://weibo.com/2076580237/DCrSs4TbC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以分享此文或参与讨论！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章对你有所帮助，可用支付宝扫描下方二维码，以捐助慰劳作者的辛苦：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/nixzhu/dev-blog/raw/master/images/nixzhu_alipay.png&quot; alt=&quot;nixzhu的支付宝二维码&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/18/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E8%8B%A6%E5%8A%9B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/18/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E8%8B%A6%E5%8A%9B/</guid>
        
        <category>转载</category>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>JHChainableAnimations源码学习</title>
        <description>&lt;h1 id=&quot;jhchainableanimations源码学习&quot;&gt;JHChainableAnimations源码学习&lt;/h1&gt;

&lt;h3 id=&quot;jhchainableanimations是什么&quot;&gt;JHChainableAnimations是什么&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JHChainableAnimations&lt;/code&gt; 是一个多系统动画封装的链式语法库。&lt;/p&gt;

&lt;p&gt;原有的OC代码如果我们想写一个动画，需要这样写。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;animateWithDuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
                          &lt;span class=&quot;nv&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;
         &lt;span class=&quot;nv&quot;&gt;usingSpringWithDamping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.8&lt;/span&gt;
          &lt;span class=&quot;nv&quot;&gt;initialSpringVelocity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
                        &lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;animations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;kt&quot;&gt;CGPoint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newPosition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;newPosition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finished&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;animateWithDuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;
                              &lt;span class=&quot;nv&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;
                            &lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UIViewAnimationOptionCurveEaseIn&lt;/span&gt;
                         &lt;span class=&quot;nv&quot;&gt;animations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backgroundColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UIColor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;purpleColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHChainableAnimations&lt;/code&gt; 可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;initWithView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;animator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;moveX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;thenAfter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;makeBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UIColor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;purpleColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;easeIn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码一下就显得特别清晰明了，&lt;code class=&quot;highlighter-rouge&quot;&gt;JHChainableAnimations&lt;/code&gt; 采用了现在流行的链式语法，跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;Masonry&lt;/code&gt; 一样的语法。&lt;/p&gt;
&lt;h4 id=&quot;链式语法的特点是什么&quot;&gt;链式语法的特点是什么&lt;/h4&gt;
&lt;p&gt;链式编程特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）&lt;/p&gt;

&lt;h3 id=&quot;jhchainableanimations代码具体分析&quot;&gt;JHChainableAnimations代码具体分析&lt;/h3&gt;

&lt;p&gt;首先看一段代码&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;initWithView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;animator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;moveX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先是将 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.myView&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHChainableAnimator *animator&lt;/code&gt; 关联起来，然后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHChainableAnimator *animator&lt;/code&gt; 进行动画设置。&lt;/p&gt;

&lt;p&gt;第二行代码
&lt;code class=&quot;highlighter-rouge&quot;&gt;animator.moveX(100).animate(2);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先是 &lt;code class=&quot;highlighter-rouge&quot;&gt;animator&lt;/code&gt; 调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;moveX&lt;/code&gt; 方法生成动画样式，这个方法从字面上面看 就是 移动视图的X轴，然后调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;animate&lt;/code&gt; 执行动画，设置动画时间。具体看先 它是如何实现的。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveX&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimationCalculationAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;JHKeyframeAnimation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;basicAnimationForKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;position.x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimationFromCalculationBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimationCompletionAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;CGPoint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再来回顾下链式语法的特点：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再来看上面这段代码：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;moveX&lt;/code&gt; 方法返回的是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;block chainable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 的参数是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;block chainable&lt;/code&gt; 的返回值是当前类 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHChainableAnimator&lt;/code&gt; 实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完全符合链式语法的特点。&lt;/p&gt;
&lt;h4 id=&quot;movex-具体实现&quot;&gt;moveX 具体实现&lt;/h4&gt;
&lt;p&gt;然后再来看具体实现，&lt;code class=&quot;highlighter-rouge&quot;&gt;moveX&lt;/code&gt; 干了什么。&lt;/p&gt;

&lt;p&gt;首先是返回了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;，然后这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 返回了这个类本身的实例。&lt;/p&gt;

&lt;h5 id=&quot;block-chainable-都做了什么&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;block chainable&lt;/code&gt; 都做了什么&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;生成一个可执行的动画
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimationCalculationAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;JHKeyframeAnimation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;basicAnimationForKeyPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;position.x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimationFromCalculationBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;生成有个动画执行完毕的回调，修改视图属性
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;addAnimationCompletionAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JHChainableAnimator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;CGPoint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;返回 当前类本身&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;animate-具体实现&quot;&gt;animate 具体实现&lt;/h4&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animate&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;JHChainableAnimation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JHChainableAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;animateWithCompletion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;华丽的分割线
—-&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;感觉自己的语言表示能力有问题，突然不知道该怎么往下说下去了。
这个地方。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;重新描述下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先是像&lt;/p&gt;
  &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainablePoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveXY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;JHChainableFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moveWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
  &lt;p&gt;这类方法调用的时间，会生成一些类的动画对象 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHKeyframeAnimation&lt;/code&gt; 然后存储到 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHAnimationChainLink&lt;/code&gt; 的动画数组里面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最终 &lt;code class=&quot;highlighter-rouge&quot;&gt;animate&lt;/code&gt; 方法是循环调用 类数组里面存储的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHAnimationChainLink&lt;/code&gt; 对象，执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHAnimationChainLink&lt;/code&gt; 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JHKeyframeAnimation&lt;/code&gt;动画数组。
大致就是这样执行的，但是具体的实现有好多细节，动画的添加，动画执行的回调，取得当前执行的动画、如何暂停动画等。感觉自己目前的功力还很难描述清楚。就暂时先告一段落了。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 15 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/15/JHChainableAnimations%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/15/JHChainableAnimations%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>源码</category>
        
        <category>iOS</category>
        
        <category>链式编程</category>
        
        
      </item>
    
      <item>
        <title>(转)GCD深入理解:第二部分</title>
        <description>&lt;h1 id=&quot;转gcd深入理解第二部分&quot;&gt;(转)GCD深入理解:第二部分&lt;/h1&gt;

&lt;p&gt;本文翻译自 &lt;a href=&quot;http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2&quot;&gt;http://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原作者：&lt;a href=&quot;http://www.raywenderlich.com/u/Lolgrep&quot;&gt;Derek Selander&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：&lt;a href=&quot;http://weibo.com/riven0951&quot;&gt;Riven&lt;/a&gt;、&lt;a href=&quot;https://twitter.com/nixzhu&quot;&gt;@nixzhu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前半部分由 Riven 翻译，但他由于太忙而搁置，后由 NIX 整理校对并翻译后半部分。&lt;/p&gt;

&lt;p&gt;==============================&lt;/p&gt;

&lt;p&gt;欢迎来到GCD深入理解系列教程的第二部分（也是最后一部分）。&lt;/p&gt;

&lt;p&gt;在本系列的&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md&quot;&gt;第一部分&lt;/a&gt;中，你已经学到超过你想像的关于并发、线程以及GCD 如何工作的知识。通过在初始化时利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt;，你创建了一个线程安全的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager&lt;/code&gt; 单例，而且你通过使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 的组合使得对 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photos&lt;/code&gt; 数组的读取和写入都变得线程安全了。&lt;/p&gt;

&lt;p&gt;除了上面这些，你还通过利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 来延迟显示提示信息，以及利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 将 CPU 密集型任务从 ViewController 的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。&lt;/p&gt;

&lt;p&gt;如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以&lt;a href=&quot;http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip&quot;&gt;下载第一部分最终的代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;那就让我们来更深入地探索 GCD 吧！&lt;/p&gt;

&lt;h2 id=&quot;纠正过早弹出的提示&quot;&gt;纠正过早弹出的提示&lt;/h2&gt;

&lt;p&gt;你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertView&lt;/code&gt; 会在图片下载完成之前就弹出，如下如所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png&quot; alt=&quot;Premature Completion Block&quot; /&gt;&lt;/p&gt;

&lt;p&gt;问题的症结在 PhotoManagers 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotoWithCompletionBlock:&lt;/code&gt; 里，它目前的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock
{
    __block NSError *error;
 
    for (NSInteger i = 0; i &amp;lt; 3; i++) {
        NSURL *url;
        switch (i) {
            case 0:
                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];
                break;
            case 1:
                url = [NSURL URLWithString:kSuccessKidURLString];
                break;
            case 2:
                url = [NSURL URLWithString:kLotsOfFacesURLString];
                break;
            default:
                break;
        }
 
        Photo *photo = [[Photo alloc] initwithURL:url
                              withCompletionBlock:^(UIImage *image, NSError *_error) {
                                  if (_error) {
                                      error = _error;
                                  }
                              }];
 
        [[PhotoManager sharedManager] addPhoto:photo];
    }
 
    if (completionBlock) {
        completionBlock(error);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在方法的最后你调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; ——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 类的实例方法用某个 URL 开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotoWithCompletionBlock:&lt;/code&gt; 在其末尾调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。&lt;/p&gt;

&lt;p&gt;然而，&lt;code class=&quot;highlighter-rouge&quot;&gt;-[Photo initWithURL:withCompletionBlock:]&lt;/code&gt; 是异步执行的，会立即返回——所以这种方式行不通。&lt;/p&gt;

&lt;p&gt;因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block 之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotoWithCompletionBlock:&lt;/code&gt; 才能调用它自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。&lt;/p&gt;

&lt;p&gt;或许你可以写一些比较 Hacky 的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。&lt;/p&gt;

&lt;p&gt;幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。&lt;/p&gt;

&lt;h3 id=&quot;dispatch-groups调度组&quot;&gt;Dispatch Groups（调度组）&lt;/h3&gt;

&lt;p&gt;Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_t&lt;/code&gt; 的实例来记下这些不同的任务。&lt;/p&gt;

&lt;p&gt;当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。&lt;/p&gt;

&lt;p&gt;第一种是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; ，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。&lt;/p&gt;

&lt;p&gt;打开 PhotoManager.m，用下列实现替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotosWithCompletionBlock:&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock
{
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ // 1
 
        __block NSError *error;
        dispatch_group_t downloadGroup = dispatch_group_create(); // 2
 
        for (NSInteger i = 0; i &amp;lt; 3; i++) {
            NSURL *url;
            switch (i) {
                case 0:
                    url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];
                    break;
                case 1:
                    url = [NSURL URLWithString:kSuccessKidURLString];
                    break;
                case 2:
                    url = [NSURL URLWithString:kLotsOfFacesURLString];
                    break;
                default:
                    break;
            }
 
            dispatch_group_enter(downloadGroup); // 3
            Photo *photo = [[Photo alloc] initwithURL:url
                                  withCompletionBlock:^(UIImage *image, NSError *_error) {
                                      if (_error) {
                                          error = _error;
                                      }
                                      dispatch_group_leave(downloadGroup); // 4
                                  }];
 
            [[PhotoManager sharedManager] addPhoto:photo];
        }
        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5
        dispatch_async(dispatch_get_main_queue(), ^{ // 6
            if (completionBlock) { // 7
                completionBlock(error);
            }
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照注释的顺序，你会看到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;因为你在使用的是同步的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; ，它会阻塞当前线程，所以你要用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 将整个方法放入后台队列以避免阻塞主线程。&lt;/li&gt;
  &lt;li&gt;创建一个新的 Dispatch Group，它的作用就像一个用于未完成任务的计数器。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt; 手动通知 Dispatch Group 任务已经开始。你必须保证 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt; 成对出现，否则你可能会遇到诡异的崩溃问题。&lt;/li&gt;
  &lt;li&gt;手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group 的次数和离开 Group 的次数相等。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用 &lt;code class=&quot;highlighter-rouge&quot;&gt;DISPATCH_TIME_FOREVER&lt;/code&gt; 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。&lt;/li&gt;
  &lt;li&gt;此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 回调。这会将工作放到主线程上，并在稍后执行。&lt;/li&gt;
  &lt;li&gt;最后，检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 是否为 nil，如果不是，那就运行它。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行 completionBlock 的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察 completionBlock 被调用的时刻，那么你可以在 Settings 应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往 Network Link Conditioner 区，开启它，再选择一个 Profile，“Very Bad Network” 就不错。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你是在模拟器里运行应用，你可以使用 &lt;a href=&quot;http://nshipster.com/network-link-conditioner/&quot;&gt;来自 GitHub 的 Network Link Conditioner&lt;/a&gt; 来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。&lt;/p&gt;

&lt;p&gt;目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。&lt;/p&gt;

&lt;p&gt;在我们转向另外一种使用 Dispatch Group 的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的 Dispatch Group ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自定义串行队列：它很适合当一组任务完成时发出通知。&lt;/li&gt;
  &lt;li&gt;主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。&lt;/li&gt;
  &lt;li&gt;并发队列：它也很适合 Dispatch Group 和完成时通知。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dispatch-group第二种方式&quot;&gt;Dispatch Group，第二种方式&lt;/h3&gt;

&lt;p&gt;上面的一切都很好，但在另一个队列上异步调度然后使用 dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式……&lt;/p&gt;

&lt;p&gt;在 PhotoManager.m 中找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotosWithCompletionBlock:&lt;/code&gt; 方法，用下面的实现替换它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock
{
    // 1
    __block NSError *error;
    dispatch_group_t downloadGroup = dispatch_group_create(); 
 
    for (NSInteger i = 0; i &amp;lt; 3; i++) {
        NSURL *url;
        switch (i) {
            case 0:
                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];
                break;
            case 1:
                url = [NSURL URLWithString:kSuccessKidURLString];
                break;
            case 2:
                url = [NSURL URLWithString:kLotsOfFacesURLString];
                break;
            default:
                break;
        }
 
        dispatch_group_enter(downloadGroup); // 2
        Photo *photo = [[Photo alloc] initwithURL:url
                              withCompletionBlock:^(UIImage *image, NSError *_error) {
                                  if (_error) {
                                      error = _error;
                                  }
                                  dispatch_group_leave(downloadGroup); // 3
                              }];
 
        [[PhotoManager sharedManager] addPhoto:photo];
    }
 
    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4
        if (completionBlock) {
            completionBlock(error);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面解释新的异步方法如何工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在 &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; 调用中。&lt;/li&gt;
  &lt;li&gt;同样的 &lt;code class=&quot;highlighter-rouge&quot;&gt;enter&lt;/code&gt; 方法，没做任何修改。&lt;/li&gt;
  &lt;li&gt;同样的 &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt; 方法，也没做任何修改。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_notify&lt;/code&gt; 以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 便会运行。你还指定了运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 的队列，此处，主队列就是你所需要的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。&lt;/p&gt;

&lt;h2 id=&quot;太多并发带来的风险&quot;&gt;太多并发带来的风险&lt;/h2&gt;

&lt;p&gt;既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Thread_All_The_Code_Meme.jpg&quot; alt=&quot;Thread_All_The_Code_Meme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看看 PhotoManager 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotosWithCompletionBlock&lt;/code&gt; 方法。你可能已经注意到这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环并发运行，以提高其速度。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 刚好可用于这个任务。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 表现得就像一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环一样，它只会在所有工作都完成后才会返回。&lt;/p&gt;

&lt;p&gt;当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为&lt;code class=&quot;highlighter-rouge&quot;&gt;跨越式（striding）&lt;/code&gt;的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：大概就能减少并发数量吧，作者是提醒大家注意并发的开销，记在心里！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那何时才适合用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自定义串行队列：串行队列会完全抵消 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 的功能；你还不如直接使用普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环。&lt;/li&gt;
  &lt;li&gt;主队列（串行）：与上面一样，在串行队列上不适合使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 。还是用普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环吧。&lt;/li&gt;
  &lt;li&gt;并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadPhotosWithCompletionBlock:&lt;/code&gt; 并用下列实现替换它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock
{
    __block NSError *error;
    dispatch_group_t downloadGroup = dispatch_group_create();
 
    dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) {
 
        NSURL *url;
        switch (i) {
            case 0:
                url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];
                break;
            case 1:
                url = [NSURL URLWithString:kSuccessKidURLString];
                break;
            case 2:
                url = [NSURL URLWithString:kLotsOfFacesURLString];
                break;
            default:
                break;
        }
 
        dispatch_group_enter(downloadGroup);
        Photo *photo = [[Photo alloc] initwithURL:url
                              withCompletionBlock:^(UIImage *image, NSError *_error) {
                                  if (_error) {
                                      error = _error;
                                  }
                                  dispatch_group_leave(downloadGroup);
                              }];
 
        [[PhotoManager sharedManager] addPhoto:photo];
    });
 
    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{
        if (completionBlock) {
            completionBlock(error);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你的循环现在是并行运行的了；在上面的代码中，在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个 Block。&lt;/p&gt;

&lt;p&gt;要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。&lt;/p&gt;

&lt;p&gt;编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？&lt;/p&gt;

&lt;p&gt;在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？&lt;/p&gt;

&lt;p&gt;实际上，在这个例子里并不值得。下面是原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你创建并行运行线程而付出的开销，很可能比直接使用  &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在 Instruments 里分析你的应用，找出最长运行时间的方法。看看 &lt;a href=&quot;http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode&quot;&gt;如何在 Xcode 中使用 Instruments&lt;/a&gt; 可以学到更多相关知识。&lt;/li&gt;
  &lt;li&gt;通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。&lt;/p&gt;

&lt;h2 id=&quot;gcd-的其他趣味&quot;&gt;GCD 的其他趣味&lt;/h2&gt;

&lt;p&gt;等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。&lt;/p&gt;

&lt;h3 id=&quot;阻塞正确的方式&quot;&gt;阻塞——正确的方式&lt;/h3&gt;

&lt;p&gt;这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:] 我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。&lt;/p&gt;

&lt;p&gt;Xcode 里的测试在 &lt;code class=&quot;highlighter-rouge&quot;&gt;XCTestCase&lt;/code&gt; 的子类上执行，并运行任何方法签名以 &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; 开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。&lt;/p&gt;

&lt;p&gt;当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。&lt;/p&gt;

&lt;p&gt;网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Gandalf_Semaphore.png&quot; alt=&quot;Gandalf_Semaphore&quot; /&gt;&lt;/p&gt;

&lt;p&gt;导航到 GooglyPuffTests.m 并查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadImageURLWithString:&lt;/code&gt;，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)downloadImageURLWithString:(NSString *)URLString
{
    NSURL *url = [NSURL URLWithString:URLString];
    __block BOOL isFinishedDownloading = NO;
    __unused Photo *photo = [[Photo alloc]
                             initwithURL:url
                             withCompletionBlock:^(UIImage *image, NSError *error) {
                                 if (error) {
                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);
                                 }
                                 isFinishedDownloading = YES;
                             }];
 
    while (!isFinishedDownloading) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一种测试异步网络代码的幼稚方式。 While 循环在函数的最后一直等待，直到 &lt;code class=&quot;highlighter-rouge&quot;&gt;isFinishedDownloading&lt;/code&gt; 布尔值变成 True，它只会在 Completion Block 里发生。让我们看看这样做有什么影响。&lt;/p&gt;

&lt;p&gt;通过在 Xcode 中点击  Product / Test 运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ⌘+U 来运行你的测试。&lt;/p&gt;

&lt;p&gt;在测试运行时，注意 Xcode debug 导航栏里的 CPU 使用率。这个设计不当的实现就是一个基本的 &lt;a href=&quot;http://en.wikipedia.org/wiki/Spinlock&quot;&gt;自旋锁&lt;/a&gt; 。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：所谓自旋锁，就是某个线程一直抢占着 CPU 不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可能需要使用前面提到的 Network Link Conditioner ，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：作者反复提到网速太快，而我们还需要对付 GFW，简直泪流满面！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。&lt;/p&gt;

&lt;h3 id=&quot;信号量&quot;&gt;信号量&lt;/h3&gt;

&lt;p&gt;信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。&lt;/p&gt;

&lt;p&gt;如果你想学到更多关于信号量的知识，看看这个链接&lt;a href=&quot;http://greenteapress.com/semaphores/&quot;&gt;它更细致地讨论了信号量理论&lt;/a&gt;。如果你是学术型，那可以看一个软件开发中经典的&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98&quot;&gt;哲学家进餐问题&lt;/a&gt;，它需要使用信号量来解决。&lt;/p&gt;

&lt;p&gt;信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。&lt;/p&gt;

&lt;p&gt;让我们来使用信号量吧！&lt;/p&gt;

&lt;p&gt;打开 GooglyPuffTests.m 并用下列实现替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;downloadImageURLWithString:&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)downloadImageURLWithString:(NSString *)URLString
{
    // 1
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
 
    NSURL *url = [NSURL URLWithString:URLString];
    __unused Photo *photo = [[Photo alloc]
                             initwithURL:url
                             withCompletionBlock:^(UIImage *image, NSError *error) {
                                 if (error) {
                                     XCTFail(@&quot;%@ failed. %@&quot;, URLString, error);
                                 }
 
                                 // 2
                                 dispatch_semaphore_signal(semaphore);
                             }];
 
    // 3
    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);
    if (dispatch_semaphore_wait(semaphore, timeoutTime)) {
        XCTFail(@&quot;%@ timed out&quot;, URLString);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来说明你代码中的信号量是如何工作的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。&lt;/li&gt;
  &lt;li&gt;在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。&lt;/li&gt;
  &lt;li&gt;这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意 CPU 的使用率，与之前使用自旋锁的实现作个对比。&lt;/p&gt;

&lt;p&gt;关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开 Mac 的网络链接。测试会在 10 秒后失败。这很棒，它真的能按照预想的那样工作！&lt;/p&gt;

&lt;p&gt;还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。&lt;/p&gt;

&lt;h3 id=&quot;使用-dispatch-source&quot;&gt;使用 Dispatch Source&lt;/h3&gt;

&lt;p&gt;GCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个 Dispatch Source 对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。&lt;/p&gt;

&lt;p&gt;第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_source_create&lt;/code&gt; 如何工作。下面是创建一个源的函数原型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;dispatch_source_t dispatch_source_create(
   dispatch_source_type_t type,
   uintptr_t handle,
   unsigned long mask,
   dispatch_queue_t queue);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_source_type_t&lt;/code&gt; 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants&quot;&gt;Xcode 文档&lt;/a&gt; 得到哪些选项可用于每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_source_type_t&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;下面你将监控 &lt;code class=&quot;highlighter-rouge&quot;&gt;DISPATCH_SOURCE_TYPE_SIGNAL&lt;/code&gt; 。如&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL&amp;quot;&quot;&gt;文档所显示的&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。&lt;/p&gt;

&lt;p&gt;这些 Unix 信号组成的列表可在头文件  &lt;a href=&quot;http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h&quot;&gt;signal.h&lt;/a&gt; 中找到。在其顶部有一堆 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt; 语句。你将监控此信号列表中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用 LLDB 调试器调试应用时你使用的也是这个信号。&lt;/p&gt;

&lt;p&gt;去往 PhotoCollectionViewController.m 并添加如下代码到 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 的顶部，就在 &lt;code class=&quot;highlighter-rouge&quot;&gt;[super viewDidLoad]&lt;/code&gt; 下面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)viewDidLoad
{
  [super viewDidLoad];
 
  // 1
  #if DEBUG
      // 2
      dispatch_queue_t queue = dispatch_get_main_queue();
 
      // 3
      static dispatch_source_t source = nil;
 
      // 4
      __typeof(self) __weak weakSelf = self;
 
      // 5
      static dispatch_once_t onceToken;
      dispatch_once(&amp;amp;onceToken, ^{
          // 6
          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue);
 
          // 7
          if (source)
          {
              // 8
              dispatch_source_set_event_handler(source, ^{
                  // 9
                  NSLog(@&quot;Hi, I am: %@&quot;, weakSelf);
              });
              dispatch_resume(source); // 10
          }
      });
  #endif
 
  // The other stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察。 :]&lt;/li&gt;
  &lt;li&gt;Just to mix things up，你创建了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_t&lt;/code&gt; 实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。&lt;/li&gt;
  &lt;li&gt;你需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt; 在方法范围之外也可被访问，所以你使用了一个 static 变量。&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;weakSelf&lt;/code&gt; 以确保不会出现保留环（Retain Cycle）。这对 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoCollectionViewController&lt;/code&gt; 来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 确保只会执行一次 Dispatch Source 的设置。&lt;/li&gt;
  &lt;li&gt;初始化 &lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt; 变量。你指明了你对信号监控感兴趣并提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。&lt;/li&gt;
  &lt;li&gt;如果你提供的参数不合格，那么 Dispatch Source 对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的 Dispatch Source 。&lt;/li&gt;
  &lt;li&gt;当你收到你所监控的信号时，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_source_set_event_handler&lt;/code&gt; 就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（Logic Handler）。&lt;/li&gt;
  &lt;li&gt;一个基本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 语句，它将对象打印到控制台。&lt;/li&gt;
  &lt;li&gt;默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Text&quot;&gt;2014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？&lt;/p&gt;

&lt;p&gt;你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：好像挺有用！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/What_Meme.jpg&quot; alt=&quot;What_Meme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/I_See_What_You_Did_Meme.png&quot; alt=&quot;I_See_What_You_Did_Meme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的 PhotoCollectionViewController 方法深处。你可以访问 PhotoCollectionViewController 的实例得到你关心的内容。非常方便！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被 libdispatch 跟随，它是 GCD 的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在调试器里，键入命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;po [[weakSelf navigationItem] setPrompt:@&quot;WOOT!&quot;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后恢复应用的执行。你会看到如下内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console.png&quot; alt=&quot;Dispatch_Sources_Xcode_Breakpoint_Console&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI.png&quot; alt=&quot;Dispatch_Sources_Debugger_Updating_UI&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用这个方法，你可以更新 UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;译者注：发挥这一点，是可以做出一些调试库的吧？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;之后又该往何处去&quot;&gt;之后又该往何处去？&lt;/h2&gt;

&lt;p&gt;你可以&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/GooglyPuff-Final.zip&quot;&gt;在此下载最终的项目&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我讨厌再次提及此主题，但你真的要看看 &lt;a href=&quot;http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode&quot;&gt;如何使用 Instruments&lt;/a&gt; 教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments 擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。&lt;/p&gt;

&lt;p&gt;同样请看看 &lt;a href=&quot;http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues&quot;&gt;如何使用 NSOperations 和 NSOperationQueues&lt;/a&gt; 吧，它们是建立在 GCD 之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用 GCD 的最佳实践，。NSOperations 提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。&lt;/p&gt;

&lt;p&gt;记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别 API），否则永远应尝试并坚持使用高级的 API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入 Apple 的黑暗艺术。&lt;/p&gt;

&lt;p&gt;祝你好运，玩得开心！有任何问题或反馈请在下方的讨论区贴出！&lt;/p&gt;

&lt;p&gt;=====================&lt;/p&gt;

&lt;p&gt;译者注：欢迎非商业转载，但请一定注明出处：&lt;a href=&quot;https://github.com/nixzhu/dev-blog&quot;&gt;https://github.com/nixzhu/dev-blog&lt;/a&gt; ！&lt;/p&gt;

&lt;p&gt;欢迎转发此条微博 &lt;a href=&quot;http://weibo.com/2076580237/B4eHynxYo&quot;&gt;http://weibo.com/2076580237/B4eHynxYo&lt;/a&gt;  以分享给更多人！&lt;/p&gt;

&lt;p&gt;如果你认为这篇翻译不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳译者的辛苦：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/nixzhu/dev-blog/raw/master/images/nixzhu_alipay.png&quot; alt=&quot;nixzhu的支付宝二维码&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;版权声明：自由转载-非商用-非衍生-保持署名&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Thu, 13 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/13/%E8%BD%ACGCD%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/13/%E8%BD%ACGCD%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
        
        <category>GCD</category>
        
        
      </item>
    
      <item>
        <title>（转）GCD 深入理解：第一部分</title>
        <description>&lt;h1 id=&quot;转gcd-深入理解第一部分&quot;&gt;（转）GCD 深入理解：第一部分&lt;/h1&gt;

&lt;p&gt;本文翻译自 &lt;a href=&quot;http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1&quot;&gt;http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原作者：&lt;a href=&quot;http://www.raywenderlich.com/u/Lolgrep&quot;&gt;Derek Selander&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：&lt;a href=&quot;https://twitter.com/nixzhu&quot;&gt;@nixzhu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;==========================================&lt;/p&gt;

&lt;p&gt;虽然 GCD 已经出现过一段时间了，但不是每个人都明了其主要内容。这是可以理解的；并发一直很棘手，而 GCD 是基于 C 的 API ，它们就像一组尖锐的棱角戳进 Objective-C 的平滑世界。我们将分两个部分的教程来深入学习 GCD 。&lt;/p&gt;

&lt;p&gt;在这两部分的系列中，第一个部分的将解释 GCD 是做什么的，并从许多基本的 GCD 函数中找出几个来展示。在&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md&quot;&gt;第二部分&lt;/a&gt;，你将学到几个 GCD 提供的高级函数。&lt;/p&gt;

&lt;h2 id=&quot;什么是-gcd&quot;&gt;什么是 GCD&lt;/h2&gt;

&lt;p&gt;GCD 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;libdispatch&lt;/code&gt; 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。&lt;/li&gt;
  &lt;li&gt;GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。&lt;/li&gt;
  &lt;li&gt;GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本教程假设你对 Block 和 GCD 有基础了解。如果你对 GCD 完全陌生，先看看 &lt;a href=&quot;http://www.raywenderlich.com/4295/multithreading-and-grand-central-dispatch-on-ios-for-beginners-tutorial&quot;&gt;iOS 上的多线程和 GCD 入门教程&lt;/a&gt; 学习其要领。&lt;/p&gt;

&lt;h2 id=&quot;gcd-术语&quot;&gt;GCD 术语&lt;/h2&gt;

&lt;p&gt;要理解 GCD ，你要先熟悉与线程和并发相关的几个概念。这两者都可能模糊和微妙，所以在开始 GCD 之前先简要地回顾一下它们。&lt;/p&gt;

&lt;h4 id=&quot;serial-vs-concurrent-串行-vs-并发&quot;&gt;Serial vs. Concurrent 串行 vs. 并发&lt;/h4&gt;

&lt;p&gt;这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。&lt;/p&gt;

&lt;p&gt;虽然这些术语被广泛使用，本教程中你可以将任务设定为一个 Objective-C 的 Block 。不明白什么是 Block ？看看 &lt;a href=&quot;http://www.raywenderlich.com/9328/creating-a-diner-app-using-blocks-part-1&quot;&gt;iOS 5 教程中的如何使用 Block&lt;/a&gt; 。实际上，你也可以在 GCD 上使用函数指针，但在大多数场景中，这实际上更难于使用。Block 就是更加容易些！&lt;/p&gt;

&lt;h4 id=&quot;synchronous-vs-asynchronous-同步-vs-异步&quot;&gt;Synchronous vs. Asynchronous 同步 vs. 异步&lt;/h4&gt;

&lt;p&gt;在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个_同步_函数只在完成了它预定的任务后才返回。&lt;/p&gt;

&lt;p&gt;一个_异步_函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。&lt;/p&gt;

&lt;p&gt;注意——当你读到同步函数“阻塞（Block）”当前线程，或函数是一个“阻塞”函数或阻塞操作时，不要被搞糊涂了！动词“阻塞”描述了函数如何影响它所在的线程而与名词“代码块（Block）”没有关系。代码块描述了用 Objective-C 编写的一个匿名函数，它能定义一个任务并被提交到 GCD 。&lt;/p&gt;

&lt;p&gt;译者注：中文不会有这个问题，“阻塞”和“代码块”是两个词。&lt;/p&gt;

&lt;h4 id=&quot;critical-section-临界区&quot;&gt;Critical Section 临界区&lt;/h4&gt;

&lt;p&gt;就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（译者注：它的值不再可信）。&lt;/p&gt;

&lt;h4 id=&quot;race-condition-竞态条件&quot;&gt;Race Condition 竞态条件&lt;/h4&gt;

&lt;p&gt;这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。&lt;/p&gt;

&lt;h4 id=&quot;deadlock-死锁&quot;&gt;Deadlock 死锁&lt;/h4&gt;

&lt;p&gt;两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。&lt;/p&gt;

&lt;h4 id=&quot;thread-safe-线程安全&quot;&gt;Thread Safe 线程安全&lt;/h4&gt;

&lt;p&gt;线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt; 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableDictionary&lt;/code&gt; 就不是线程安全的，应该保证一次只能有一个线程访问它。&lt;/p&gt;

&lt;h4 id=&quot;context-switch-上下文切换&quot;&gt;Context Switch 上下文切换&lt;/h4&gt;

&lt;p&gt;一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。&lt;/p&gt;

&lt;h3 id=&quot;concurrency-vs-parallelism-并发与并行&quot;&gt;Concurrency vs Parallelism 并发与并行&lt;/h3&gt;

&lt;p&gt;并发和并行通常被一起提到，所以值得花些时间解释它们之间的区别。&lt;/p&gt;

&lt;p&gt;并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Concurrency_vs_Parallelism.png&quot; alt=&quot;Concurrency_vs_Parallelism&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然你可以编写代码在 GCD 下并发执行，但 GCD 会决定有多少并行的需求。并行_要求_并发，但并发并不能_保证_并行。&lt;/p&gt;

&lt;p&gt;更深入的观点是并发实际上是关于_构造_。当你在脑海中用 GCD 编写代码，你组织你的代码来暴露能同时运行的多个工作片段，以及不能同时运行的那些。如果你想深入此主题，看看 &lt;a href=&quot;http://vimeo.com/49718712&quot;&gt;这个由Rob Pike做的精彩的讲座&lt;/a&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;queues-队列&quot;&gt;Queues 队列&lt;/h3&gt;

&lt;p&gt;GCD 提供有 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch queues&lt;/code&gt; 来处理代码块，这些队列管理你提供给 GCD 的任务并用 FIFO 顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。&lt;/p&gt;

&lt;p&gt;所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。当你了解了调度队列如何为你自己代码的不同部分提供线程安全后，GCD的优点就是显而易见的。关于这一点的关键是选择正确_类型_的调度队列和正确的_调度函数_来提交你的工作。&lt;/p&gt;

&lt;p&gt;在本节你会看到两种调度队列，都是由 GCD 提供的，然后看一些描述如何用调度函数添加工作到队列的例子。&lt;/p&gt;

&lt;h4 id=&quot;serial-queues-串行队列&quot;&gt;Serial Queues 串行队列&lt;/h4&gt;

&lt;p&gt;串行队列中的任务一次执行一个，每个任务只在前一个任务完成时才开始。而且，你不知道在一个 Block 结束和下一个开始之间的时间长度，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/Serial-Queue-480x272.png&quot; alt=&quot;Serial-Queue&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。&lt;/p&gt;

&lt;p&gt;由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了。&lt;/p&gt;

&lt;h4 id=&quot;concurrent-queues-并发队列&quot;&gt;Concurrent Queues 并发队列&lt;/h4&gt;

&lt;p&gt;在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。&lt;/p&gt;

&lt;p&gt;下图展示了一个示例任务执行计划，GCD 管理着四个并发任务：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Concurrent-Queue.png&quot; alt=&quot;Concurrent-Queue&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。&lt;/p&gt;

&lt;p&gt;何时开始一个 Block 完全取决于 GCD 。如果一个 Block 的执行时间与另一个重叠，也是由 GCD 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 Block 。&lt;/p&gt;

&lt;p&gt;有趣的是， GCD 提供给你至少五个特定的队列，可根据队列类型选择使用。&lt;/p&gt;

&lt;h4 id=&quot;queue-types-队列类型&quot;&gt;Queue Types 队列类型&lt;/h4&gt;

&lt;p&gt;首先，系统提供给你一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;主队列（main queue）&lt;/code&gt; 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发生消息给 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; 或发送通知的。&lt;/p&gt;

&lt;p&gt;系统同时提供给你好几个并发队列。它们叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;全局调度队列（Global Dispatch Queues）&lt;/code&gt; 。目前的四个全局队列有着不同的优先级：&lt;code class=&quot;highlighter-rouge&quot;&gt;background&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;low&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;high&lt;/code&gt;。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。&lt;/p&gt;

&lt;p&gt;最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有_五个_队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。&lt;/p&gt;

&lt;p&gt;以上是调度队列的大框架！&lt;/p&gt;

&lt;p&gt;GCD 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的列子，我们沿途会提供一些一般性的建议。&lt;/p&gt;

&lt;h2 id=&quot;入门&quot;&gt;入门&lt;/h2&gt;

&lt;p&gt;既然本教程的目标是优化且安全的使用 GCD 调用来自不同线程的代码，那么你将从一个近乎完成的叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;GooglyPuff&lt;/code&gt; 的项目入手。&lt;/p&gt;

&lt;p&gt;GooglyPuff 是一个没有优化，线程不安全的应用，它使用 Core Image 的人脸检测 API 来覆盖一对曲棍球眼睛到被检测到的人脸上。对于基本的图像，可以从相机胶卷选择，或用预设好的URL从互联网下载。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/GooglyPuff_Start_1.zip&quot;&gt;点击此处下载项目&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;完成项目下载之后，将其解压到某个方便的目录，再用 Xcode 打开它并编译运行。这个应用看起来如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/Workflow1.png&quot; alt=&quot;Workflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意当你选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;Le Internet&lt;/code&gt; 选项下载图片时，一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIAlertView&lt;/code&gt; 过早地弹出。你将在本系列教程地第二部分修复这个问题。&lt;/p&gt;

&lt;p&gt;这个项目中有四个有趣的类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PhotoCollectionViewController：它是应用开始的第一个视图控制器。它用缩略图展示所有选定的照片。&lt;/li&gt;
  &lt;li&gt;PhotoDetailViewController：它执行添加曲棍球眼睛到图像上的逻辑，并用一个 UIScrollView 来显示结果图片。&lt;/li&gt;
  &lt;li&gt;Photo：这是一个类簇，它根据一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURL&lt;/code&gt; 的实例或一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ALAsset&lt;/code&gt; 的实例来实例化照片。这个类提供一个图像、缩略图以及从 URL 下载的状态。&lt;/li&gt;
  &lt;li&gt;PhotoManager：它管理所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 的实例.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用-dispatch_async-处理后台任务&quot;&gt;用 dispatch_async 处理后台任务&lt;/h2&gt;

&lt;p&gt;回到应用并从你的相机胶卷添加一些照片或使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Le Internet&lt;/code&gt; 选项下载一些。&lt;/p&gt;

&lt;p&gt;注意在按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoCollectionViewController&lt;/code&gt; 中的一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;UICollectionViewCell&lt;/code&gt; 到生成一个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoDetailViewController&lt;/code&gt; 之间花了多久时间；你会注意到一个明显的滞后，特别是在比较慢的设备上查看很大的图。&lt;/p&gt;

&lt;p&gt;在重载 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController 的 viewDidLoad&lt;/code&gt; 时容易加入太多杂乱的工作（too much clutter），这通常会引起视图控制器出现前更长的等待。如果可能，最好是卸下一些工作放到后台，如果它们不是绝对必须要运行在加载时间里。&lt;/p&gt;

&lt;p&gt;这听起来像是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 能做的事情！&lt;/p&gt;

&lt;p&gt;打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoDetailViewController&lt;/code&gt; 并用下面的实现替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)viewDidLoad
{   
    [super viewDidLoad];
    NSAssert(_image, @&quot;Image not set; required to use view controller&quot;);
    self.photoImageView.image = _image;
 
    //Resize if neccessary to ensure it's not pixelated
    if (_image.size.height &amp;lt;= self.photoImageView.bounds.size.height &amp;amp;&amp;amp;
        _image.size.width &amp;lt;= self.photoImageView.bounds.size.width) {
        [self.photoImageView setContentMode:UIViewContentModeCenter];
    }
 
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ // 1
        UIImage *overlayImage = [self faceOverlayImageFromImage:_image];
        dispatch_async(dispatch_get_main_queue(), ^{ // 2
            [self fadeInNewImage:overlayImage]; // 3
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来说明上面的新代码所做的事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;你首先将工作从主线程移到全局线程。因为这是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async()&lt;/code&gt; ，Block 会被异步地提交，意味着调用线程地执行将会继续。这就使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 更早地在主线程完成，让加载过程感觉起来更加快速。同时，一个人脸检测过程会启动并将在稍后完成。&lt;/li&gt;
  &lt;li&gt;在这里，人脸检测过程完成，并生成了一个新的图像。既然你要使用此新图像更新你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView&lt;/code&gt; ，那么你就添加一个新的 Block 到主线程。记住——你必须总是在主线程访问 UIKit 的类。&lt;/li&gt;
  &lt;li&gt;最后，你用 &lt;code class=&quot;highlighter-rouge&quot;&gt;fadeInNewImage:&lt;/code&gt; 更新 UI ，它执行一个淡入过程切换到新的曲棍球眼睛图像。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编译并运行你的应用；选择一个图像然后你会注意到视图控制器加载明显变快，曲棍球眼睛稍微在之后就加上了。这给应用带来了不错的效果，和之前的显示差别巨大。&lt;/p&gt;

&lt;p&gt;进一步，如果你试着加载一个超大的图像，应用不会在加载视图控制器上“挂住”，这就使得应用具有很好伸缩性。&lt;/p&gt;

&lt;p&gt;正如之前提到的， &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 添加一个 Block 到队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; ，这样就不会阻塞当前线程。&lt;/p&gt;

&lt;p&gt;下面是一个关于在 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 上如何以及何时使用不同的队列类型的快速指导：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自定义串行队列：当你想串行执行后台任务并追踪它时就是一个好选择。这消除了资源争用，因为你知道一次只有一个任务在执行。注意若你需要来自某个方法的数据，你必须内联另一个 Block 来找回它或考虑使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;主队列（串行）：这是在一个并发队列上完成任务后更新 UI 的共同选择。要这样做，你将在一个 Block 内部编写另一个 Block 。以及，如果你在主队列调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 到主队列，你能确保这个新任务将在当前方法完成后的某个时间执行。&lt;/li&gt;
  &lt;li&gt;并发队列：这是在后台执行非 UI 工作的共同选择。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用-dispatch_after-延后工作&quot;&gt;使用 dispatch_after 延后工作&lt;/h2&gt;

&lt;p&gt;稍微考虑一下应用的 UX 。是否用户第一次打开应用时会困惑于不知道做什么？你是这样吗？ :]&lt;/p&gt;

&lt;p&gt;如果用户的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager&lt;/code&gt; 里还没有任何照片，那么显示一个提示会是个好主意！然而，你同样要考虑用户的眼睛会如何在主屏幕上浏览：如果你太快的显示一个提示，他们的眼睛还徘徊在视图的其它部分上，他们很可能会错过它。&lt;/p&gt;

&lt;p&gt;显示提示之前延迟一秒钟就足够捕捉到用户的注意，他们此时已经第一次看过了应用。&lt;/p&gt;

&lt;p&gt;添加如下代码到到 PhotoCollectionViewController.m 中 showOrHideNavPrompt 的废止实现里：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)showOrHideNavPrompt
{
    NSUInteger count = [[PhotoManager sharedManager] photos].count;
    double delayInSeconds = 1.0;
    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 
    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 
        if (!count) {
            [self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;];
        } else {
            [self.navigationItem setPrompt:nil];
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;showOrHideNavPrompt 在 viewDidLoad 中执行，以及 UICollectionView 被重新加载的任何时候。按照注释数字顺序看看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;你声明了一个变量指定要延迟的时长。&lt;/li&gt;
  &lt;li&gt;然后等待 &lt;code class=&quot;highlighter-rouge&quot;&gt;delayInSeconds&lt;/code&gt; 给定的时长，再异步地添加一个 Block 到主线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编译并运行应用。应该有一个轻微地延迟，这有助于抓住用户的注意力并展示所要做的事情。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 工作起来就像一个延迟版的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 。你依然不能控制实际的执行时间，且一旦 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 返回也就不能再取消它。&lt;/p&gt;

&lt;p&gt;不知道何时适合使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; ？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自定义串行队列：在一个自定义串行队列上使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 要小心。你最好坚持使用主队列。&lt;/li&gt;
  &lt;li&gt;主队列（串行）：是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 的好选择；Xcode 提供了一个不错的自动完成模版。&lt;/li&gt;
  &lt;li&gt;并发队列：在并发队列上使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 也要小心；你会这样做就比较罕见。还是在主队列做这些操作吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;让你的单例线程安全&quot;&gt;让你的单例线程安全&lt;/h2&gt;

&lt;p&gt;单例，不论喜欢还是讨厌，它们在 iOS 上的流行情况就像网上的猫。 :]&lt;/p&gt;

&lt;p&gt;一个常见的担忧是它们常常不是线程安全的。这个担忧十分合理，基于它们的用途：单例常常被多个控制器同时访问。&lt;/p&gt;

&lt;p&gt;单例的线程担忧范围从初始化开始，到信息的读和写。&lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager&lt;/code&gt; 类被实现为单例——它在目前的状态下就会被这些问题所困扰。要看看事情如何很快地失去控制，你将在单例实例上创建一个控制好的竞态条件。&lt;/p&gt;

&lt;p&gt;导航到 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager.m&lt;/code&gt; 并找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;sharedManager&lt;/code&gt; ；它看起来如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;+ (instancetype)sharedManager    
{
    static PhotoManager *sharedPhotoManager = nil;
    if (!sharedPhotoManager) {
        sharedPhotoManager = [[PhotoManager alloc] init];
        sharedPhotoManager-&amp;gt;_photosArray = [NSMutableArray array];
    }
    return sharedPhotoManager;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前状态下，代码相当简单；你创建了一个单例并初始化一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;photosArray&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableArray&lt;/code&gt; 属性。&lt;/p&gt;

&lt;p&gt;然而，&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 条件分支不是&lt;a href=&quot;http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1#Terminology&quot;&gt;线程安全&lt;/a&gt;的；如果你多次调用这个方法，有一个可能性是在某个线程（就叫它线程A）上进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句块并可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sharedPhotoManager&lt;/code&gt; 被分配内存前发生一个上下文切换。然后另一个线程（线程B）可能进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; ，分配单例实例的内存，然后退出。&lt;/p&gt;

&lt;p&gt;当系统上下文切换回线程A，你会分配另外一个单例实例的内存，然后退出。在那个时间点，你有了两个单例的实例——很明显这不是你想要的（译者注：这还能叫单例吗？）！&lt;/p&gt;

&lt;p&gt;要强制这个（竞态）条件发生，替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager.m&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;sharedManager&lt;/code&gt; 为下面的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;+ (instancetype)sharedManager  
{
    static PhotoManager *sharedPhotoManager = nil;
    if (!sharedPhotoManager) {
        [NSThread sleepForTimeInterval:2];
        sharedPhotoManager = [[PhotoManager alloc] init];
        NSLog(@&quot;Singleton has memory address at: %@&quot;, sharedPhotoManager);
        [NSThread sleepForTimeInterval:2];
        sharedPhotoManager-&amp;gt;_photosArray = [NSMutableArray array];
    }
    return sharedPhotoManager;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中你用 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSThread 的 sleepForTimeInterval:&lt;/code&gt; 类方法来强制发生一个上下文切换。&lt;/p&gt;

&lt;p&gt;打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate.m&lt;/code&gt; 并添加如下代码到 &lt;code class=&quot;highlighter-rouge&quot;&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; 的最开始处：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
    [PhotoManager sharedManager];
});
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
    [PhotoManager sharedManager];
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里创建了多个异步并发调用来实例化单例，然后引发上面描述的竞态条件。&lt;/p&gt;

&lt;p&gt;编译并运行项目；查看控制台输出，你会看到多个单例被实例化，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/NSLog-Race-Condition.png&quot; alt=&quot;NSLog-Race-Condition&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意到这里有好几行显示着不同地址的单例实例。这明显违背了单例的目的，对吧？:]&lt;/p&gt;

&lt;p&gt;这个输出向你展示了临界区被执行多次，而它只应该执行一次。现在，固然是你自己强制这样的状况发生，但你可以想像一下这个状况会怎样在无意间发生。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：基于其它你无法控制的系统事件，NSLog 的数量有时会显示多个。线程问题极其难以调试，因为它们往往难以重现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要纠正这个状况，实例化代码应该只执行一次，并阻塞其它实例在 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 条件的临界区运行。这刚好就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 能做的事。&lt;/p&gt;

&lt;p&gt;在单例初始化方法中用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 取代 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 条件判断，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;+ (instancetype)sharedManager
{
    static PhotoManager *sharedPhotoManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        [NSThread sleepForTimeInterval:2];
        sharedPhotoManager = [[PhotoManager alloc] init];
        NSLog(@&quot;Singleton has memory address at: %@&quot;, sharedPhotoManager);
        [NSThread sleepForTimeInterval:2];
        sharedPhotoManager-&amp;gt;_photosArray = [NSMutableArray array];
    });
    return sharedPhotoManager;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译并运行你的应用；查看控制台输出，你会看到有且仅有一个单例的实例——这就是你对单例的期望！:]&lt;/p&gt;

&lt;p&gt;现在你已经明白了防止竞态条件的重要性，从 &lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate.m&lt;/code&gt; 中移除 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 语句，并用下面的实现替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager&lt;/code&gt; 单例的初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;+ (instancetype)sharedManager
{
    static PhotoManager *sharedPhotoManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        sharedPhotoManager = [[PhotoManager alloc] init];
        sharedPhotoManager-&amp;gt;_photosArray = [NSMutableArray array];
    });
    return sharedPhotoManager;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once()&lt;/code&gt; 以线程安全的方式执行且仅执行其代码块一次。试图访问临界区（即传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 的代码）的不同的线程会在临界区已有一个线程的情况下被阻塞，直到临界区完成为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Highlander_dispatch_once-480x274.png&quot; alt=&quot;Highlander_dispatch_once&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要记住的是，这只是让访问共享实例线程安全。它绝对没有让类本身线程安全。类中可能还有其它竞态条件，例如任何操纵内部数据的情况。这些需要用其它方式来保证线程安全，例如同步访问数据，你将在下面几个小节看到。&lt;/p&gt;

&lt;h2 id=&quot;处理读者与写者问题&quot;&gt;处理读者与写者问题&lt;/h2&gt;

&lt;p&gt;线程安全实例不是处理单例时的唯一问题。如果单例属性表示一个可变对象，那么你就需要考虑是否那个对象自身线程安全。&lt;/p&gt;

&lt;p&gt;如果问题中的这个对象是一个 Foundation 容器类，那么答案是——“很可能不安全”！Apple 维护一个&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html&quot;&gt;有用且有些心寒的列表&lt;/a&gt;，众多的 Foundation 类都不是线程安全的。 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableArray&lt;/code&gt;，已用于你的单例，正在那个列表里休息。&lt;/p&gt;

&lt;p&gt;虽然许多线程可以同时读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableArray&lt;/code&gt; 的一个实例而不会产生问题，但当一个线程正在读取时让另外一个线程修改数组就是不安全的。你的单例在目前的状况下不能预防这种情况的发生。&lt;/p&gt;

&lt;p&gt;要分析这个问题，看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager.m&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;addPhoto:&lt;/code&gt;，转载如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)addPhoto:(Photo *)photo
{
    if (photo) {
        [_photosArray addObject:photo];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self postContentAddedNotification];
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;写&lt;/code&gt;方法，它修改一个私有可变数组对象。&lt;/p&gt;

&lt;p&gt;现在看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; ，转载如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (NSArray *)photos
{
  return [NSArray arrayWithArray:_photosArray];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;读&lt;/code&gt;方法，它读取可变数组。它为调用者生成一个不可变的拷贝，防止调用者不当地改变数组，但这不能提供任何保护来对抗当一个线程调用读方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 的同时另一个线程调用写方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;addPhoto:&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;这就是软件开发中经典的&lt;code class=&quot;highlighter-rouge&quot;&gt;读者写者问题&lt;/code&gt;。GCD 通过用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch barriers&lt;/code&gt; 创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;读者写者锁&lt;/code&gt; 提供了一个优雅的解决方案。&lt;/p&gt;

&lt;p&gt;Dispatch barriers 是一组函数，在并发队列上工作时扮演一个串行式的瓶颈。使用 GCD 的障碍（barrier）API 确保提交的 Block 在那个特定时间上是指定队列上唯一被执行的条目。这就意味着所有的先于调度障碍提交到队列的条目必能在这个 Block 执行前完成。&lt;/p&gt;

&lt;p&gt;当这个 Block 的时机到达，调度障碍执行这个 Block 并确保在那个时间里队列不会执行任何其它 Block 。一旦完成，队列就返回到它默认的实现状态。 GCD 提供了同步和异步两种障碍函数。&lt;/p&gt;

&lt;p&gt;下图显示了障碍函数对多个异步队列的影响：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Dispatch-Barrier-480x272.png&quot; alt=&quot;Dispatch-Barrier&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意到正常部分的操作就如同一个正常的并发队列。但当障碍执行时，它本质上就如同一个串行队列。也就是，障碍是唯一在执行的事物。在障碍完成后，队列回到一个正常并发队列的样子。&lt;/p&gt;

&lt;p&gt;下面是你何时会——和不会——使用障碍函数的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自定义串行队列：一个很坏的选择；障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。&lt;/li&gt;
  &lt;li&gt;全局并发队列：要小心；这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。&lt;/li&gt;
  &lt;li&gt;自定义并发队列：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于上面唯一像样的选择是自定义并发队列，你将创建一个你自己的队列去处理你的障碍函数并分开读和写函数。且这个并发队列将允许多个多操作同时进行。&lt;/p&gt;

&lt;p&gt;打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager.m&lt;/code&gt;，添加如下私有属性到类扩展中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;@interface PhotoManager ()
@property (nonatomic,strong,readonly) NSMutableArray *photosArray;
@property (nonatomic, strong) dispatch_queue_t concurrentPhotoQueue; ///&amp;lt; Add this
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;addPhoto:&lt;/code&gt; 并用下面的实现替换它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)addPhoto:(Photo *)photo
{
    if (photo) { // 1
        dispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 
            [_photosArray addObject:photo]; // 3
            dispatch_async(dispatch_get_main_queue(), ^{ // 4
                [self postContentAddedNotification]; 
            });
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你新写的函数是这样工作的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在执行下面所有的工作前检查是否有合法的相片。&lt;/li&gt;
  &lt;li&gt;添加写操作到你的自定义队列。当临界区在稍后执行时，这将是你队列中唯一执行的条目。&lt;/li&gt;
  &lt;li&gt;这是添加对象到数组的实际代码。由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行。&lt;/li&gt;
  &lt;li&gt;最后你发送一个通知说明完成了添加图片。这个通知将在主线程被发送因为它将会做一些 UI 工作，所以在此为了通知，你异步地调度另一个任务到主线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就处理了写操作，但你还需要实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 读方法并实例化 &lt;code class=&quot;highlighter-rouge&quot;&gt;concurrentPhotoQueue&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;在写者打扰的情况下，要确保线程安全，你需要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;concurrentPhotoQueue&lt;/code&gt; 队列上执行读操作。既然你需要从函数返回，你就不能异步调度到队列，因为那样在读者函数返回之前不一定运行。&lt;/p&gt;

&lt;p&gt;在这种情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 就是一个绝好的候选。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync()&lt;/code&gt; 同步地提交工作并在返回前等待它完成。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 跟踪你的调度障碍工作，或者当你需要等待操作完成后才能使用 Block 处理过的数据。如果你使用第二种情况做事，你将不时看到一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt; 变量写在 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 范围之外，以便返回时在 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 使用处理过的对象。&lt;/p&gt;

&lt;p&gt;但你需要很小心。想像如果你调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 并放在你已运行着的当前队列。这会导致死锁，因为调用会一直等待直到 Block 完成，但 Block 不能完成（它甚至不会开始！），直到当前已经存在的任务完成，而当前任务无法完成！这将迫使你自觉于你正从哪个队列调用——以及你正在传递进入哪个队列。&lt;/p&gt;

&lt;p&gt;下面是一个快速总览，关于在何时以及何处使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自定义串行队列：在这个状况下要非常小心！如果你正运行在一个队列并调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 放在同一个队列，那你就百分百地创建了一个死锁。&lt;/li&gt;
  &lt;li&gt;主队列（串行）：同上面的理由一样，必须非常小心！这个状况同样有潜在的导致死锁的情况。&lt;/li&gt;
  &lt;li&gt;并发队列：这才是做同步工作的好选择，不论是通过调度障碍，或者需要等待一个任务完成才能执行进一步处理的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;继续在 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager.m&lt;/code&gt; 上工作，用下面的实现替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (NSArray *)photos
{
    __block NSArray *array; // 1
    dispatch_sync(self.concurrentPhotoQueue, ^{ // 2
        array = [NSArray arrayWithArray:_photosArray]; // 3
    });
    return array;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是你的读函数。按顺序看看编过号的注释，有这些：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt; 关键字允许对象在 Block 内可变。没有它，&lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt; 在 Block 内部就只是只读的，你的代码甚至不能通过编译。&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;concurrentPhotoQueue&lt;/code&gt; 上同步调度来执行读操作。&lt;/li&gt;
  &lt;li&gt;将相片数组存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt; 内并返回它。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，你需要实例化你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;concurrentPhotoQueue&lt;/code&gt; 属性。修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;sharedManager&lt;/code&gt; 以便像下面这样初始化队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;+ (instancetype)sharedManager
{
    static PhotoManager *sharedPhotoManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        sharedPhotoManager = [[PhotoManager alloc] init];
        sharedPhotoManager-&amp;gt;_photosArray = [NSMutableArray array];
 
        // ADD THIS:
        sharedPhotoManager-&amp;gt;_concurrentPhotoQueue = dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,
                                                    DISPATCH_QUEUE_CONCURRENT); 
    });
 
    return sharedPhotoManager;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 初始化 &lt;code class=&quot;highlighter-rouge&quot;&gt;concurrentPhotoQueue&lt;/code&gt; 为一个并发队列。第一个参数是反向DNS样式命名惯例；确保它是描述性的，将有助于调试。第二个参数指定你的队列是串行还是并发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：当你在网上搜索例子时，你会经常看人们传递 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 给 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 的第二个参数。这是一个创建串行队列的过时方式；明确你的参数总是更好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恭喜——你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoManager&lt;/code&gt; 单例现在是线程安全的了。不论你在何处或怎样读或写你的照片，你都有这样的自信，即它将以安全的方式完成，不会出现任何惊吓。&lt;/p&gt;

&lt;h2 id=&quot;a-visual-review-of-queueing-队列的虚拟回顾&quot;&gt;A Visual Review of Queueing 队列的虚拟回顾&lt;/h2&gt;

&lt;p&gt;依然没有 100% 地掌握 GCD 的要领？确保你可以使用 GCD 函数轻松地创建简单的例子，使用断点和 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 语句保证自己明白当下发生的情况。&lt;/p&gt;

&lt;p&gt;我在下面提供了两个 GIF动画来帮助你巩固对 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 的理解。包含在每个 GIF 中的代码可以提供视觉辅助；仔细注意 GIF 左边显示代码断点的每一步，以及右边相关队列的状态。&lt;/p&gt;

&lt;h3 id=&quot;dispatch_sync-回顾&quot;&gt;dispatch_sync 回顾&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)viewDidLoad
{
  [super viewDidLoad];
 
  dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
 
      NSLog(@&quot;First Log&quot;);
 
  });
 
  NSLog(@&quot;Second Log&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/dispatch_sync_in_action.gif&quot; alt=&quot;dispatch_sync_in_action&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是图中几个步骤的说明：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主队列一路按顺序执行任务——接着是一个实例化 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; 的任务，其中包含了 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 在主线程执行。&lt;/li&gt;
  &lt;li&gt;主线程目前在 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 内，正要到达 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; Block 被添加到一个全局队列中，将在稍后执行。进程将在主线程挂起直到该 Block 完成。同时，全局队列并发处理任务；要记得 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。&lt;/li&gt;
  &lt;li&gt;全局队列处理 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; Block 加入之前已经出现在队列中的任务。&lt;/li&gt;
  &lt;li&gt;终于，轮到 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; Block 。&lt;/li&gt;
  &lt;li&gt;这个 Block 完成，因此主线程上的任务可以恢复。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 方法完成，主队列继续处理其他任务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 添加任务到一个队列并等待直到任务完成。&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 做类似的事情，但不同之处是它不会等待任务的完成，而是立即继续“调用线程”的其它任务。&lt;/p&gt;

&lt;h3 id=&quot;dispatch_async-回顾&quot;&gt;dispatch_async 回顾&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)viewDidLoad
{
  [super viewDidLoad];
 
  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
 
      NSLog(@&quot;First Log&quot;);
 
  });
 
  NSLog(@&quot;Second Log&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/dispatch_async_in_action.gif&quot; alt=&quot;dispatch_async_in_action&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主队列一路按顺序执行任务——接着是一个实例化 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; 的任务，其中包含了 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 在主线程执行。&lt;/li&gt;
  &lt;li&gt;主线程目前在 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 内，正要到达 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; Block 被添加到一个全局队列中，将在稍后执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt; 在添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 到全局队列后继续进行，主线程把注意力转向剩下的任务。同时，全局队列并发地处理它未完成地任务。记住 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。&lt;/li&gt;
  &lt;li&gt;添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 的代码块开始执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; Block 完成，两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 语句将它们的输出放在控制台上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这个特定的实例中，第二个 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 语句执行，跟着是第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 语句。并不总是这样——着取决于给定时刻硬件正在做的事情，而且你无法控制或知晓哪个语句会先执行。“第一个” &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog&lt;/code&gt; 在某些调用情况下会第一个执行。&lt;/p&gt;

&lt;h2 id=&quot;下一步怎么走&quot;&gt;下一步怎么走？&lt;/h2&gt;

&lt;p&gt;在本教程中，你学习了如何让你的代码线程安全，以及在执行 CPU 密集型任务时如何保持主线程的响应性。&lt;/p&gt;

&lt;p&gt;你可以下载&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2014/01/GooglyPuff_End_1.zip&quot;&gt; GooglyPuff 项目&lt;/a&gt;，它包含了目前所有本教程中编写的实现。在本教程的&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md&quot;&gt;第二部分&lt;/a&gt;，你将继续改进这个项目。&lt;/p&gt;

&lt;p&gt;如果你计划优化你自己的应用，那你应该用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Instruments&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Time Profile&lt;/code&gt; 模版分析你的工作。对这个工具的使用超出了本教程的范围，你可以看看 &lt;a href=&quot;http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode&quot;&gt;如何使用Instruments&lt;/a&gt; 来得到一个很好的概述。&lt;/p&gt;

&lt;p&gt;同时请确保在真实设备上分析，而在模拟器上测试会对程序速度产生非常不准确的印象。&lt;/p&gt;

&lt;p&gt;在教程的下一部分，你将更加深入到 GCD 的 API 中，做一些更 Cool 的东西。&lt;/p&gt;

&lt;p&gt;如果你有任何问题或评论，可自由地加入下方的讨论！&lt;/p&gt;

&lt;p&gt;===============================================&lt;/p&gt;

&lt;p&gt;译者注：欢迎转载，但请一定注明出处！ &lt;a href=&quot;https://github.com/nixzhu/dev-blog&quot;&gt;https://github.com/nixzhu/dev-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎转发此条微博 &lt;a href=&quot;http://weibo.com/2076580237/B0tjrEQr9&quot;&gt;http://weibo.com/2076580237/B0tjrEQr9&lt;/a&gt;  以分享给更多人！&lt;/p&gt;

&lt;p&gt;如果你认为这篇翻译不错，也有闲钱，那你可以用支付宝随便捐助一点，以慰劳译者的辛苦：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/nixzhu/dev-blog/raw/master/images/nixzhu_alipay.png&quot; alt=&quot;nixzhu的支付宝二维码&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 12 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/12/%E8%BD%AC-GCD/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/12/%E8%BD%AC-GCD/</guid>
        
        <category>GCD</category>
        
        
      </item>
    
  </channel>
</rss>
