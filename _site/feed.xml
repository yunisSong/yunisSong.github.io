<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三十一</title>
    <description>潜心修行中。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 08 Aug 2017 08:46:57 +0800</pubDate>
    <lastBuildDate>Tue, 08 Aug 2017 08:46:57 +0800</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>正则表达式必知必会</title>
        <description>&lt;h1 id=&quot;正则表达式必知必会&quot;&gt;正则表达式必知必会&lt;/h1&gt;
&lt;h3 id=&quot;匹配单个字符&quot;&gt;匹配单个字符&lt;/h3&gt;

&lt;h4 id=&quot;匹配纯文本&quot;&gt;匹配纯文本&lt;/h4&gt;
&lt;p&gt;相当于文本查找的功能（CMD + F）。但是一般的正则表达式引擎默认返回第一个匹配结果。&lt;/p&gt;
&lt;h4 id=&quot;大小写匹配&quot;&gt;大小写匹配&lt;/h4&gt;
&lt;h4 id=&quot;匹配任意字符&quot;&gt;匹配任意字符&lt;/h4&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 来匹配任意字符。
譬如：使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yunis.&lt;/code&gt; 来匹配，&lt;code class=&quot;highlighter-rouge&quot;&gt;yunis1&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;yunis2&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;yunis3&lt;/code&gt;都是符合搜索结果的。&lt;/p&gt;
&lt;h4 id=&quot;匹配特殊字符&quot;&gt;匹配特殊字符&lt;/h4&gt;
&lt;p&gt;如果需要匹配特殊字符（ &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 等）就需要使用元字符（ &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; 反斜杠）来对他进行转义。
譬如：使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yunis\.&lt;/code&gt; 来匹配， &lt;code class=&quot;highlighter-rouge&quot;&gt;yunis.&lt;/code&gt; 是符合匹配结果的。&lt;/p&gt;
&lt;h3 id=&quot;匹配一组字符&quot;&gt;匹配一组字符&lt;/h3&gt;
&lt;h4 id=&quot;匹配多个字符串中的任意一个&quot;&gt;匹配多个字符串中的任意一个&lt;/h4&gt;
&lt;p&gt;譬如：使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[abc]hhhh&lt;/code&gt; 进行匹配。&lt;code class=&quot;highlighter-rouge&quot;&gt;ahhhh&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;bhhhh&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;chhhh&lt;/code&gt; 都是符合条件的搜索结果。&lt;/p&gt;
&lt;h4 id=&quot;例如字符集合区间&quot;&gt;例如字符集合区间&lt;/h4&gt;
&lt;p&gt;譬如：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[a-c]hhh&lt;/code&gt; 进行匹配，&lt;code class=&quot;highlighter-rouge&quot;&gt;ahhhh&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;bhhhh&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;chhhh&lt;/code&gt; 都是符合条件的搜索结果。
使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[0-9]hhh&lt;/code&gt; 进行匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;0hhh&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;1hhh&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;2hhh&lt;/code&gt; 。。。 &lt;code class=&quot;highlighter-rouge&quot;&gt;9hhh&lt;/code&gt; 都是符合条件的搜索结果。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A-Z 匹配 A 到 Z 的所有大写字母。&lt;/li&gt;
  &lt;li&gt;a-z 匹配 a 到 z 的所有小写字母。&lt;/li&gt;
  &lt;li&gt;A-F 匹配 A 到 F 的所有大写字母。&lt;/li&gt;
  &lt;li&gt;A-z 匹配从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt; 字符 A 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt; 字符 z 的所有字母。&lt;/li&gt;
  &lt;li&gt;同一个字符集合里面可以给出多个字符区间。譬如 &lt;code class=&quot;highlighter-rouge&quot;&gt;[A-Za-z0-9]&lt;/code&gt; 可以匹配任何字母和数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;取非匹配&quot;&gt;取非匹配&lt;/h4&gt;
&lt;p&gt;可以使用元字符 &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 来标明你想对一个字符集合取非匹配结果。
譬如：使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;a[\^0-9]&lt;/code&gt; 进行匹配, as,ab,ac 都是符合调剂的搜索结果，a0，a1,a2不是符合条件的搜索结果。&lt;/p&gt;
&lt;h3 id=&quot;使用元字符&quot;&gt;使用元字符&lt;/h3&gt;
&lt;h4 id=&quot;对特殊字符使用转义&quot;&gt;对特殊字符使用转义&lt;/h4&gt;
&lt;p&gt;如果想匹配元字符需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; 反斜杠来转义。
譬如：匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; 本身就需要转义，需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;\\&lt;/code&gt;来匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;。
    匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt; 需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;\[&lt;/code&gt; 来进行匹配。&lt;/p&gt;

&lt;h4 id=&quot;匹配空白字符&quot;&gt;匹配空白字符&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt; 换页符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; 换行符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\r&lt;/code&gt; 回车符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt; 制表符（Tab）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\v&lt;/code&gt; 垂直制表符
    &lt;h4 id=&quot;匹配数字&quot;&gt;匹配数字&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\d&lt;/code&gt; 匹配任意一个数字字符 等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;[0-9]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\D&lt;/code&gt; 匹配任意一个非数字字符 等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;[^0-9]&lt;/code&gt;
    &lt;h4 id=&quot;匹配字母与数字&quot;&gt;匹配字母与数字&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\w&lt;/code&gt; 匹配任意一个字母、数字或者下划线字符，等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;[a-zA-z0-9_]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\W&lt;/code&gt; 匹配任何一个非字母、数字或者下划线字符，等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;[^a-zA-z0-9_]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;匹配空白字符-1&quot;&gt;匹配空白字符&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\s&lt;/code&gt; 任意一个空白符 ，等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;[\f\n\r\t\v]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\S&lt;/code&gt; 任意一个非空白符 ，等价于 &lt;code class=&quot;highlighter-rouge&quot;&gt;[^\f\n\r\t\v]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;重复匹配&quot;&gt;重复匹配&lt;/h3&gt;
&lt;h4 id=&quot;匹配一个或多个字符&quot;&gt;匹配一个或多个字符&lt;/h4&gt;
&lt;p&gt;想要匹配同一个字符或者字符集合的多次重复，只需要简单的给这个字符或字符集合加上一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 字符作为后缀就行了。
&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 匹配一个或者多个字符（至少一个，不匹配零个字符的情况）。譬如 a 匹配 a 本身，a+ 将匹配一个或多个连续出现的 a 。类似的 ,&lt;code class=&quot;highlighter-rouge&quot;&gt;[0-9]&lt;/code&gt; 匹配任意一个数字，&lt;code class=&quot;highlighter-rouge&quot;&gt;[0-9]+&lt;/code&gt; 匹配一个或多个连续的数字。&lt;/p&gt;

&lt;p&gt;匹配邮箱：&lt;code class=&quot;highlighter-rouge&quot;&gt;[\w.]+@[\w.]\.\w+&lt;/code&gt;
一般来说，在字符集合里面的元字符将被解释为普通字符，不需要被转义，但转义了也没有坏处。 &lt;code class=&quot;highlighter-rouge&quot;&gt;[\w.]&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;[\w\\.]&lt;/code&gt; 是一样的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 是一个元字符。如果需要匹配 + 本身，需要转义。&lt;/p&gt;

&lt;h4 id=&quot;匹配零个或者多个字符&quot;&gt;匹配零个或者多个字符&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 匹配一个或者多个字符，&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 匹配零个或者多个字符。
&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 是元字符，匹配他本身需要转义。&lt;/p&gt;
&lt;h4 id=&quot;匹配零个或者一个字符&quot;&gt;匹配零个或者一个字符&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 元字符 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 的意思是匹配一个字符一次或者零次。
譬如：&lt;code class=&quot;highlighter-rouge&quot;&gt;https?&lt;/code&gt; 进行匹配，&lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;https&lt;/code&gt; 都是符合条件的搜索结果。&lt;/p&gt;
&lt;h4 id=&quot;匹配重复次数&quot;&gt;匹配重复次数&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 匹配的字符个数没有上限。我们无法为他们将匹配的字符个数设定一个最大值。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;？&lt;/code&gt; 至少匹配零个或者一个字符。无法为他们匹配的字符个数设定一个最小值。&lt;/li&gt;
  &lt;li&gt;如果只使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 我们无法将他们匹配的字符个数设定为一个精确的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;为重复匹配设定一个精确的值&quot;&gt;为重复匹配设定一个精确的值&lt;/h5&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; 表示前一个字符匹配6次。
譬如 &lt;code class=&quot;highlighter-rouge&quot;&gt;y{6}&lt;/code&gt; 进行匹配，&lt;code class=&quot;highlighter-rouge&quot;&gt;yyyyyy&lt;/code&gt; 是符合条件的匹配结果。&lt;/p&gt;
&lt;h5 id=&quot;为重复匹配设定一个区间&quot;&gt;为重复匹配设定一个区间&lt;/h5&gt;
&lt;p&gt;譬如使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;y{2,4}&lt;/code&gt; 进行匹配，&lt;code class=&quot;highlighter-rouge&quot;&gt;yy&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;yyy&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;yyyy&lt;/code&gt; 都是符合条件的搜索结果。&lt;/p&gt;
&lt;h5 id=&quot;为重复匹配设定一个最小重复数字&quot;&gt;为重复匹配设定一个最小重复数字&lt;/h5&gt;
&lt;p&gt;譬如使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;y{2,}&lt;/code&gt; 进行匹配，&lt;code class=&quot;highlighter-rouge&quot;&gt;yy&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;yyy&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;yyyy&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;yyyyyyyyyyyy&lt;/code&gt; 都是符合条件的搜索结果。
这个正则的意思是y至少重复2次。&lt;/p&gt;
&lt;h5 id=&quot;防止过度匹配&quot;&gt;防止过度匹配&lt;/h5&gt;
&lt;p&gt;下面一段文本 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;1234&amp;lt;/b&amp;gt;qweqweqweqweqweqweqw&amp;lt;b&amp;gt;5678&amp;lt;/b&amp;gt;&lt;/code&gt;
当我们使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;.*&amp;lt;/b&amp;gt;&lt;/code&gt; 进行匹配时，我们希望得到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;1234&amp;lt;/b&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;5678&amp;lt;/b&amp;gt;&lt;/code&gt; ，但是我们得到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;1234&amp;lt;/b&amp;gt;qweqweqweqweqweqweqw&amp;lt;b&amp;gt;5678&amp;lt;/b&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这是因为什么呢？
因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;贪婪型&lt;/code&gt; 的元字符，它们进行匹配时的模式是多多益善而不是适可而止。它们会尽可能的从一段文本的开头一直匹配到这段文本的结尾，而不是从文本的开头匹配到第一个匹配时为止。&lt;/p&gt;

&lt;p&gt;当不需要这种贪婪型模式时怎么办？使用它们的懒惰型版本，懒惰型版本会尽可能少的匹配字符。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;贪婪型元字符&lt;/th&gt;
      &lt;th&gt;懒惰型元字符&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*?&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+?&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当我们使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;.*?&amp;lt;/b&amp;gt;&lt;/code&gt; 进行匹配时，就能得到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;1234&amp;lt;/b&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;5678&amp;lt;/b&amp;gt;&lt;/code&gt; 的匹配结果。&lt;/p&gt;

&lt;h3 id=&quot;位置匹配&quot;&gt;位置匹配&lt;/h3&gt;
&lt;h4 id=&quot;单词边界&quot;&gt;单词边界&lt;/h4&gt;
&lt;p&gt;文本 &lt;code class=&quot;highlighter-rouge&quot;&gt;dog hjhjdogkjhkj hhh dogs.&lt;/code&gt; 当我们使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dog&lt;/code&gt; 进行匹配时，我们只希望匹配到第一个单词 &lt;code class=&quot;highlighter-rouge&quot;&gt;dog&lt;/code&gt;，但是匹配的结果是 &lt;strong&gt;dog&lt;/strong&gt; hjhj&lt;strong&gt;dog&lt;/strong&gt;kjhkj hhh &lt;strong&gt;dog&lt;/strong&gt;s.&lt;/p&gt;

&lt;p&gt;这个时间就需要使用单词边界来限定了，单词边界由限定符 &lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt; 表示。&lt;/p&gt;

&lt;p&gt;当我们使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;\bdog\b&lt;/code&gt; 来匹配时，只会匹配到第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dog&lt;/code&gt; 单词。&lt;/p&gt;
&lt;h4 id=&quot;字符串边界&quot;&gt;字符串边界&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 匹配一个字符串的开始。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 匹配一个字符串的结尾。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(?m)&lt;/code&gt; 匹配一行的开始。
    &lt;h3 id=&quot;使用子表达式&quot;&gt;使用子表达式&lt;/h3&gt;
    &lt;h3 id=&quot;回溯引用前后一致匹配&quot;&gt;回溯引用：前后一致匹配&lt;/h3&gt;
    &lt;h3 id=&quot;前后查找&quot;&gt;前后查找&lt;/h3&gt;
    &lt;h3 id=&quot;嵌入条件&quot;&gt;嵌入条件&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</guid>
        
        <category>内功</category>
        
        <category>正则表达式</category>
        
        
      </item>
    
      <item>
        <title>Processing symbol files</title>
        <description>&lt;h1 id=&quot;xcode真机调试出现-is-busy-processing-symbol-files&quot;&gt;Xcode真机调试出现“* is busy: Processing symbol files”&lt;/h1&gt;

&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;重新插拔数据线；&lt;/li&gt;
  &lt;li&gt;打开iTunes；&lt;/li&gt;
  &lt;li&gt;终极解决方案：重启手机。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 04 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/04/Xcode%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%87%BA%E7%8E%B0-is-busy-Processing-symbol-files/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/04/Xcode%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%87%BA%E7%8E%B0-is-busy-Processing-symbol-files/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>jekyll启动本地服务时报端口错误</title>
        <description>&lt;h1 id=&quot;jekyll启动本地服务时报端口错误&quot;&gt;jekyll启动本地服务时报端口错误&lt;/h1&gt;

&lt;p&gt;报错内容为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Auto-regeneration: enabled for ‘/Users/Yunis/Documents/Github/yunisSong.github.io’
Configuration file: /Users/Yunis/Documents/Github/yunisSong.github.io/_config.yml
jekyll 3.4.1 | Error:  Address already in use - bind(2) for 127.0.0.1:4000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一直本地的服务启动不起来，是端口被占用了，应该是我之前启动的jekyll 服务没有关闭，导致新服务启动不了。最终的解决方案如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/jekyll端口错误.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1,查看占用端口的进程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看占用4000端口的服务
sudo lsof -wni tcp:4000

结果如下：
COMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
ruby    15149 Yunis    8u  IPv4 0xb0723eb7e38e11c5      0t0  TCP 127.0.0.1:terabase (LISTEN)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2，杀掉占用端口的进程（sudo kill -9 PID）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo kill -9 15149
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3，再次启动 jekyll 服务正常。&lt;/p&gt;

&lt;p&gt;参考链接：https://stackoverflow.com/a/39351624/7771598&lt;/p&gt;

</description>
        <pubDate>Wed, 02 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/02/jekyll%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%97%B6%E6%8A%A5%E7%AB%AF%E5%8F%A3%E9%94%99%E8%AF%AF/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/02/jekyll%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%97%B6%E6%8A%A5%E7%AB%AF%E5%8F%A3%E9%94%99%E8%AF%AF/</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>iOS蓝牙框架的简单实用</title>
        <description>&lt;h1 id=&quot;ios蓝牙框架的简单实用&quot;&gt;iOS蓝牙框架的简单实用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreBluetooth&lt;/code&gt; 分为两种模式：&lt;/p&gt;

&lt;p&gt;1，&lt;code class=&quot;highlighter-rouge&quot;&gt;peripheral&lt;/code&gt; 外设&lt;/p&gt;

&lt;p&gt;2，&lt;code class=&quot;highlighter-rouge&quot;&gt;central&lt;/code&gt; 中心&lt;/p&gt;

&lt;h3 id=&quot;蓝牙中心模式流程&quot;&gt;蓝牙中心模式流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;建立中心角色&lt;/li&gt;
  &lt;li&gt;扫描外设（discover）&lt;/li&gt;
  &lt;li&gt;连接外设(connect)&lt;/li&gt;
  &lt;li&gt;扫描外设中的服务和特征(discover)
    &lt;ul&gt;
      &lt;li&gt;4.1 获取外设的services&lt;/li&gt;
      &lt;li&gt;4.2 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;与外设做数据交互(explore and interact)&lt;/li&gt;
  &lt;li&gt;订阅Characteristic的通知&lt;/li&gt;
  &lt;li&gt;断开连接(disconnect)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;蓝牙外设模式流程&quot;&gt;蓝牙外设模式流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;启动一个Peripheral管理对象&lt;/li&gt;
  &lt;li&gt;本地Peripheral设置服务,特性,描述，权限等等&lt;/li&gt;
  &lt;li&gt;Peripheral发送广告&lt;/li&gt;
  &lt;li&gt;设置处理订阅、取消订阅、读characteristic、写characteristic的委托方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/iOS_CoreBluetooth.png&quot; alt=&quot;思维导图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大神写的文章，写的很详细，最后提供了一个蓝牙库，封装的很简便。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/07/17/ios-BLE-1.html&quot;&gt;iOS蓝牙开发（一）蓝牙相关基础知识&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/08/14/ios-BLE-2.html&quot;&gt;ios蓝牙开发（二）ios连接外设的代码实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/09/07/ios-BLE-3.html&quot;&gt;ios蓝牙开发（三）app作为外设被连接的实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/09/11/ios-BLE-4.html&quot;&gt;ios蓝牙开发（四）BabyBluetooth蓝牙库介绍&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 01 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/01/iOS%E8%93%9D%E7%89%99%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/01/iOS%E8%93%9D%E7%89%99%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</guid>
        
        <category>蓝牙</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Head First HTML与CSS</title>
        <description>&lt;h1 id=&quot;head-first-html与css&quot;&gt;Head First HTML与CSS&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;构建网页的文件名称不要有空格
&amp;lt;a href=&quot;test.html&quot;&amp;gt;点击跳转到同级目录下test.html 文件&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;../test.html&quot;&amp;gt;点击跳转到上级目录下test.html 文件&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;Yunis/test.html&quot;&amp;gt;点击跳转到Yunis目录下test.html 文件&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;


&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;跳转到页面指定位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;index.html :
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Head First Lounge Directions&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Directions&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;




当使用

&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;index.html#jump&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;跳转&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;

会跳转到 index.html 页面 ID 为jump 的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相对路径、绝对路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;http&quot;//www.Yunis.com/demo/test/play.html&quot;&amp;gt;网页&amp;lt;/a&amp;gt;

&amp;lt;a href=&quot;demo/test/play.html&quot;&amp;gt;网页&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 元素&lt;/p&gt;

&lt;p&gt;alt&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当 图片不可显示时，显示 alt 内容
    &amp;lt;img src=&quot;images/00drinks.gif&quot; alt=&quot;这是一个备选的显示&quot;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CSS&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一个元素可以有多个规则。
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        p {
            color: maroon;
        }
    
        h1,h2 {
            font-family :sans-serif;
            color :gray;
        }
    
        h1 {
            border-bottom:1px solid black;
        }
    
    &amp;lt;/style&amp;gt;
    
    
    
    也可以这样引入 CSS 样式
 &amp;lt;link type = &quot;text/css&quot; rel = &quot;stylesheet&quot; href = &quot;lounge.css&quot;&amp;gt;


rel 属性指定了 HTML 文件和所链接的文件之间的关系。

&amp;lt;link&amp;gt; 是一个 void 元素。



可以为一个元素增加 class 属性，然后单独为这个属性的值设置样式。

&amp;lt;p class=&quot;greentea&quot;&amp;gt;
      &amp;lt;img src=&quot;../images/green.jpg&quot;&amp;gt;
      Chock full of vitamins and minerals, this elixir
      combines the healthful benefits of green tea with
      a twist of chamomile blossoms and ginger root.
    &amp;lt;/p&amp;gt;
p.greentea {
    color:green;
}

这样的话只要 class 是 greentea 这个值的话，都会设置为这个样式。
.greentea {
    color:green;
}

class 可以有多个值 使用空格分割。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;逻辑区，包围标签，相当于 一个块的概念，把里面的元素当做一个整体处理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建内联字符和元素的逻辑分组。功能等同 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 27 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/27/Head-First-HTML%E4%B8%8ECSS/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/27/Head-First-HTML%E4%B8%8ECSS/</guid>
        
        <category>前端</category>
        
        
      </item>
    
      <item>
        <title>自动化的一些实践</title>
        <description>&lt;h1 id=&quot;自动化的一些实践&quot;&gt;自动化的一些实践&lt;/h1&gt;

&lt;p&gt;今天尝试了下使用脚本自动化打包并发布到蒲公英，现记录如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
# -*- coding: utf-8 -*-
import os
import sys
import time
# 项目根目录
project_path = &quot;&quot;
#证书名称
cerName = &quot;&quot;
#工程名称
projectName = &quot;&quot;+&quot;.xcodeproj&quot;
#scheme
scheme = &quot;&quot;
#发布到蒲公英的说明文档
updateDescription = &quot;&quot;


#蒲公英Key
PGY_key=&quot;&quot;
#蒲公英APIKey
PGY_APIkey=&quot;&quot;

time = time.strftime('%Y%m%d%H%M%S',time.localtime(time.time()))
ipa_filename = time + &quot;.ipa&quot;

#activePath
activePath = &quot;&quot;+time+&quot;.xcarchive&quot;
# 打包后ipa存储目录
targerIPA_parth = &quot;&quot;

ipaName = &quot;YNGJ_HomeTest_V2.1_&quot;

# 清理项目 创建build目录
def clean_project_mkdir_build():
    print(&quot;******clean******&quot;)

    os.system('cd %s;xcodebuild clean -project &quot;%s&quot; -scheme %s -configuration release' % (project_path,projectName,scheme)) # clean 项目

def build_project():
    print(&quot;build release start&quot;)
    os.system ('xcodebuild -list')
    os.system ('cd %s;xcodebuild archive -project &quot;%s&quot; -scheme %s -configuration release -sdk iphoneos10.2  IPHONEOS_DEPLOYMENT_TARGET=8.0 -archivePath %s;' % (project_path,projectName,scheme,activePath))

# 打包ipa 并且保存在桌面
def build_ipa():
    global ipa_filename
    ipa_filename = ipaName + ipa_filename
    os.system ('xcodebuild -exportArchive -archivePath %s -exportPath %s/%s -exportFormat IPA -exportProvisioningProfile %s'%(activePath,targerIPA_parth,ipa_filename,cerName))

def ipaUpdate():

    os.system ('curl -F \&quot;updateDescription=%s\&quot; -F \&quot;file=@%s/%s\&quot; -F \&quot;uKey=%s\&quot; -F \&quot;_api_key=%s\&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload'%(updateDescription,targerIPA_parth,ipa_filename,PGY_key,PGY_APIkey))

def main():
    # 清理并创建build目录
    clean_project_mkdir_build()
    # 编译coocaPods项目文件并 执行编译目录
    build_project()
    # 打包ipa 并制定到桌面
    build_ipa()
    
    ipaUpdate()

# 执行
main()











&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 13 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/13/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/13/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5/</guid>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>基与CocosPods和SVN的一次组件化实践</title>
        <description>&lt;p&gt;TODO:如何添加到 SVN
 文件描述 与 文件层级的关系。&lt;/p&gt;
&lt;h1 id=&quot;基与cocospods和svn的一次组件化实践&quot;&gt;基与CocosPods和SVN的一次组件化实践&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;入职新公司，发现两个工程共享一套代码，每次修改一个地方，就要同步到另外一个地方去修改，有时间就会很容易遗忘修改另外一个工程。刚好之前看过一些模块化的文章，这次就尝试下，把公用的代码打成一个私有库，每次更新代码都去到私有库去更新，只需要更新一个，两个工程就都可以兼顾到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;记录下步骤：&lt;/p&gt;

&lt;h3 id=&quot;1安装-cocoapods-repo-svn-插件&quot;&gt;1,安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;cocoapods-repo-svn&lt;/code&gt; 插件&lt;/h3&gt;
&lt;p&gt;没什么好说的，就是一行命令。
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install cocoapods-repo-svn&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;2提取共有代码创建-podspec-文件&quot;&gt;2，提取共有代码，创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;podspec&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;提取两个工程中的共有代码，然后进入目录，创建&lt;code class=&quot;highlighter-rouge&quot;&gt;podspec&lt;/code&gt; 文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod spec create CommonWebTools&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CommonWebTools&lt;/code&gt; 是你提取的私有库的名称。&lt;/p&gt;

&lt;h3 id=&quot;3编辑podspec文件内容&quot;&gt;3，编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;podspec&lt;/code&gt;文件内容&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Pod::Spec.new do |s|

    s.name         = &quot;CommonWebTools&quot;

    s.version      = &quot;0.0.1&quot;

    s.summary      = &quot;提取公用代码.&quot;

    s.description  = &quot;Good&quot;

    s.homepage     = &quot;http://www.baidu.com&quot;

    s.license      = &quot;MIT&quot;

    s.author             = { &quot;iThinkerYZ&quot; =&amp;gt; &quot;xxxxxxxx@qq.com&quot; }

  s.source       = { :svn =&amp;gt; &quot;http://xxxxxx/svn/DIC-TS-eBOSS/SourceCode/50-COPMO2O/1_Develop/00-IOS/ComponentTestDemo&quot; }

 s.source_files = &quot;CommonWebTools&quot;, &quot;CommonWebTools/*.{h,m}&quot;


  end

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;多个s.source_files文件使用 ， 分割&lt;/p&gt;

&lt;h3 id=&quot;4使用&quot;&gt;4，使用：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target 'TestComponentDemo' do
pod 'CommonWebTools', :svn =&amp;gt; &quot;http://xxxxxxxx/svn/DIC-TS-eBOSS/SourceCode/50-COPMO2O/1_Develop/00-IOS/ComponentTestDemo&quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;5如何更新代码&quot;&gt;5，如何更新代码&lt;/h3&gt;

&lt;p&gt;提交代码后，
使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pod update --verbose --no-repo-update&lt;/code&gt;
即可生效。&lt;/p&gt;

</description>
        <pubDate>Wed, 12 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/12/%E5%9F%BA%E4%B8%8ECocosPods%E5%92%8CSVN%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/12/%E5%9F%BA%E4%B8%8ECocosPods%E5%92%8CSVN%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>输入框切换键盘卡顿的解决办法</title>
        <description>&lt;h1 id=&quot;输入框切换键盘卡顿的解决办法&quot;&gt;输入框切换键盘卡顿的解决办法&lt;/h1&gt;

&lt;p&gt;今天开发碰到一个问题：
有两个输入框，一个输入手机号码、一个输入验证码。
客户要求：手机号输入框输入满11位时，切换到验证码输入框。&lt;/p&gt;

&lt;p&gt;很常见的需求，也很好解决,观察输入框内容的变化，然后切换键盘响应：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //监听位数
    if (field.text.length &amp;gt;= 11) {
        dispatch_async(dispatch_get_main_queue(), ^{
            //输入框取消响应
            [field resignFirstResponder];
            //验证码输入框 响应键盘
            [self.codeField becomeFirstResponder];

        });
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很愉快的提交了代码，但是测试的小伙伴告诉我，键盘切换的时间有卡顿。？？？？一脸懵逼！！&lt;/p&gt;

&lt;p&gt;这也会卡？&lt;/p&gt;

&lt;p&gt;然后想到了是不是因为动画引起的问题？
更改如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //监听位数
    if (field.text.length &amp;gt;= 11) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView performWithoutAnimation:^{
                //输入框取消响应
                [field resignFirstResponder];
                //验证码输入框 响应键盘
                [self.codeField becomeFirstResponder];
            }];
        });
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还是不行，是在没有办法了，最后搜索到这样一个答案：
&lt;a href=&quot;https://stackoverflow.com/questions/27098097/becomefirstresponder-not-working-in-ios-8?answertab=votes#tab-top&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A responder object only becomes the first responder if the current responder can resign first-responder status (canResignFirstResponder) and the new responder can become first responder.
You may call this method to make a responder object such as a view the first responder. However, you should only call it on that view if it is part of a view hierarchy. If the view’s window property holds a UIWindow object, it has been installed in a view hierarchy; if it returns nil, the view is detached from any hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[txtAddNew performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;心想这样总可以了吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [field resignFirstResponder];
    [self.codeField performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;。。。
还是不行。。&lt;/p&gt;

&lt;p&gt;最后把    &lt;code class=&quot;highlighter-rouge&quot;&gt;[field resignFirstResponder];&lt;/code&gt; 这样代码注释掉才可以。&lt;/p&gt;

&lt;p&gt;最终版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //监听位数
    if (field.text.length &amp;gt;= 11) {
        //切换键盘响应
        //解决切换键盘卡顿
        [self.codeField performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0];
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;猜测应该是键盘所在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 切换导致的这个问题。&lt;/p&gt;

&lt;p&gt;如果先取消第一个输入框的响应，再让第二个输入框响应， 这样的话会先把当前键盘所在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 销毁，然后创建新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;，就会导致卡顿。&lt;/p&gt;

&lt;p&gt;如果不先取消第一个键盘的响应，就不会销毁 window 也不会创建新的 window ，就不会卡顿。有时间了写个 demo 验证下。&lt;/p&gt;

&lt;p&gt;好尴尬，在模拟器上测试。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-07-08 17:45:07.888 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc841cd70
2017-07-08 17:45:07.888 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc85b2630
2017-07-08 17:45:07.889 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc847e910
2017-07-08 17:45:07.889 TestBecomeFirstResponder[14397:582182] 




2017-07-08 17:45:08.973 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc841cd70
2017-07-08 17:45:08.973 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc85b2630
2017-07-08 17:45:08.974 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc847e910
2017-07-08 17:45:08.974 TestBecomeFirstResponder[14397:582182] 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;窗口都没有变化。。。这让老夫如何是好！&lt;/p&gt;

</description>
        <pubDate>Sat, 08 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/08/%E8%BE%93%E5%85%A5%E6%A1%86%E5%88%87%E6%8D%A2%E9%94%AE%E7%9B%98%E5%8D%A1%E9%A1%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/08/%E8%BE%93%E5%85%A5%E6%A1%86%E5%88%87%E6%8D%A2%E9%94%AE%E7%9B%98%E5%8D%A1%E9%A1%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Xcode断点无效的处理方式</title>
        <description>&lt;h1 id=&quot;xcode断点无效的处理方式&quot;&gt;Xcode断点无效的处理方式&lt;/h1&gt;

&lt;p&gt;原文链接&lt;a href=&quot;http://blog.csdn.net/skylin19840101/article/details/72185975&quot;&gt;xcode断点无效无法调试的一个问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某一次”svn update”后，突然发现Xcode无法断点调试了，这是什么鬼？&lt;/p&gt;

&lt;p&gt;根据大家的经验，试了各种方式&lt;/p&gt;

&lt;p&gt;1、Product-&amp;gt;Debug workflow取消选中show Disassembly when debug&lt;/p&gt;

&lt;p&gt;2、修改Generate Debug Symbols 为YES
3、Edit Scheme -&amp;gt; Run -&amp;gt; Debug executable 勾选&lt;/p&gt;

&lt;p&gt;按照上面的方法检查一遍，一切都是OK的，没啥问题，但就是无法调试.&lt;/p&gt;

&lt;p&gt;后来经过和修改Xcode工程的同事确认，原来是他们修改了一个配置参数，将”&lt;code class=&quot;highlighter-rouge&quot;&gt;Deployment Postprocessing&lt;/code&gt;“设为YES&lt;/p&gt;

&lt;p&gt;这样做的目的是减少调试信息，减少IPA体积，同时保护IPA。
所以，可以在debug下设为NO，release下设为YES&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/06/Xcode%E6%96%AD%E7%82%B9%E6%97%A0%E6%95%88%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/06/Xcode%E6%96%AD%E7%82%B9%E6%97%A0%E6%95%88%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>为什么使用weak修饰的变量会自动设置为nil</title>
        <description>&lt;h1 id=&quot;为什么使用weak修饰的变量会自动设置为nil&quot;&gt;为什么使用weak修饰的变量会自动设置为nil&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Objective-C高级编程 iOS与OS X多线程和内存管理 读书笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;为什么使用weak修饰的变量会自动设置为nil-1&quot;&gt;为什么使用weak修饰的变量会自动设置为nil&lt;/h3&gt;
&lt;p&gt;我们知道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;修饰符的变量的 引用对象 被废弃时，则将nil赋值给该变量。&lt;/li&gt;
  &lt;li&gt;使用附有 __weak 修饰符的变量，即是使用注册到 autoreleasepool 中的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;系统是如何实现的&quot;&gt;系统是如何实现的？&lt;/h3&gt;

&lt;p&gt;先看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;__weak&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经过编译器会装换为下面的代码;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    id obj1;
    objc_initWeak(&amp;amp;obj1,obj);
    objc_destroyWeak(&amp;amp;obj1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_initWeak&lt;/code&gt; 函数初始化附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量，在变量作用域结束后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_destroyWeak&lt;/code&gt; 函数释放该变量。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_initWeak&lt;/code&gt; 实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    obj1 = 0;
    objc_storeWeak(&amp;amp;obj1,obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_destroyWeak&lt;/code&gt; 实现:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    objc_storeWeak(&amp;amp;obj1,0);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以以上的代码与下面的源代码相同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    id obj1;
    obj1 = 0;
    objc_storeWeak(&amp;amp;obj1,obj);
    objc_storeWeak(&amp;amp;obj1,0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_storeWeak&lt;/code&gt; 函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量的地址注册到 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表中。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*{obj:&amp;amp;obj1} 等同 {“key”:”Value”}*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表 是作为一个散列表实现的。
当 变量 废弃时，使用该对象的地址作为键进行查找，就能快速的获取对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量的地址。另外，由于一个对象可以同时赋值给多个 附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量中，所以对于一个键，可注册多个变量的地址。&lt;/p&gt;

&lt;p&gt;释放对象时，废弃谁都不持有的对象的同时，程序的动作是怎么样的呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;objc_release&lt;/li&gt;
  &lt;li&gt;因为引用计数为0所以执行 dealloc&lt;/li&gt;
  &lt;li&gt;_onjc_rootDealloc&lt;/li&gt;
  &lt;li&gt;objc_dispose&lt;/li&gt;
  &lt;li&gt;objc_destrucInstance&lt;/li&gt;
  &lt;li&gt;objc_clear_deallocating&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对象废弃时 最后调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_clear_deallocating&lt;/code&gt; 函数动作如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表中获取废弃对象的地址为键值的记录&lt;/li&gt;
  &lt;li&gt;将包含在记录中的所有附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符变量的地址，赋值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;从 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表中删除该记录&lt;/li&gt;
  &lt;li&gt;从引用计数表中删除废弃对象的地址为键值的记录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以如果附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量 所引用的对象废弃后，将 nil 赋值给改变量的步骤是在这里实现的。&lt;/p&gt;

&lt;p&gt;由此可知，如果大量的使用附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量，会消耗对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt; 资源。良策是只在需要避免循环引用时使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符。&lt;/p&gt;

&lt;h3 id=&quot;最后总结&quot;&gt;最后总结&lt;/h3&gt;

&lt;p&gt;简单来说就是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用 __weak 修饰符的变量 A ，A 引用变量 B ，这时系统会把 B 的地址作为Key ，A的地址作为 Value ，存储在一个系统的散列表中；&lt;/li&gt;
  &lt;li&gt;当对象 B 被释放时，会先调用 release 然后引用计数为0；&lt;/li&gt;
  &lt;li&gt;然后调用 dealloc ；&lt;/li&gt;
  &lt;li&gt;接着会调用一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_clear_deallocating&lt;/code&gt;的函数，这个函数的作用就是查找以 B 的地址为 key 的 Value，然后将改这些 Value 赋值为 nil，在把这些 Key 、Value 从散列表中删除；&lt;/li&gt;
  &lt;li&gt;最后在引用计数表中将以 B 的地址为键值的记录删除。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/06/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8weak%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE%E4%B8%BAnil/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8weak%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE%E4%B8%BAnil/</guid>
        
        <category>内功</category>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
