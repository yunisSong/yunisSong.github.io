<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三十一</title>
    <description>潜心修行中。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 04 Aug 2017 08:47:48 +0800</pubDate>
    <lastBuildDate>Fri, 04 Aug 2017 08:47:48 +0800</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>Processing symbol files</title>
        <description>&lt;h1 id=&quot;xcode真机调试出现-is-busy-processing-symbol-files&quot;&gt;Xcode真机调试出现“* is busy: Processing symbol files”&lt;/h1&gt;

&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;重新插拔数据线；&lt;/li&gt;
  &lt;li&gt;打开iTunes；&lt;/li&gt;
  &lt;li&gt;终极解决方案：重启手机。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 04 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/04/Xcode%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%87%BA%E7%8E%B0-is-busy-Processing-symbol-files/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/04/Xcode%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%87%BA%E7%8E%B0-is-busy-Processing-symbol-files/</guid>
        
        
      </item>
    
      <item>
        <title>jekyll启动本地服务时报端口错误</title>
        <description>&lt;h1 id=&quot;jekyll启动本地服务时报端口错误&quot;&gt;jekyll启动本地服务时报端口错误&lt;/h1&gt;

&lt;p&gt;报错内容为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Auto-regeneration: enabled for ‘/Users/Yunis/Documents/Github/yunisSong.github.io’
Configuration file: /Users/Yunis/Documents/Github/yunisSong.github.io/_config.yml
jekyll 3.4.1 | Error:  Address already in use - bind(2) for 127.0.0.1:4000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一直本地的服务启动不起来，是端口被占用了，应该是我之前启动的jekyll 服务没有关闭，导致新服务启动不了。最终的解决方案如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/jekyll端口错误.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1,查看占用端口的进程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看占用4000端口的服务
sudo lsof -wni tcp:4000

结果如下：
COMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
ruby    15149 Yunis    8u  IPv4 0xb0723eb7e38e11c5      0t0  TCP 127.0.0.1:terabase (LISTEN)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2，杀掉占用端口的进程（sudo kill -9 PID）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo kill -9 15149
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3，再次启动 jekyll 服务正常。&lt;/p&gt;

&lt;p&gt;参考链接：https://stackoverflow.com/a/39351624/7771598&lt;/p&gt;

</description>
        <pubDate>Wed, 02 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/02/jekyll%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%97%B6%E6%8A%A5%E7%AB%AF%E5%8F%A3%E9%94%99%E8%AF%AF/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/02/jekyll%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E6%97%B6%E6%8A%A5%E7%AB%AF%E5%8F%A3%E9%94%99%E8%AF%AF/</guid>
        
        
      </item>
    
      <item>
        <title>iOS蓝牙框架的简单实用</title>
        <description>&lt;h1 id=&quot;ios蓝牙框架的简单实用&quot;&gt;iOS蓝牙框架的简单实用&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreBluetooth&lt;/code&gt; 分为两种模式：&lt;/p&gt;

&lt;p&gt;1，&lt;code class=&quot;highlighter-rouge&quot;&gt;peripheral&lt;/code&gt; 外设&lt;/p&gt;

&lt;p&gt;2，&lt;code class=&quot;highlighter-rouge&quot;&gt;central&lt;/code&gt; 中心&lt;/p&gt;

&lt;h3 id=&quot;蓝牙中心模式流程&quot;&gt;蓝牙中心模式流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;建立中心角色&lt;/li&gt;
  &lt;li&gt;扫描外设（discover）&lt;/li&gt;
  &lt;li&gt;连接外设(connect)&lt;/li&gt;
  &lt;li&gt;扫描外设中的服务和特征(discover)
    &lt;ul&gt;
      &lt;li&gt;4.1 获取外设的services&lt;/li&gt;
      &lt;li&gt;4.2 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;与外设做数据交互(explore and interact)&lt;/li&gt;
  &lt;li&gt;订阅Characteristic的通知&lt;/li&gt;
  &lt;li&gt;断开连接(disconnect)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;蓝牙外设模式流程&quot;&gt;蓝牙外设模式流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;启动一个Peripheral管理对象&lt;/li&gt;
  &lt;li&gt;本地Peripheral设置服务,特性,描述，权限等等&lt;/li&gt;
  &lt;li&gt;Peripheral发送广告&lt;/li&gt;
  &lt;li&gt;设置处理订阅、取消订阅、读characteristic、写characteristic的委托方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/iOS_CoreBluetooth.png&quot; alt=&quot;思维导图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大神写的文章，写的很详细，最后提供了一个蓝牙库，封装的很简便。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/07/17/ios-BLE-1.html&quot;&gt;iOS蓝牙开发（一）蓝牙相关基础知识&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/08/14/ios-BLE-2.html&quot;&gt;ios蓝牙开发（二）ios连接外设的代码实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/09/07/ios-BLE-3.html&quot;&gt;ios蓝牙开发（三）app作为外设被连接的实现&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuyanwei.jumppo.com/2015/09/11/ios-BLE-4.html&quot;&gt;ios蓝牙开发（四）BabyBluetooth蓝牙库介绍&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 01 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/01/iOS%E8%93%9D%E7%89%99%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/01/iOS%E8%93%9D%E7%89%99%E6%A1%86%E6%9E%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</guid>
        
        <category>蓝牙</category>
        
        
      </item>
    
      <item>
        <title>Head First HTML与CSS</title>
        <description>&lt;h1 id=&quot;head-first-html与css&quot;&gt;Head First HTML与CSS&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;构建网页的文件名称不要有空格
&amp;lt;a href=&quot;test.html&quot;&amp;gt;点击跳转到同级目录下test.html 文件&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;../test.html&quot;&amp;gt;点击跳转到上级目录下test.html 文件&amp;lt;/a&amp;gt;
&amp;lt;a href=&quot;Yunis/test.html&quot;&amp;gt;点击跳转到Yunis目录下test.html 文件&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;


&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;....&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;跳转到页面指定位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;index.html :
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Head First Lounge Directions&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Directions&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;




当使用

&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;index.html#jump&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;跳转&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;

会跳转到 index.html 页面 ID 为jump 的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相对路径、绝对路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;http&quot;//www.Yunis.com/demo/test/play.html&quot;&amp;gt;网页&amp;lt;/a&amp;gt;

&amp;lt;a href=&quot;demo/test/play.html&quot;&amp;gt;网页&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 元素&lt;/p&gt;

&lt;p&gt;alt&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当 图片不可显示时，显示 alt 内容
    &amp;lt;img src=&quot;images/00drinks.gif&quot; alt=&quot;这是一个备选的显示&quot;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CSS&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一个元素可以有多个规则。
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        p {
            color: maroon;
        }
    
        h1,h2 {
            font-family :sans-serif;
            color :gray;
        }
    
        h1 {
            border-bottom:1px solid black;
        }
    
    &amp;lt;/style&amp;gt;
    
    
    
    也可以这样引入 CSS 样式
 &amp;lt;link type = &quot;text/css&quot; rel = &quot;stylesheet&quot; href = &quot;lounge.css&quot;&amp;gt;


rel 属性指定了 HTML 文件和所链接的文件之间的关系。

&amp;lt;link&amp;gt; 是一个 void 元素。



可以为一个元素增加 class 属性，然后单独为这个属性的值设置样式。

&amp;lt;p class=&quot;greentea&quot;&amp;gt;
      &amp;lt;img src=&quot;../images/green.jpg&quot;&amp;gt;
      Chock full of vitamins and minerals, this elixir
      combines the healthful benefits of green tea with
      a twist of chamomile blossoms and ginger root.
    &amp;lt;/p&amp;gt;
p.greentea {
    color:green;
}

这样的话只要 class 是 greentea 这个值的话，都会设置为这个样式。
.greentea {
    color:green;
}

class 可以有多个值 使用空格分割。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;逻辑区，包围标签，相当于 一个块的概念，把里面的元素当做一个整体处理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建内联字符和元素的逻辑分组。功能等同 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 27 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/27/Head-First-HTML%E4%B8%8ECSS/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/27/Head-First-HTML%E4%B8%8ECSS/</guid>
        
        
      </item>
    
      <item>
        <title>自动化的一些实践</title>
        <description>&lt;h1 id=&quot;自动化的一些实践&quot;&gt;自动化的一些实践&lt;/h1&gt;

&lt;p&gt;今天尝试了下使用脚本自动化打包并发布到蒲公英，现记录如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
# -*- coding: utf-8 -*-
import os
import sys
import time
# 项目根目录
project_path = &quot;&quot;
#证书名称
cerName = &quot;&quot;
#工程名称
projectName = &quot;&quot;+&quot;.xcodeproj&quot;
#scheme
scheme = &quot;&quot;
#发布到蒲公英的说明文档
updateDescription = &quot;&quot;


#蒲公英Key
PGY_key=&quot;&quot;
#蒲公英APIKey
PGY_APIkey=&quot;&quot;

time = time.strftime('%Y%m%d%H%M%S',time.localtime(time.time()))
ipa_filename = time + &quot;.ipa&quot;

#activePath
activePath = &quot;&quot;+time+&quot;.xcarchive&quot;
# 打包后ipa存储目录
targerIPA_parth = &quot;&quot;

ipaName = &quot;YNGJ_HomeTest_V2.1_&quot;

# 清理项目 创建build目录
def clean_project_mkdir_build():
    print(&quot;******clean******&quot;)

    os.system('cd %s;xcodebuild clean -project &quot;%s&quot; -scheme %s -configuration release' % (project_path,projectName,scheme)) # clean 项目

def build_project():
    print(&quot;build release start&quot;)
    os.system ('xcodebuild -list')
    os.system ('cd %s;xcodebuild archive -project &quot;%s&quot; -scheme %s -configuration release -sdk iphoneos10.2  IPHONEOS_DEPLOYMENT_TARGET=8.0 -archivePath %s;' % (project_path,projectName,scheme,activePath))

# 打包ipa 并且保存在桌面
def build_ipa():
    global ipa_filename
    ipa_filename = ipaName + ipa_filename
    os.system ('xcodebuild -exportArchive -archivePath %s -exportPath %s/%s -exportFormat IPA -exportProvisioningProfile %s'%(activePath,targerIPA_parth,ipa_filename,cerName))

def ipaUpdate():

    os.system ('curl -F \&quot;updateDescription=%s\&quot; -F \&quot;file=@%s/%s\&quot; -F \&quot;uKey=%s\&quot; -F \&quot;_api_key=%s\&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload'%(updateDescription,targerIPA_parth,ipa_filename,PGY_key,PGY_APIkey))

def main():
    # 清理并创建build目录
    clean_project_mkdir_build()
    # 编译coocaPods项目文件并 执行编译目录
    build_project()
    # 打包ipa 并制定到桌面
    build_ipa()
    
    ipaUpdate()

# 执行
main()











&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 13 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/13/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/13/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5/</guid>
        
        
      </item>
    
      <item>
        <title>基与CocosPods和SVN的一次组件化实践</title>
        <description>&lt;p&gt;TODO:如何添加到 SVN
 文件描述 与 文件层级的关系。&lt;/p&gt;
&lt;h1 id=&quot;基与cocospods和svn的一次组件化实践&quot;&gt;基与CocosPods和SVN的一次组件化实践&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;入职新公司，发现两个工程共享一套代码，每次修改一个地方，就要同步到另外一个地方去修改，有时间就会很容易遗忘修改另外一个工程。刚好之前看过一些模块化的文章，这次就尝试下，把公用的代码打成一个私有库，每次更新代码都去到私有库去更新，只需要更新一个，两个工程就都可以兼顾到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;记录下步骤：&lt;/p&gt;

&lt;h3 id=&quot;1安装-cocoapods-repo-svn-插件&quot;&gt;1,安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;cocoapods-repo-svn&lt;/code&gt; 插件&lt;/h3&gt;
&lt;p&gt;没什么好说的，就是一行命令。
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install cocoapods-repo-svn&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;2提取共有代码创建-podspec-文件&quot;&gt;2，提取共有代码，创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;podspec&lt;/code&gt; 文件&lt;/h3&gt;
&lt;p&gt;提取两个工程中的共有代码，然后进入目录，创建&lt;code class=&quot;highlighter-rouge&quot;&gt;podspec&lt;/code&gt; 文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pod spec create CommonWebTools&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CommonWebTools&lt;/code&gt; 是你提取的私有库的名称。&lt;/p&gt;

&lt;h3 id=&quot;3编辑podspec文件内容&quot;&gt;3，编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;podspec&lt;/code&gt;文件内容&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
Pod::Spec.new do |s|

    s.name         = &quot;CommonWebTools&quot;

    s.version      = &quot;0.0.1&quot;

    s.summary      = &quot;提取公用代码.&quot;

    s.description  = &quot;Good&quot;

    s.homepage     = &quot;http://www.baidu.com&quot;

    s.license      = &quot;MIT&quot;

    s.author             = { &quot;iThinkerYZ&quot; =&amp;gt; &quot;xxxxxxxx@qq.com&quot; }

  s.source       = { :svn =&amp;gt; &quot;http://xxxxxx/svn/DIC-TS-eBOSS/SourceCode/50-COPMO2O/1_Develop/00-IOS/ComponentTestDemo&quot; }

 s.source_files = &quot;CommonWebTools&quot;, &quot;CommonWebTools/*.{h,m}&quot;


  end

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;多个s.source_files文件使用 ， 分割&lt;/p&gt;

&lt;h3 id=&quot;4使用&quot;&gt;4，使用：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target 'TestComponentDemo' do
pod 'CommonWebTools', :svn =&amp;gt; &quot;http://xxxxxxxx/svn/DIC-TS-eBOSS/SourceCode/50-COPMO2O/1_Develop/00-IOS/ComponentTestDemo&quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;5如何更新代码&quot;&gt;5，如何更新代码&lt;/h3&gt;

&lt;p&gt;提交代码后，
使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pod update --verbose --no-repo-update&lt;/code&gt;
即可生效。&lt;/p&gt;

</description>
        <pubDate>Wed, 12 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/12/%E5%9F%BA%E4%B8%8ECocosPods%E5%92%8CSVN%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/12/%E5%9F%BA%E4%B8%8ECocosPods%E5%92%8CSVN%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/</guid>
        
        
      </item>
    
      <item>
        <title>输入框切换键盘卡顿的解决办法</title>
        <description>&lt;h1 id=&quot;输入框切换键盘卡顿的解决办法&quot;&gt;输入框切换键盘卡顿的解决办法&lt;/h1&gt;

&lt;p&gt;今天开发碰到一个问题：
有两个输入框，一个输入手机号码、一个输入验证码。
客户要求：手机号输入框输入满11位时，切换到验证码输入框。&lt;/p&gt;

&lt;p&gt;很常见的需求，也很好解决,观察输入框内容的变化，然后切换键盘响应：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //监听位数
    if (field.text.length &amp;gt;= 11) {
        dispatch_async(dispatch_get_main_queue(), ^{
            //输入框取消响应
            [field resignFirstResponder];
            //验证码输入框 响应键盘
            [self.codeField becomeFirstResponder];

        });
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很愉快的提交了代码，但是测试的小伙伴告诉我，键盘切换的时间有卡顿。？？？？一脸懵逼！！&lt;/p&gt;

&lt;p&gt;这也会卡？&lt;/p&gt;

&lt;p&gt;然后想到了是不是因为动画引起的问题？
更改如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //监听位数
    if (field.text.length &amp;gt;= 11) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [UIView performWithoutAnimation:^{
                //输入框取消响应
                [field resignFirstResponder];
                //验证码输入框 响应键盘
                [self.codeField becomeFirstResponder];
            }];
        });
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还是不行，是在没有办法了，最后搜索到这样一个答案：
&lt;a href=&quot;https://stackoverflow.com/questions/27098097/becomefirstresponder-not-working-in-ios-8?answertab=votes#tab-top&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A responder object only becomes the first responder if the current responder can resign first-responder status (canResignFirstResponder) and the new responder can become first responder.
You may call this method to make a responder object such as a view the first responder. However, you should only call it on that view if it is part of a view hierarchy. If the view’s window property holds a UIWindow object, it has been installed in a view hierarchy; if it returns nil, the view is detached from any hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[txtAddNew performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;心想这样总可以了吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [field resignFirstResponder];
    [self.codeField performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;。。。
还是不行。。&lt;/p&gt;

&lt;p&gt;最后把    &lt;code class=&quot;highlighter-rouge&quot;&gt;[field resignFirstResponder];&lt;/code&gt; 这样代码注释掉才可以。&lt;/p&gt;

&lt;p&gt;最终版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //监听位数
    if (field.text.length &amp;gt;= 11) {
        //切换键盘响应
        //解决切换键盘卡顿
        [self.codeField performSelector:@selector(becomeFirstResponder) withObject:nil afterDelay:0];
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;猜测应该是键盘所在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 切换导致的这个问题。&lt;/p&gt;

&lt;p&gt;如果先取消第一个输入框的响应，再让第二个输入框响应， 这样的话会先把当前键盘所在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 销毁，然后创建新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;，就会导致卡顿。&lt;/p&gt;

&lt;p&gt;如果不先取消第一个键盘的响应，就不会销毁 window 也不会创建新的 window ，就不会卡顿。有时间了写个 demo 验证下。&lt;/p&gt;

&lt;p&gt;好尴尬，在模拟器上测试。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2017-07-08 17:45:07.888 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc841cd70
2017-07-08 17:45:07.888 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc85b2630
2017-07-08 17:45:07.889 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc847e910
2017-07-08 17:45:07.889 TestBecomeFirstResponder[14397:582182] 




2017-07-08 17:45:08.973 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc841cd70
2017-07-08 17:45:08.973 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc85b2630
2017-07-08 17:45:08.974 TestBecomeFirstResponder[14397:582182] 窗口 = 0x7f8cc847e910
2017-07-08 17:45:08.974 TestBecomeFirstResponder[14397:582182] 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;窗口都没有变化。。。这让老夫如何是好！&lt;/p&gt;

</description>
        <pubDate>Sat, 08 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/08/%E8%BE%93%E5%85%A5%E6%A1%86%E5%88%87%E6%8D%A2%E9%94%AE%E7%9B%98%E5%8D%A1%E9%A1%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/08/%E8%BE%93%E5%85%A5%E6%A1%86%E5%88%87%E6%8D%A2%E9%94%AE%E7%9B%98%E5%8D%A1%E9%A1%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Xcode断点无效的处理方式</title>
        <description>&lt;h1 id=&quot;xcode断点无效的处理方式&quot;&gt;Xcode断点无效的处理方式&lt;/h1&gt;

&lt;p&gt;原文链接&lt;a href=&quot;http://blog.csdn.net/skylin19840101/article/details/72185975&quot;&gt;xcode断点无效无法调试的一个问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某一次”svn update”后，突然发现Xcode无法断点调试了，这是什么鬼？&lt;/p&gt;

&lt;p&gt;根据大家的经验，试了各种方式&lt;/p&gt;

&lt;p&gt;1、Product-&amp;gt;Debug workflow取消选中show Disassembly when debug&lt;/p&gt;

&lt;p&gt;2、修改Generate Debug Symbols 为YES
3、Edit Scheme -&amp;gt; Run -&amp;gt; Debug executable 勾选&lt;/p&gt;

&lt;p&gt;按照上面的方法检查一遍，一切都是OK的，没啥问题，但就是无法调试.&lt;/p&gt;

&lt;p&gt;后来经过和修改Xcode工程的同事确认，原来是他们修改了一个配置参数，将”&lt;code class=&quot;highlighter-rouge&quot;&gt;Deployment Postprocessing&lt;/code&gt;“设为YES&lt;/p&gt;

&lt;p&gt;这样做的目的是减少调试信息，减少IPA体积，同时保护IPA。
所以，可以在debug下设为NO，release下设为YES&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/06/Xcode%E6%96%AD%E7%82%B9%E6%97%A0%E6%95%88%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/06/Xcode%E6%96%AD%E7%82%B9%E6%97%A0%E6%95%88%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
        
        <category>Xcode</category>
        
        
      </item>
    
      <item>
        <title>为什么使用weak修饰的变量会自动设置为nil</title>
        <description>&lt;h1 id=&quot;为什么使用weak修饰的变量会自动设置为nil&quot;&gt;为什么使用weak修饰的变量会自动设置为nil&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Objective-C高级编程 iOS与OS X多线程和内存管理 读书笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;为什么使用weak修饰的变量会自动设置为nil-1&quot;&gt;为什么使用weak修饰的变量会自动设置为nil&lt;/h3&gt;
&lt;p&gt;我们知道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;修饰符的变量的 引用对象 被废弃时，则将nil赋值给该变量。&lt;/li&gt;
  &lt;li&gt;使用附有 __weak 修饰符的变量，即是使用注册到 autoreleasepool 中的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;系统是如何实现的&quot;&gt;系统是如何实现的？&lt;/h3&gt;

&lt;p&gt;先看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;__weak&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;obj;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经过编译器会装换为下面的代码;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    id obj1;
    objc_initWeak(&amp;amp;obj1,obj);
    objc_destroyWeak(&amp;amp;obj1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_initWeak&lt;/code&gt; 函数初始化附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量，在变量作用域结束后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_destroyWeak&lt;/code&gt; 函数释放该变量。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_initWeak&lt;/code&gt; 实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    obj1 = 0;
    objc_storeWeak(&amp;amp;obj1,obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_destroyWeak&lt;/code&gt; 实现:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    objc_storeWeak(&amp;amp;obj1,0);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以以上的代码与下面的源代码相同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    id obj1;
    obj1 = 0;
    objc_storeWeak(&amp;amp;obj1,obj);
    objc_storeWeak(&amp;amp;obj1,0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_storeWeak&lt;/code&gt; 函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量的地址注册到 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表中。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*{obj:&amp;amp;obj1} 等同 {“key”:”Value”}*&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表 是作为一个散列表实现的。
当 变量 废弃时，使用该对象的地址作为键进行查找，就能快速的获取对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量的地址。另外，由于一个对象可以同时赋值给多个 附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量中，所以对于一个键，可注册多个变量的地址。&lt;/p&gt;

&lt;p&gt;释放对象时，废弃谁都不持有的对象的同时，程序的动作是怎么样的呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;objc_release&lt;/li&gt;
  &lt;li&gt;因为引用计数为0所以执行 dealloc&lt;/li&gt;
  &lt;li&gt;_onjc_rootDealloc&lt;/li&gt;
  &lt;li&gt;objc_dispose&lt;/li&gt;
  &lt;li&gt;objc_destrucInstance&lt;/li&gt;
  &lt;li&gt;objc_clear_deallocating&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对象废弃时 最后调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_clear_deallocating&lt;/code&gt; 函数动作如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表中获取废弃对象的地址为键值的记录&lt;/li&gt;
  &lt;li&gt;将包含在记录中的所有附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符变量的地址，赋值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;从 &lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt; 表中删除该记录&lt;/li&gt;
  &lt;li&gt;从引用计数表中删除废弃对象的地址为键值的记录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以如果附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量 所引用的对象废弃后，将 nil 赋值给改变量的步骤是在这里实现的。&lt;/p&gt;

&lt;p&gt;由此可知，如果大量的使用附有 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符的变量，会消耗对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt; 资源。良策是只在需要避免循环引用时使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt; 修饰符。&lt;/p&gt;

&lt;h3 id=&quot;最后总结&quot;&gt;最后总结&lt;/h3&gt;

&lt;p&gt;简单来说就是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用 __weak 修饰符的变量 A ，A 引用变量 B ，这时系统会把 B 的地址作为Key ，A的地址作为 Value ，存储在一个系统的散列表中；&lt;/li&gt;
  &lt;li&gt;当对象 B 被释放时，会先调用 release 然后引用计数为0；&lt;/li&gt;
  &lt;li&gt;然后调用 dealloc ；&lt;/li&gt;
  &lt;li&gt;接着会调用一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_clear_deallocating&lt;/code&gt;的函数，这个函数的作用就是查找以 B 的地址为 key 的 Value，然后将改这些 Value 赋值为 nil，在把这些 Key 、Value 从散列表中删除；&lt;/li&gt;
  &lt;li&gt;最后在引用计数表中将以 B 的地址为键值的记录删除。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/06/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8weak%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE%E4%B8%BAnil/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8weak%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE%E4%B8%BAnil/</guid>
        
        <category>weak</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>(美团)深入理解Objective-C：Category</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;美团深入理解objective-ccategory&quot;&gt;(美团)深入理解Objective-C：Category&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文地址：&lt;a href=&quot;http://tech.meituan.com/DiveIntoCategory.html&quot;&gt;深入理解Objective-C：Category&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;category-的其他使用场景&quot;&gt;Category 的其他使用场景&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处:
    &lt;ol&gt;
      &lt;li&gt;可以减少单个文件的体积&lt;/li&gt;
      &lt;li&gt;可以把不同的功能组织到不同的 category 里&lt;/li&gt;
      &lt;li&gt;可以由多个开发者共同完成一个类&lt;/li&gt;
      &lt;li&gt;可以按需加载想要的 category 等等。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;声明私有方法&lt;/li&gt;
  &lt;li&gt;模拟多继承&lt;/li&gt;
  &lt;li&gt;把 framework 的私有方法公开&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;category-和-extension&quot;&gt;Category 和 Extension&lt;/h3&gt;

&lt;h4 id=&quot;extension&quot;&gt;Extension&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;extension 看起来很像一个匿名的category，但是 extension 和有名字的 category 几乎完全是两个东西。  extension 在编译期决议，它就是类的一部分，在编译期和头文件里的 @interface 以及实现文件里的 @implement 一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。 extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension ，所以你无法为系统的类比如 NSString 添加 extension。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;category&quot;&gt;category&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;但是category则完全不一样，它是在运行期决议的。
就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更直观的表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Extension&amp;amp;Category/Extension&amp;amp;Category.png&quot; alt=&quot;ScopeChain&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/06/05/(%E7%BE%8E%E5%9B%A2)%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Objective-C-Category/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/05/(%E7%BE%8E%E5%9B%A2)%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Objective-C-Category/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
