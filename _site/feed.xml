<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三十一</title>
    <description>潜心修行中。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 11 Jan 2018 09:35:51 +0800</pubDate>
    <lastBuildDate>Thu, 11 Jan 2018 09:35:51 +0800</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>使用脚本统计SVN代码修改数</title>
        <description>&lt;h1 id=&quot;使用脚本统计svn代码修改数&quot;&gt;使用脚本统计SVN代码修改数&lt;/h1&gt;

&lt;p&gt;今天老大让统计自己这一段写的代码量，之前因为是写的新功能，所有的文件都是新增的比较好统计，使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;cloc&lt;/code&gt; 来统计了代码的总量，最近的修改都是修补一些bug，没怎么大模块的提交代码，都是小小的修修补补，不可能每一次提交都去看下修改的代码行数的，作为一个程序员，还是习惯性的在网上看看前辈们是怎么统计代码的，最后找到了一个工具来统计自己修改的代码数量。脚本如下：
原脚本地址：&lt;a href=&quot;http://blog.csdn.net/kittyboy0001/article/details/24362045&quot;&gt;使用svn命令统计两次上线之间的代码行数，以及不同作者的代码行数&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 计算有效变更代码量的脚本&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 包括注释，但不包括新增的空行&lt;/span&gt;
version&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;uname -o&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;svn_counter (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;) 0.0.1&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


usage&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;usage: svn_counter [-t SVN_REPOSITORY_URL] [-s START_REVISION]&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;                      [-e END_REVISION] [-u USER_NAME]&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;                      [-p PASSWD]&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;       svn_counter [-v|-h]&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo
    echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -t,                 目标SVN库地址&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -s,                 起始修订号&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -e,                 结束修订号&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -a,                 提交作者&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -u,                 svn帐号&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -p,                 svn密码&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -h,                 帮助&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;        -v,                 版本信息&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$# &lt;/span&gt;-lt 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;usage
    &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;1
&lt;span class=&quot;k&quot;&gt;fi


while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;getopts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;t:s:e:a:u:p:vh&quot;&lt;/span&gt; opt; &lt;span class=&quot;k&quot;&gt;do
    case&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$opt&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in
        &lt;/span&gt;t&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OPTARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
        s&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;start_revision&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OPTARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
        e&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;end_revision&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OPTARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
        a&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OPTARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
        u&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OPTARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
        p&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;passwd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$OPTARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
        v&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; version; &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;1;;
        h&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; usage; &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;1;;
    &lt;span class=&quot;k&quot;&gt;esac
done


if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -z &lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;请输入目标SVN库地址!&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;1
&lt;span class=&quot;k&quot;&gt;fi


if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -z &lt;span class=&quot;nv&quot;&gt;$start_revision&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;请输入起始修订号!&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;1
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;




&lt;span class=&quot;c&quot;&gt;#SVN_CMD='/home/work/local/svn/bin/svn'&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SVN_CMD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'svn'&lt;/span&gt;


&lt;span class=&quot;nv&quot;&gt;TEMPFILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;temp_diff.log
&lt;span class=&quot;nv&quot;&gt;USERNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;PASSWD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;passwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;TOTAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -z &lt;span class=&quot;nv&quot;&gt;$author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;then
    if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -z &lt;span class=&quot;nv&quot;&gt;$end_revision&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SVN_CMD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; diff -r&lt;span class=&quot;nv&quot;&gt;$start_revision&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt; --username &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; --password &lt;span class=&quot;nv&quot;&gt;$PASSWD&lt;/span&gt; &amp;gt; &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SVN_CMD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; diff -r&lt;span class=&quot;nv&quot;&gt;$start_revision&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$end_revision&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt; --username &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; --password &lt;span class=&quot;nv&quot;&gt;$PASSWD&lt;/span&gt; &amp;gt; &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;


    &lt;span class=&quot;c&quot;&gt;#去掉含空格的空行&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;TOTAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;grep &lt;span class=&quot;s2&quot;&gt;&quot;^+&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt; | grep -v &lt;span class=&quot;s2&quot;&gt;&quot;^+++&quot;&lt;/span&gt; | sed &lt;span class=&quot;s1&quot;&gt;'s/^.//'&lt;/span&gt;| sed s/[[:space:]]//g |sed &lt;span class=&quot;s1&quot;&gt;'/^$/d'&lt;/span&gt;|wc -l&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#没有去掉有的空行&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#TOTAL=`grep &quot;^+&quot; $TEMPFILE|grep -v &quot;^+++&quot;|sed 's/^.//'|sed '/^$/d'|wc -l`&lt;/span&gt;

    rm -fr &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TOTAL&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else
    if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -z &lt;span class=&quot;nv&quot;&gt;$end_revision&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;; &lt;span class=&quot;k&quot;&gt;then
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;revs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SVN_CMD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; log -q &lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt;  -r &lt;span class=&quot;nv&quot;&gt;$start_revision&lt;/span&gt;:HEAD --username &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; --password &lt;span class=&quot;nv&quot;&gt;$PASSWD&lt;/span&gt; |awk &lt;span class=&quot;s1&quot;&gt;'{print \$1,\$3}'&lt;/span&gt;| grep  &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;| awk &lt;span class=&quot;s1&quot;&gt;'{print \$1}'&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;revs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SVN_CMD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; log -q &lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt;  -r &lt;span class=&quot;nv&quot;&gt;$start_revision&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$end_revision&lt;/span&gt; --username &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; --password &lt;span class=&quot;nv&quot;&gt;$PASSWD&lt;/span&gt; |awk &lt;span class=&quot;s1&quot;&gt;'{print \$1,\$3}'&lt;/span&gt;| grep  &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;| awk &lt;span class=&quot;s1&quot;&gt;'{print \$1}'&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi
    for &lt;/span&gt;rev &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;revs&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;;&lt;span class=&quot;k&quot;&gt;do
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rev&lt;/span&gt;:1&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;last_rev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;rev-1&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;


        &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SVN_CMD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; diff -r&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;last_rev&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;:&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt; --username &lt;span class=&quot;nv&quot;&gt;$USERNAME&lt;/span&gt; --password &lt;span class=&quot;nv&quot;&gt;$PASSWD&lt;/span&gt;  &amp;gt; &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;grep &lt;span class=&quot;s2&quot;&gt;&quot;^+&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt; | grep -v &lt;span class=&quot;s2&quot;&gt;&quot;^+++&quot;&lt;/span&gt; | sed &lt;span class=&quot;s1&quot;&gt;'s/^.//'&lt;/span&gt;| sed s/[[:space:]]//g |sed &lt;span class=&quot;s1&quot;&gt;'/^$/d'&lt;/span&gt;|wc -l&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;TOTAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;TOTAL+count&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
        rm -rf &lt;span class=&quot;nv&quot;&gt;$TEMPFILE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;done
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TOTAL&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;试用了一下，使用就比较简单了，统计的也比较准，记录下如何使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sh countCode.sh -t 要统计的代码SVN地址 -s 起始版本号 -e 结束版本号 -a 要统计那个用户的代码量 -u 用户名 -p 密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;countCode.sh&lt;/code&gt; 为保存上面那段代码的文件名称。&lt;/p&gt;

</description>
        <pubDate>Tue, 09 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/09/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E7%BB%9F%E8%AE%A1SVN%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/09/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E7%BB%9F%E8%AE%A1SVN%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%95%B0/</guid>
        
        <category>Shell</category>
        
        
      </item>
    
      <item>
        <title>Python编程快速上手 — 让繁琐工作自动化&lt;三&gt;</title>
        <description>&lt;h1 id=&quot;python编程快速上手--让繁琐工作自动化&quot;&gt;Python编程快速上手 — 让繁琐工作自动化&lt;三&gt;&lt;/三&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pillow&lt;/code&gt; 是一个第三方 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 模块，用于 处理图像文件。该模块包含一些函数，可以很容易地裁剪图像、调整图像大小，
以及编辑图像的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;获取颜色值&quot;&gt;获取颜色值&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from PIL import ImageColor
ImageColor.getcolor('red', 'RGBA')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;用-pillow-操作图像&quot;&gt;用 Pillow 操作图像&lt;/h3&gt;

&lt;p&gt;加载一张图片到 Python 环境中
&lt;img src=&quot;/media/15152393132842/zophie.png&quot; alt=&quot;zophie&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from PIL import Image
catIm = Image.open('zophie.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;catIm.size&lt;/code&gt; 获取图片尺寸
&lt;code class=&quot;highlighter-rouge&quot;&gt;width, height = catIm.size&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;catIm.filename&lt;/code&gt; 图片在本地的名称
&lt;code class=&quot;highlighter-rouge&quot;&gt;catIm.format&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;catIm.format_description&lt;/code&gt; 是获取图片格式的字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;'PNG' 'Portable network graphics'&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;format_description&lt;/code&gt; 比较详细。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;im = Image.new(&quot;RGBA&quot;,(100,200),&quot;purple&quot;)&lt;/code&gt; 创建一个尺寸为 100*200、背景色为 purple 的图片。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;im2 = Image.new('RGBA', (20, 20))&lt;/code&gt; 创建一个尺寸为 20*20、背景透明 的图片。&lt;/p&gt;

&lt;h4 id=&quot;裁剪图片&quot;&gt;裁剪图片&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;croppedIm = catIm.crop((335, 345, 565, 560))
croppedIm.save('cropped.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/media/15152393132842/cropped.png&quot; alt=&quot;cropped&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 对 象的 crop()方法接受一个矩形元组，返回一个 Image 对象，表示裁剪后的图像。裁剪 不是在原图上发生的，也就是说，原始的 Image 对象原封不动，crop()方法返回一 个新的 Image 对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//读取本地图片建立一个 Image对象
catIm = Image.open('zophie.png')
//拷贝一份
catCopyIm = catIm.copy()
//剪裁出一份
faceIm = catIm.crop((335, 345, 565, 560))
//把剪裁出来的图片粘贴到拷贝出来的图片上，位置为（0，0）
catCopyIm.paste(faceIm, (0, 0))
//保存图片
catCopyIm.save('pasted.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/media/15152393132842/pasted.png&quot; alt=&quot;pasted&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;平铺图片&quot;&gt;平铺图片&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
 catImWidth, catImHeight = catIm.size
 faceImWidth, faceImHeight = faceIm.size
 catCopyTwo = catIm.copy()
//平铺
//0, catImWidth 范围内，faceImWidth为步长
 for left in range(0, catImWidth, faceImWidth):
    for top in range(0, catImHeight, faceImHeight):
        print(left, top)
        catCopyTwo.paste(faceIm, (left, top))
        
 catCopyTwo.save('tiled.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/media/15152393132842/tiled.png&quot; alt=&quot;tiled&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;调整图片大小&quot;&gt;调整图片大小&lt;/h4&gt;

&lt;p&gt;resize()方法在 Image 对象上调用，返回指定宽度和高度的一个新 Image 对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;width, height = catIm.size
quartersizedIm = catIm.resize((int(width / 2), int(height / 2)))
quartersizedIm.save('quartersized.png')
svelteIm = catIm.resize((width, height + 300))
svelteIm.save('svelte.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/media/15152393132842/quartersized.png&quot; alt=&quot;quartersized&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;旋转图片&quot;&gt;旋转图片&lt;/h4&gt;

&lt;p&gt;图像可以用 rotate()方法旋转，该方法返回旋转后的新 Image 对象，并保持原始 Image 对象不变。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;catIm.rotate(90).save('rotated90.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/media/15152393132842/rotated90.png&quot; alt=&quot;rotated90&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意，当图像旋转 90 度或 270 度时，宽度和高度会变化。如果旋转其他角度， 图像的原始尺寸会保持。在 Windows 上，使用黑色的背景来填补旋转造成的缝隙， 如图 17-8 所示。在 OS X 上，使用透明的像素来填补缝隙。rotate()方法有一个可选 的 expand 关键字参数，如果设置为 True，就会放大图像的尺寸，以适应整个旋转 后的新图像。&lt;/p&gt;

&lt;p&gt;利用 transpose()方法，还可以得到图像的“镜像翻转”。必须向 transpose()方法 传入 Image.FLIP_LEFT_RIGHT 或 Image.FLIP_TOP_BOTTOM。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;catIm.transpose(Image.FLIP_LEFT_RIGHT).save('horizontal_flip.png')
catIm.transpose(Image.FLIP_TOP_BOTTOM).save('vertical_flip.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/media/15152393132842/horizontal_flip.png&quot; alt=&quot;horizontal_flip&quot; /&gt;&lt;img src=&quot;/media/15152393132842/vertical_flip.png&quot; alt=&quot;vertical_flip&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;更改单个像素&quot;&gt;更改单个像素&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//创建一个透明图片 大小为 100 *100
im = Image.new('RGBA', (100, 100))

//填充颜色 为x轴  0 - 99 y轴 0-49
for x in range(100):
    for y in range(50):
        im.putpixel((x, y), (210, 210, 210))

//填充颜色 为x轴  0 - 99 y轴 50-99
for x in range(100):
    for y in range(50, 100):
        im.putpixel((x, y), ImageColor.getcolor('darkgray', 'RGBA'))

im.save('putPixel.png')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/media/15152393132842/putPixel.png&quot; alt=&quot;putPixe&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/06/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%B8%89/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/06/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%B8%89/</guid>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>Excel 技巧</title>
        <description>&lt;h1 id=&quot;excel-技巧&quot;&gt;Excel 技巧&lt;/h1&gt;

&lt;h3 id=&quot;不同的文字等于不同的数值&quot;&gt;不同的文字等于不同的数值&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IF(B4=&quot;跑步&quot;,1,IF(B4=&quot;打球&quot;,1,IF(B4=&quot;休息&quot;,0,&quot;&quot;)))&lt;/code&gt;
上面这句话的意思是，如果 单元格 B4 的文字是 跑步 或者 打球，值就是1，休息值是0
&lt;code class=&quot;highlighter-rouge&quot;&gt;COUNTIF(C4,&quot;*页*&quot;)&lt;/code&gt;
上面这句话的意思是，如果文字中包含页，条件为真。值为1，其他情况条件为假，值为0&lt;/p&gt;

&lt;h3 id=&quot;为不同的文字配置不同的颜色&quot;&gt;为不同的文字配置不同的颜色&lt;/h3&gt;

&lt;p&gt;选择条件格式，
&lt;img src=&quot;/media/15150510388028/15150513177157.jpg&quot; alt=&quot;&quot; /&gt;
然后选择突出显示单元格规则，
&lt;img src=&quot;/media/15150510388028/15150512941005.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后选择文本包含。。。
写入希望那些文本变为什么颜色，这个时候点击确定，跑步就变成黄色了。
&lt;img src=&quot;/media/15150510388028/15150514775612.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;为不同的数值配置不同的颜色&quot;&gt;为不同的数值配置不同的颜色&lt;/h3&gt;

&lt;p&gt;选中单元格
然后，开始 - 条件选择
&lt;img src=&quot;/media/15150510388028/15150515834148.jpg&quot; alt=&quot;&quot; /&gt;
选择新建规则
&lt;img src=&quot;/media/15150510388028/15150516051464.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择三色阶，确定，这个时候 0 就会变成白色，最大值4就会变成深绿色，中间值为浅绿色。
&lt;img src=&quot;/media/15150510388028/15150516669169.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;不同的数值显示不同的进度条&quot;&gt;不同的数值显示不同的进度条&lt;/h4&gt;
&lt;p&gt;选中单元格
开始 - 条件格式
&lt;img src=&quot;/media/15150510388028/15150544932486.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新建规则
&lt;img src=&quot;/media/15150510388028/15150545206149.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设置数据要求。
&lt;img src=&quot;/media/15150510388028/15150545664900.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显示格式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15150510388028/15150545967482.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;求结果单元格的和&quot;&gt;求结果单元格的和&lt;/h3&gt;
&lt;p&gt;选择单元格，输入公式：
&lt;img src=&quot;/media/15150510388028/15150518554180.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=SUM(IF(B4=&quot;跑步&quot;,1,IF(B4=&quot;打球&quot;,1,IF(B4=&quot;休息&quot;,0,&quot;&quot;))),COUNTIF(C4,&quot;*页*&quot;),IF(D4=&quot;打卡&quot;,1,IF(D4=&quot;未打卡&quot;,0)),IF(E4=&quot;编程&quot;,1,IF(E4=&quot;未编程&quot;,0)))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面这个公式的意思是：求B4，C4，D4，E4单元格的和，其中
&lt;code class=&quot;highlighter-rouge&quot;&gt;IF(B4=&quot;跑步&quot;,1,IF(B4=&quot;打球&quot;,1,IF(B4=&quot;休息&quot;,0,&quot;&quot;)))&lt;/code&gt;
的意思是 如果 B4 单元格的文字是 跑步 或者 打球，值就是1，休息值是0。
&lt;code class=&quot;highlighter-rouge&quot;&gt;IF(D4=&quot;打卡&quot;,1,IF(D4=&quot;未打卡&quot;,0))&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;IF(E4=&quot;编程&quot;,1,IF(E4=&quot;未编程&quot;,0)))&lt;/code&gt; 同理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=SUM(G2:G32)&lt;/code&gt;
这个的意思就是求 G2到G32的数值和&lt;/p&gt;

&lt;h3 id=&quot;文字只适应-行宽或者行高&quot;&gt;文字只适应 行宽或者行高&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/media/15150510388028/15150521947905.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 04 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/04/Excel%E6%8A%80%E5%B7%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/04/Excel%E6%8A%80%E5%B7%A7/</guid>
        
        <category>Excel</category>
        
        
      </item>
    
      <item>
        <title>Linux基础</title>
        <description>&lt;h1 id=&quot;linux基础&quot;&gt;Linux基础&lt;/h1&gt;
&lt;h4 id=&quot;shell-命令&quot;&gt;shell 命令&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; 显示当前路径下的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 
&lt;code class=&quot;highlighter-rouge&quot;&gt;clear&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;touch&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;pwd&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; 查看文本内容
&lt;code class=&quot;highlighter-rouge&quot;&gt;history&lt;/code&gt; 之前执行的命令
&lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt; 删除
&lt;code class=&quot;highlighter-rouge&quot;&gt;ls &amp;gt;1.txt&lt;/code&gt;  显示的文件存储到1.txt 文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;cat 1.txt &amp;gt;2.txt&lt;/code&gt; 查看 1.txt 内容 并存储到 2.txt 并覆盖原内容 ，如果2.txt 文件不存在，先创建文件，再存储内容。
&lt;code class=&quot;highlighter-rouge&quot;&gt;cat 1.txt &amp;gt;&amp;gt;2.txt&lt;/code&gt; 两个 » 代表在原内容的基础上追加内容
&lt;code class=&quot;highlighter-rouge&quot;&gt;wc -w yunis.txt&lt;/code&gt; 统计 yunis.txt 的文字数
more 分页查看大文件 按键 q 退出
&lt;code class=&quot;highlighter-rouge&quot;&gt;ls; ls -a&lt;/code&gt; 可以用 ; 执行两条命令&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;管道：一个命令的输出可以通过管道做为另一个命令的输入。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt; 回到上次用户所处在的路径
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~&lt;/code&gt; 回到根目录&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mv 1.txt 11.txt&lt;/code&gt; 重命名 1.txt 为 11.txt
&lt;code class=&quot;highlighter-rouge&quot;&gt;mv 1.txt ../11.txt&lt;/code&gt; 移动1.txt 到上层目录并重命名为11.txt
&lt;code class=&quot;highlighter-rouge&quot;&gt;cp 2.txt ../&lt;/code&gt; copy 2.txt 一份到上层目录&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s 11.txt 100.txt&lt;/code&gt; 为 11.txt 创建 100.txt 的快捷方式
&lt;code class=&quot;highlighter-rouge&quot;&gt;ln 11.txt 100.txt&lt;/code&gt; 相当于复制了一份相同的内容&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grep -n '^a' 1.txt&lt;/code&gt;   搜寻以a开头的行
&lt;code class=&quot;highlighter-rouge&quot;&gt;grep -n 'a$' 1.txt&lt;/code&gt;   搜寻以a结尾的行&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;find ./ -name &quot;^SY*.m&quot;&lt;/code&gt; 查找当前目录下名字为 &lt;code class=&quot;highlighter-rouge&quot;&gt;SY&lt;/code&gt; 开头的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.m&lt;/code&gt; 结尾的文件。
&lt;code class=&quot;highlighter-rouge&quot;&gt;find ./ -name test.sh&lt;/code&gt; 查找当前目录下所有名为test.sh的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find ./ -name '*.sh'	&lt;/code&gt;	 查找当前目录下所有后缀为.sh的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find ./ -name &quot;[A-Z]*&quot;	&lt;/code&gt; 查找当前目录下所有以大写字母开头的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find /tmp -size 2M	&lt;/code&gt; 查找在/tmp 目录下等于2M的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find /tmp -size +2M	&lt;/code&gt;查找在/tmp 目录下大于2M的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find /tmp -size -2M	&lt;/code&gt; 查找在/tmp 目录下小于2M的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find ./ -size +4k -size -5M&lt;/code&gt; 查找当前目录下大于4k，小于5M的文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;find ./ -perm 0777	&lt;/code&gt;  查找当前目录下权限为 777 的文件或目录&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh UserName@192.168.XX.XX&lt;/code&gt; 远程连接 &lt;code class=&quot;highlighter-rouge&quot;&gt;UserName&lt;/code&gt;：用户名  &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.XX.XX&lt;/code&gt; ip地址。&lt;/p&gt;

&lt;h4 id=&quot;linux-文件权限&quot;&gt;Linux 文件权限&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/media/15126318765585/Linux用户权限.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; ：可读&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; ：可写&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; ：可执行
    &lt;h5 id=&quot;更改文件权限&quot;&gt;更改文件权限&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;u 文件的拥有者&lt;/li&gt;
  &lt;li&gt;g 文件的用户组&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;o 其他&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; chmod u=rwx 1.txt&lt;/code&gt; 修改用户的权限
&lt;img src=&quot;/media/15126318765585/修改文件权限.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod g=rw- 1.txt&lt;/code&gt; 修改用户用户组的权限
&lt;img src=&quot;/media/15126318765585/修改文件用户组权限.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod o=rw- 1.txt&lt;/code&gt; 修改其他用户的权限&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;同时修改 用户、用户组、其他用户的权限：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod o=r,g=r,o=r 1.txt&lt;/code&gt; 用户、用户组、其他用户的权限均为可读的权限&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod o=,g=,o= 1.txt&lt;/code&gt; 用户、用户组、其他用户的权限均没有任何权限&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用数字法修改权限：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r --------- 4
w --------- 2
x --------- 1

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 数字 1，代表可执行
* 数字 2，带包可写
* 数字 4，代表可读
* 数字 5，代表可读、可执行
* 数字 6，代表可读、可写
* 数字 7，代表可读、可写、可执行
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/media/15126318765585/数字法修改用户权限.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod 777 1.txt&lt;/code&gt; 的意思就是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;1.txt&lt;/code&gt; 这个文件修改为&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拥有文件的用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;可读&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可写&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可执行&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;文件所属的组 &lt;code class=&quot;highlighter-rouge&quot;&gt;可读&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可写&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可执行&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;其他用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;可读&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可写&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可执行&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同理 &lt;code class=&quot;highlighter-rouge&quot;&gt;chmod 644  1.txt&lt;/code&gt;的意思是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;1.txt&lt;/code&gt; 这个文件修改为&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拥有文件的用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;可读&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;可写&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;文件所属的组 &lt;code class=&quot;highlighter-rouge&quot;&gt;可读&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;其他用户 &lt;code class=&quot;highlighter-rouge&quot;&gt;可读&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vim-命令&quot;&gt;vim 命令&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/media/15126318765585/201607-vim-keymap.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;进入插入模式&quot;&gt;进入插入模式:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i: 插入光标前一个字符 

I: 插入行首 

a: 插入光标后一个字符 

A: 插入行未 

o: 向下新开一行,插入行首 

O: 向上新开一行,插入行首
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;进入命令模式&quot;&gt;进入命令模式:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ESC:从插入模式或末行模式进入命令模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;移动光标&quot;&gt;移动光标:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h: 左移 

j: 下移 

k: 上移 

l: 右移

M: 光标移动到中间行 

L: 光标移动到屏幕最后一行行首 

G: 移动到指定行,行号 -G

w: 向后一次移动一个字 

b: 向前一次移动一个字

{: 按段移动,上移 

}: 按段移动,下移

Ctr-d: 向下翻半屏 

Ctr-u: 向上翻半屏

Ctr-f: 向下翻一屏 

Ctr-b: 向上翻一屏

gg: 光标移动文件开头 

G: 光标移动到文件末尾
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;删除命令&quot;&gt;删除命令:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x: 删除光标后一个字符,相当于 Del 

X: 删除光标前一个字符,相当于 Backspace

dd: 删除光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符 

d0: 删除光标前本行所有内容,不包含光标所在字符

dw: 删除光标开始位置的字,包含光标所在字符
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;撤销命令&quot;&gt;撤销命令:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u: 一步一步撤销 


Ctr-r: 反撤销
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;重复命令&quot;&gt;重复命令:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.: 重复上一次操作的命令
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;文本行移动&quot;&gt;文本行移动:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;: 文本行右移 

&amp;lt;&amp;lt;: 文本行左移
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;复制粘贴&quot;&gt;复制粘贴:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yy: 复制当前行,n yy 复制 n 行 

p: 在光标所在位置向下新开辟一行,粘贴
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;可视模式&quot;&gt;可视模式:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v: 按字符移动,选中文本 

V: 按行移动,选中文本可视模式可以配合 d, y, &amp;gt;&amp;gt;, &amp;lt;&amp;lt; 实现对文本块的删除,复制,左右移动
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;替换操作&quot;&gt;替换操作:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r: 替换当前字符 

R: 替换当前行光标后的字符
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;查找命令&quot;&gt;查找命令:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/: str查找
n: 下一个
N：上一个
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;替换命令&quot;&gt;替换命令：&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;把abc全部替换成123&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;末行模式下，将光标所在行的abc替换成123
:%s/abc/123/g

末行模式下，将第一行至第10行之间的abc替换成123
:1, 10s/abc/123/g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;vim里执行-shell-下命令&quot;&gt;vim里执行 shell 下命令:&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;末行模式里输入!,后面跟命令

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 08 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/08/Linux%E5%9F%BA%E7%A1%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/08/Linux%E5%9F%BA%E7%A1%80/</guid>
        
        
      </item>
    
      <item>
        <title>(转载)简单几条命令，轻松开启 macOS 系统隐藏功能</title>
        <description>&lt;h1 id=&quot;转载简单几条命令轻松开启-macos-系统隐藏功能&quot;&gt;(转载)简单几条命令，轻松开启 macOS 系统隐藏功能&lt;/h1&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://sspai.com/post/41695&quot;&gt;简单几条命令，轻松开启 macOS 系统隐藏功能 新手问号&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/article/f9454695-bfc7-f1f2-5b36-6cf46c7c0209.jpg?imageMogr2/quality/95/thumbnail/!700x233r/gravity/Center/crop/700x233&quot; alt=&quot;简单几条命令，轻松开启 macOS 系统隐藏功能&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sspai.com/user/719707&quot;&gt;&lt;img src=&quot;https://cdn.sspai.com/2017/08/31/45f498dc0e9a6b1caf7a1f2146682c0b.jpg?imageMogr2/quality/95/thumbnail/!60x60r/gravity/Center/crop/60x60&quot; alt=&quot;WATERS&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;waters&quot;&gt;&lt;a href=&quot;https://sspai.com/user/719707&quot;&gt;WATERS&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;编注：「新手问号」是少数派的一个全新栏目。它面向完全「零基础」的新手用户，通过最简单易懂的方式，帮助你快速掌握关于系统和软硬件的入门知识。&lt;/p&gt;

&lt;p&gt;栏目文章回顾：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://sspai.com/post/41411&quot;&gt;向 Windows 高级用户进阶，这 10 款效率工具帮你开路&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://sspai.com/post/41477&quot;&gt;macOS 上都有哪些既免费、又实用的工具？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://sspai.com/post/41371&quot;&gt;刚从 Windows 转到 macOS，如何快速上手操作？&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://sspai.com/post/41363&quot;&gt;做好这四种方法，让你的 Mac 远离数据被盗和丢失&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Mac 中有一个图标是「黑色的窗口」名为「终端 Terminal」的应用，对于一个普通人用户来说，它就好像有一层神秘的面纱，时常让人觉得只有技术流、程序员才能驾驭。而命令行这种东西似乎也都是存在想象里的，一个人对着空白的窗口噼里啪啦的打下一行代码，然后电脑便自动给你执行相应的任务。其实作为新手的我们一样也可以让它发挥出一定的作用，今天的这一篇文章就带你了解一些你可能也能用到的命令行，让你轻松开启系统的隐藏功能。&lt;/p&gt;

&lt;h2 id=&quot;配置-launchpad&quot;&gt;配置 Launchpad&lt;/h2&gt;

&lt;p&gt;在大家安装好应用去 Launchpad 里寻找的时候，时常会发现原生的配置让 Launchpad 看的稍许拥挤，但是在系统偏好设置里我们是无法修改的。为了让我们的 Launchpad 识别度更高并且更加美观，可以通过终端对排列方式进行修改，复制以下代码至终端即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.dock springboard-columns -int 8; defaults write com.apple.dock springboard-rows -int 7; defaults write com.apple.dock ResetLaunchPad -bool TRUE; killall Dock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令中有两个数字 8 和 7，它们分别代表的是布局中的列数和行数，如果想更清除的了解该段命令，可以参考《&lt;a href=&quot;https://sspai.com/post/33299&quot;&gt;通过终端命令改变 Launchpad 中应用图标的大小&lt;/a&gt;》。
&lt;img src=&quot;https://cdn.sspai.com/2017/11/09/4b53845799f46d7aba1eb7d58fe9b846.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;
除了可以对 Launchpad 的布局进行更改，还可以根据自己的喜好对北背景的模糊程度进行更改，复制以下代码至终端即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.dock springboard-blur-radius -int 100; killall Dock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令中有一个数字 100，它代表的背景模糊的程度，你可以在 0 ~ 255 的范围内选择。&lt;/p&gt;

&lt;h2 id=&quot;修改截图属性&quot;&gt;修改截图属性&lt;/h2&gt;

&lt;p&gt;Mac 上自带的截图非常的还用，可以区域、窗口、延时截图。但是截图会默认保存在你的桌面上，时间一长，你的桌面就会被五花八门的截图堆满。对此，我们可以新建一个文件夹专门来存放截图，新建一个 screenshots 的文件夹在桌面或者任意一个你希望它待在的地方，将下述代码复制进终端即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.screencapture location ~/Desktop/screenshots; killall SystemUIServer
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;~ 之后填写你相应的文件夹路径即可，如果不清楚路径的写法，可以打开该文件夹右键点击任何一个文件「显示简介」，复制「位置」之后的内容即可，也可以直接将文件夹拖拽至终端以此显示路径。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2017/11/09/05c353239dec51329c19169daef951a6.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除此之外，你也可以使用以下命令修改截图保存的类型，例如你想保存 JPG 格式的截图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;efaults write com.apple.screencapture type jpg &amp;amp;&amp;amp; killall SystemUIServe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;显示隐藏文件夹&quot;&gt;显示隐藏文件夹&lt;/h2&gt;

&lt;p&gt;在 Windows 上隐藏文件夹大家应该都是老手了，转到 Mac 后，却发现隐藏文件夹和自己想象有那么一些不一样。为了更好的把大家的「小秘密」藏到内心最深处的地方，也可以使用两段命令来完成操作。跟前文一样，我们需要获取文件夹的路径，然后在终端中输入以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chflags hidden ~/Desktop/Hidden
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nohidden&lt;/code&gt; 重新让该文件夹显示。如果你要显示全部文件，推荐大家直接使用快捷键「Shift + Command + .」即可显示全部隐藏文件。
&lt;img src=&quot;https://cdn.sspai.com/2017/11/09/52ea8991101b5a04c7f5d3a59aea7731.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;
除此之外，如果你觉得自己桌面太乱了，但是这会又有人来看你的电脑，你可以使用一段命令行将桌面的文件全部隐藏起来，让桌面回归清爽，文件也依旧可以通过 Finder 中的桌面中找到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.finder CreateDesktop -bool false; killall Finder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果想重新看到桌面的图标，将 false 替换为 true 输入终端即可。&lt;/p&gt;

&lt;h2 id=&quot;dock-栏属性修改&quot;&gt;Dock 栏属性修改&lt;/h2&gt;

&lt;p&gt;Mac 中为了获得更大的可视空间，在不使用 Dock 时我们可以隐藏它。若要查看隐藏的 Dock，可以将指针移到 Dock 所在屏幕的边缘。但是这个显示速度存在了一定的延迟，为了加速这个过程，我们可以使用一段命令行，让你的隐藏 Dock 弹出的时候更加的顺滑流畅：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.apple.Dock autohide-delay -float 0 &amp;amp;&amp;amp; killall Dock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用后的效果，可以说是非常明显了，再也不会有在「挤牙膏」的感觉。
&lt;img src=&quot;https://cdn.sspai.com/2017/11/09/938e520e64d816a59123861e24efda34.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;
如果在你的使用下，Dock 栏上摆满了各类 App，却发现这不是自己想要的结果。你可以通过终端来重置你的 Dock 栏，让它回到最开始的状态：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults delete com.apple.dock; killall Dock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;让屏幕亮的更久&quot;&gt;让屏幕亮的更久&lt;/h2&gt;

&lt;p&gt;Mac 在运行一段时间后，会自动进入睡眠。如果大家不想 Mac 那么快的进入书面，可以采用一些第三方软件来达到此目的。其实与其下载一个软件占用 Mac 上精贵的储存，不如使用一段命令行就可以解决这些问题了。下方命令行中的 3600 单位是秒，即你希望多长时间内你的 Mac 不会进入睡眠：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;caffeinate -t 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;应用安装与更新&quot;&gt;应用安装与更新&lt;/h2&gt;

&lt;p&gt;MAS 的连接情况大家也很清楚，时常会因为情绪不稳定导致你无法获得最完美的下载体验，况且还有很多应用并不在商店上架，或是非商店版本有更多的功能。原来的时候，我们需要查找一个又一个的官网，然后下载安装，其实这么多繁琐操作，在终端里可以更快的完成。你只需要输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew cask install App
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将 App 替换为你需要安装的软件的名字即可。但是使用前，需要你在电脑中安装 Homebrew Cask ，具体可以参考《&lt;a href=&quot;https://sspai.com/post/40321&quot;&gt;再谈 Homebrew Cask 在 macOS 上安装应用的轻松感&lt;/a&gt;》。大多数通过 Cask 安装的软件都自带更新选项，如果没有该选项，用户依旧可以通过终端进行更新，在终端中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;brew tap buo/cask-upgrade&lt;/code&gt;，然后再输入下段命令即可更新全部应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew cu
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.sspai.com/2017/11/10/0a289482f9790f047468edf2d0c89996.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1&quot; alt=&quot;&quot; /&gt;
如果你希望安装 MAS 上的应用，也可以绕过原生的商店应用，直接采用终端进行安装。你可以先通过刚才安装的 Homebrew 安装一个我们需要的 mas ，即在终端输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install mas 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，可以在终端中搜索需要的软件，或者直接输入关键字段加上应用的识别码进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mas install AppID
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;友情提示-️&quot;&gt;友情提示 ⚠️&lt;/h2&gt;

&lt;p&gt;终端操作虽然说很快捷，可能你也觉得很高端。但是，在网络上经常会有人拿终端命令开玩笑，比如前面带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm -rf&lt;/code&gt; 类型字段的，一定要谨慎使用。可能就是这一步操作，电脑就会「爆炸」，也希望大家也不要开这一类玩笑，给大家一个美好的环境！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sspai.com/tag/%e6%96%b0%e6%89%8b&quot;&gt;新手&lt;/a&gt;&lt;a href=&quot;https://sspai.com/tag/%e6%8a%80%e5%b7%a7&quot;&gt;技巧&lt;/a&gt;&lt;a href=&quot;https://sspai.com/tag/macOS&quot;&gt;macOS&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 14 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/11/14/(%E8%BD%AC%E8%BD%BD)%E7%AE%80%E5%8D%95%E5%87%A0%E6%9D%A1%E5%91%BD%E4%BB%A4-%E8%BD%BB%E6%9D%BE%E5%BC%80%E5%90%AF-macOS-%E7%B3%BB%E7%BB%9F%E9%9A%90%E8%97%8F%E5%8A%9F%E8%83%BD-%E6%96%B0%E6%89%8B%E9%97%AE%E5%8F%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/14/(%E8%BD%AC%E8%BD%BD)%E7%AE%80%E5%8D%95%E5%87%A0%E6%9D%A1%E5%91%BD%E4%BB%A4-%E8%BD%BB%E6%9D%BE%E5%BC%80%E5%90%AF-macOS-%E7%B3%BB%E7%BB%9F%E9%9A%90%E8%97%8F%E5%8A%9F%E8%83%BD-%E6%96%B0%E6%89%8B%E9%97%AE%E5%8F%B7/</guid>
        
        
      </item>
    
      <item>
        <title>算法图解</title>
        <description>&lt;h1 id=&quot;算法图解&quot;&gt;算法图解&lt;/h1&gt;
&lt;h3 id=&quot;算法简介&quot;&gt;算法简介&lt;/h3&gt;
&lt;h4 id=&quot;对数&quot;&gt;对数&lt;/h4&gt;
&lt;p&gt;对数运算是幂运算的逆运算。
&lt;img src=&quot;/media/15105545936376/15105546056701.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;二分查找如何实现&quot;&gt;二分查找如何实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def binary_search(array,item):
    low = 0
    high = len(array) - 1
    print(&quot;large index is %d&quot;%high)

    while low &amp;lt;= high:
        mid = int((low + high)/2)
        guess = array[mid]
        print(&quot;Mid is %d&quot;%mid)
        print(&quot;guess is %d&quot;%guess)
        if  guess == item:
            return mid
        elif guess &amp;lt; item:
            low = mid + 1
            print(&quot;+++++++low is %d&quot;%low)
        elif guess &amp;gt; item:
            high = mid - 1
            print(&quot;-------high is %d&quot;%high)
        else:
            return None
myList = [1,3,7,9,12,23,45,67,89,123,244,345,456,1234]
print(binary_search(myList,23))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;运行时间&quot;&gt;运行时间&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;每次介绍算法时，我都将讨论其运行时间。一般而言，应选择效率最高的算 法，以最大限度地减少运行时间或占用空间。
简单查找逐个地检查数 字，如果列表包含100个数字，最多需要猜100次。如果列表包含40亿个数字，最 多需要猜40亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为线性 时间(linear time)。
二分查找则不同。如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?二分查找的运行时间为对数时间(或log时间)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/media/15105545936376/15105591801136.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;大-o-表示法&quot;&gt;大 O 表示法&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;大O表示法是一种特殊的表示法，指出了算法的速度有多快。&lt;/li&gt;
  &lt;li&gt;大O表示法 让你能够比较操作数，它指出了算法运行时间的增速。&lt;/li&gt;
  &lt;li&gt;大O表示法指出了最糟情况下的运行时间。&lt;/li&gt;
  &lt;li&gt;算法的速度指的并非时间，而是操作数的增速。&lt;/li&gt;
  &lt;li&gt;谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。&lt;/li&gt;
  &lt;li&gt;算法的运行时间用大O表示法表示。&lt;/li&gt;
  &lt;li&gt;O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面按从快到慢的顺序列出了经常会遇到的5种大O运行时间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[ ]  &lt;strong&gt;O(log n)&lt;/strong&gt;，也叫对数时间，这样的算法包括二分查找。&lt;/li&gt;
  &lt;li&gt;[ ]  &lt;strong&gt;O(n)&lt;/strong&gt;，也叫线性时间，这样的算法包括简单查找。&lt;/li&gt;
  &lt;li&gt;[ ]  &lt;strong&gt;O(n * log n)&lt;/strong&gt;，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。&lt;/li&gt;
  &lt;li&gt;[ ]  &lt;strong&gt;O(n2)&lt;/strong&gt;，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。&lt;/li&gt;
  &lt;li&gt;[ ]  &lt;strong&gt;O(n!)&lt;/strong&gt;，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/media/15105545936376/15106259079062.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;选择排序&quot;&gt;选择排序&lt;/h3&gt;
&lt;h4 id=&quot;内存的工作原理&quot;&gt;内存的工作原理&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设你去看演出，需要将东西寄存。寄存处有一个柜子，柜子有很多抽屉。
每个抽屉可放一样东西，你有两样东西要寄存，因此要了两个抽屉。
你将两样东西存放在这里。
现在你可以去看演出了!这大致就是计算机内存的工作原理。计算机就像是很多抽屉的集合体，每个抽屉都有地址。
需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;数组和链表&quot;&gt;数组和链表&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;数组 ：所有元素在内存中都是相连的，添加需要重新申请内存。&lt;/li&gt;
  &lt;li&gt;链表 ：链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。使用链表时，根本就不需要移动元素。链表的优势在插入元素方面。&lt;/li&gt;
  &lt;li&gt;插入元素：使用链表时，只需要修改前面那个元素指向的地址就可以插入元素，数组的话，就需要把元素后面的元素全部向后移动，如果没有足够的时间的话，还得将数组复制到其他地方。&lt;/li&gt;
  &lt;li&gt;删除元素：使用链表时，只需要修改前一个元素指向的地址就行了，使用数组的话，删除元素后面的元素都需要向前移。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数组&lt;/td&gt;
      &lt;td&gt;查找方便&lt;/td&gt;
      &lt;td&gt;必须使用连续的存储空间，添加元素需要从新分配内存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;链表&lt;/td&gt;
      &lt;td&gt;可以使用分割开的内存，添加元素方便&lt;/td&gt;
      &lt;td&gt;查找慢，必须重头开始一个个地址的查。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;常见的数组和链表操作的运行时间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15105545936376/15106419508468.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;选择排序-1&quot;&gt;选择排序&lt;/h4&gt;

&lt;p&gt;时间：O(n²)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
# 找出当前数组最小的数字的index
def findSmallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1,len(arr)):
        if arr[i] &amp;lt; smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

# 选择排序  O(n²)
def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest_index = findSmallest(arr)
        # arr.pop(smallest_index) 移除指定位置的元素，并返回这个元素
        newArr.append(arr.pop(smallest_index))
    return newArr


print (selectionSort([5, 3, 6, 2, 10]))

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;计算机内存犹如一大堆抽屉。&lt;/li&gt;
  &lt;li&gt;需要存储多个元素时，可使用数组或链表。&lt;/li&gt;
  &lt;li&gt;数组的元素都在一起。&lt;/li&gt;
  &lt;li&gt;链表的元素是分开的，其中每个元素都存储了下一个元素的地址。&lt;/li&gt;
  &lt;li&gt;数组的读取速度很快。&lt;/li&gt;
  &lt;li&gt;链表的插入和删除速度很快。&lt;/li&gt;
  &lt;li&gt;在同一个数组中，所有元素的类型都必须相同(都为int、double等)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;递归&quot;&gt;递归&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/media/15105545936376/15106447680191.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/media/15105545936376/15106447757742.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;栈&quot;&gt;栈&lt;/h4&gt;

&lt;h5 id=&quot;调用栈&quot;&gt;调用栈&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;计算机在内部使用被称为调用栈的栈。
 下面是一个 简单的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def greet(name):
    print &quot;hello, &quot; + name + &quot;!&quot; 
    greet2(name)
    print &quot;getting ready to say bye...&quot;
    bye()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个函数问候用户，再调用另外两个函数。这两个函数的代码如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def greet2(name):
    print &quot;how are you, &quot; + name + &quot;?&quot;
def bye():
    print &quot;ok bye!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设你调用greet(“maggie”)，计算机将首先为该函数调用分配一块内存。
&lt;img src=&quot;/media/15105545936376/15106457934088.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们来使用这些内存。变量name被设置为maggie，这需要存储到内存中。
&lt;img src=&quot;/media/15105545936376/15106458376828.jpg&quot; alt=&quot;&quot; /&gt;
每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来， 你打印hello, maggie!，再调用greet2(“maggie”)。同样，计算机也为这个函数调用分配一 块内存。
&lt;img src=&quot;/media/15105545936376/15106458571552.jpg&quot; alt=&quot;&quot; /&gt;
计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印 how are you, maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。
&lt;img src=&quot;/media/15105545936376/15106458854545.jpg&quot; alt=&quot;&quot; /&gt;
现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2 时，函数greet只执行了一部分。这是本节的一个重要概念:调用另一个函数时，当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。执行完函数greet2后，你回到函数 greet，并从离开的地方开始接着往下执行:首先打印getting ready to say bye…，再调用 函数bye。
&lt;img src=&quot;/media/15105545936376/15106459042795.jpg&quot; alt=&quot;&quot; /&gt;
在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。
&lt;img src=&quot;/media/15105545936376/15106459176341.jpg&quot; alt=&quot;&quot; /&gt;
现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于
存储多个函数的变量，被称为调用栈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;这一段讲的真好，之前一直理不清楚这个概念&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;小结-1&quot;&gt;小结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;递归指的是调用自己的函数。&lt;/li&gt;
  &lt;li&gt;每个递归函数都有两个条件:基线条件和递归条件。 * 栈有两种操作:压入和弹出。&lt;/li&gt;
  &lt;li&gt;所有函数调用都进入调用栈。&lt;/li&gt;
  &lt;li&gt;调用栈可能很长，这将占用大量的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;快速排序&quot;&gt;快速排序&lt;/h3&gt;

&lt;h4 id=&quot;分而治之divide划分-and-conquer征服&quot;&gt;分而治之(divide(划分) and conquer(征服))&lt;/h4&gt;

&lt;p&gt;D&amp;amp;C的工作原理:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找出简单的&lt;strong&gt;基线条件&lt;/strong&gt;;&lt;/li&gt;
  &lt;li&gt;确定如何&lt;strong&gt;缩小问题的规模&lt;/strong&gt;，使其符合基线条件。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;快速排序-1&quot;&gt;快速排序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;快速排序是一种常用的排序算法，比选择排序快得多。&lt;/li&gt;
  &lt;li&gt;例如，C语言标准库中的函数qsort 实现的就是快速排序。&lt;/li&gt;
  &lt;li&gt;快速排序也使用了D&amp;amp;C。
    &lt;ul&gt;
      &lt;li&gt;基线条件
        &lt;ul&gt;
          &lt;li&gt;基线条件为数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缩小问题规模
        &lt;ul&gt;
          &lt;li&gt;首先，从数组中选择一个元素，这个元素被称为基准值(pivot)。&lt;/li&gt;
          &lt;li&gt;接下来，找出比基准值小的元素以及比基准值大的元素。&lt;/li&gt;
          &lt;li&gt;这被称为分区(partitioning)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 这样写更好理解一点

def quickSort(array):
    # 判断数组是否满足基线条件，如果满足基线条件直接返回
    # 如果不满足基线条件，继续减小问题规模
    if len(array) &amp;gt; 1:
        mid = array[0]
        largeArray = []
        smallArray = []
        print(&quot;---------------mid = &quot; + str(mid))
        for index in range(1,len(array)):
            value = array[index]
            if  value &amp;gt; mid :
                largeArray = largeArray +[value]
            else :
                smallArray = smallArray +[value]
        print(&quot;smallArrar = &quot; + str(smallArray))
        print(&quot;largeArray = &quot; + str(largeArray))
        return quickSort(smallArray) + [mid] + quickSort(largeArray)
    else:
        return array
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#更符合 Python 的写法

def quicksort(array):
  if len(array) &amp;lt; 2:
    # base case, arrays with 0 or 1 element are already &quot;sorted&quot;
    return array
  else:
    # recursive case
    pivot = array[0]
    # sub-array of all the elements less than the pivot
    less = [i for i in array[1:] if i &amp;lt;= pivot]
    # sub-array of all the elements greater than the pivot
    greater = [i for i in array[1:] if i &amp;gt; pivot]
    return quicksort(less) + [pivot] + quicksort(greater)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这行代码的意思：
&lt;code class=&quot;highlighter-rouge&quot;&gt;less = [i for i in array[1:] if i &amp;lt;= pivot]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;寻找 array 中 index 1 到末尾的元素，当这个元素小于等于 pivot 时，返回这个元素 i，存储在数组中；&lt;/p&gt;

&lt;p&gt;图形演示更直观一点：
&lt;img src=&quot;/img/in-post/GIF/quickSort.gif&quot; alt=&quot;快排&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;推荐一个网站&lt;a href=&quot;https://visualgo.net/en&quot;&gt;visualgo&lt;/a&gt;,可以直观的演示算法的执行过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;为什么快速排序的复杂度为-nlog-n&quot;&gt;为什么快速排序的复杂度为 n*log n&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/media/15105545936376/15111703521218.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在这个示例中，层数为O(log n)(用技术术语说，调用栈的高度为O(log n))，而每层需要的 时间O(n)。因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况。
在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) * O(n) = O(n²)。
只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n log n)。快速排序是最快的排序算法之一，也是D&amp;amp;C典范.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;散列表&quot;&gt;散列表&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;散列表 哈希表 字典 区别与共同点&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;散列表查找速度是 O(1)。&lt;/p&gt;

&lt;h4 id=&quot;散列函数&quot;&gt;散列函数&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;散列函数必须满足一些要求:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;它必须是一致的。输入相同的内容时，得到是数字是一样的。&lt;/li&gt;
  &lt;li&gt;它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1， 它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;散列函数为什么可以迅速查找到结果：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个 数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来 确定鳄梨的价格存储在什么地方。&lt;/li&gt;
  &lt;li&gt;散列函数将不同的输入映射到不同的索引。。avocado映射到索引4，milk映射到索引0。每 种商品都映射到数组的不同位置，让你能够将其价格存储到这里。&lt;/li&gt;
  &lt;li&gt;散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会 返回无效索引100。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;散列表应用&quot;&gt;散列表应用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;用于查找
    &lt;ul&gt;
      &lt;li&gt;无论你访问哪个网站，其网址都必须转换为IP地址。这个过程被称为DNS解析 (DNS resolution)，散列表是提供这种功能的方式之一。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;防止重复&lt;/li&gt;
  &lt;li&gt;用作缓存
    &lt;ul&gt;
      &lt;li&gt;缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;小结-2&quot;&gt;小结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;可以结合散列函数和数组来创建散列表。&lt;/li&gt;
  &lt;li&gt;冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。&lt;/li&gt;
  &lt;li&gt;散列表的查找、插入和删除速度都非常快。&lt;/li&gt;
  &lt;li&gt;散列表适合用于模拟映射关系。&lt;/li&gt;
  &lt;li&gt;一旦填装因子超过0.7，就该调整散列表的长度。&lt;/li&gt;
  &lt;li&gt;散列表可用于缓存数据(例如，在Web服务器上)。&lt;/li&gt;
  &lt;li&gt;散列表非常适合用于防止重复。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;广度优先搜索&quot;&gt;广度优先搜索&lt;/h3&gt;

&lt;p&gt;广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多!使用广 度优先搜索可以:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编写国际跳棋AI，计算最少走多少步就可获胜;&lt;/li&gt;
  &lt;li&gt;编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将
READED改为READER需要编辑一个地方;&lt;/li&gt;
  &lt;li&gt;根据你的人际关系网络找到关系最近的医生。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;解决最短路径问题&lt;/code&gt;的算法被称为&lt;code class=&quot;highlighter-rouge&quot;&gt;广度优先搜索&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;图简介&quot;&gt;图简介&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。&lt;/code&gt;
图模拟一组连接。
图用于模拟不同的东西是如何相连的。&lt;/p&gt;

&lt;h4 id=&quot;广度优先搜索-1&quot;&gt;广度优先搜索&lt;/h4&gt;

&lt;p&gt;广度优先搜索可回答两类问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一类问题:从节点A出发，有前往节点B的路径吗?&lt;/li&gt;
  &lt;li&gt;第二类问题:从节点A出发，前往节点B的哪条路径最短?&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;假设 需要查找 你认识的人中，以及你认识的人所认识的人中，是否有名字末尾为 M 的人。
&lt;img src=&quot;/media/15105545936376/15117489027923.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;搜索的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先查看 你 认识的人中是否有符合条件的人；
    &lt;ul&gt;
      &lt;li&gt;找到 alice、bob、claire 三个人&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果有直接返回这个人，如果没有，就继续查找你认识的人中的社交关系是否有需要查找的人。
    &lt;ul&gt;
      &lt;li&gt;这三个人没有一个符合条件的人，把他们加入到队列中&lt;/li&gt;
      &lt;li&gt;从队列中取出候选人查看，如果候选人不符合，就把候选人的联系人继续添加到队列中，同时标识这个候选人已经排查过了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;知道找到需要的人，或者整个社交圈搜索完毕。
    &lt;ul&gt;
      &lt;li&gt;重复上面的操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import deque


graph = {}
graph[&quot;you&quot;] = [&quot;alice&quot;, &quot;bob&quot;, &quot;claire&quot;]
graph[&quot;bob&quot;] = [&quot;anuj&quot;, &quot;peggy&quot;]
graph[&quot;alice&quot;] = [&quot;peggy&quot;]
graph[&quot;claire&quot;] = [&quot;thom&quot;, &quot;jonny&quot;]
graph[&quot;anuj&quot;] = []
graph[&quot;peggy&quot;] = []
graph[&quot;thom&quot;] = []
graph[&quot;jonny&quot;] = []

# 判断是不是需要找到的人
def person_is_seller(name):
    if name[-1] == 'm':
        return True
    else:
        return False

# 查找与 name 关系最近的符合条件的人
def searchName(name):
    # 创建一个队列 用于存储要查找的人
    searchQueue = deque()
    # 先在 name 的第一层级去找是否有符合条件的人
    searchQueue += graph[name]
    # 用于记录 已经查找过的人 放置重复查找
    searched = []
    # 当队列不为空时，循环执行
    while searchQueue:
        # 取出队列的第一个人
        person = searchQueue.popleft()
        # 当前  person 没有被查找过
        if not person  in searched:
            print(&quot;searching &quot; + person)
            # 判断 person 是否我们需要的人。
            if person_is_seller(person):
                print(person + &quot; is you  need person&quot;)
                return True
            else:
                # 如果 person 不是符合条件的人
                # 把与  person 关联的人加入到队列中
                searchQueue += graph[person]
                # 把 person 标记为已经查找过
                searched.append(person)
    return False

# 查找跟 “you” 关系最近发符合条件的人。
searchName(&quot;you&quot;)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;狄克斯特拉算法&quot;&gt;狄克斯特拉算法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;狄克斯特拉算法 找出最快路径。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/15105545936376/15117652304241.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为&lt;code class=&quot;highlighter-rouge&quot;&gt;权重(weight)&lt;/code&gt;。
狄克斯特拉算法只适用于&lt;code class=&quot;highlighter-rouge&quot;&gt;有向无环图(directed acyclic graph，DAG)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;带权重的图称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;加权图(weighted graph)&lt;/code&gt;，不带权重的图称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;非加权图(unweighted graph)&lt;/code&gt;。
&lt;img src=&quot;/media/15105545936376/15117653278009.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;要计算非加权图中的最短路径，可使用&lt;code class=&quot;highlighter-rouge&quot;&gt;广度优先搜索&lt;/code&gt;。要计算加权图中的最短路径，可使用&lt;code class=&quot;highlighter-rouge&quot;&gt;狄克斯特拉算法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;狄克斯特拉算法包含4个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找出“最便宜”的节点，即可在最短时间内到达的节点。&lt;/li&gt;
  &lt;li&gt;更新该节点的邻居的开销，其含义将稍后介绍。&lt;/li&gt;
  &lt;li&gt;重复这个过程，直到对图中的每个节点都这样做了。&lt;/li&gt;
  &lt;li&gt;计算最终路径。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/11/13/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/13/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/</guid>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>（转载）程序员技术练级攻略</title>
        <description>&lt;h1 id=&quot;转载程序员技术练级攻略&quot;&gt;（转载）程序员技术练级攻略&lt;/h1&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://coolshell.cn/articles/4990.html&quot;&gt;程序员技术练级攻略&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2011/07/programmer.png&quot; alt=&quot;程序员技术练级入略&quot; /&gt;月光博客6月12日发表了《&lt;a href=&quot;http://www.williamlong.info/archives/2700.html&quot;&gt;写给新手程序员的一封信&lt;/a&gt;》，翻译自《&lt;a href=&quot;http://blog.akash.im/an-open-letter-to-those-who-want-to-start&quot;&gt;An open letter to those who want to start programming&lt;/a&gt;》，我的朋友（他在本站的id是&lt;a href=&quot;https://coolshell.cn/?author=3&quot;&gt;Mailper&lt;/a&gt;）告诉我，他希望在酷壳上看到一篇更具操作性的文章。因为他也是喜欢编程和技术的家伙，于是，我让他把他的一些学习Python和Web编程的一些点滴总结一下。于是他给我发来了一些他的心得和经历，我在把他的心得做了不多的增改，并根据我的经历增加了“进阶”一节。&lt;strong&gt;这是一篇由新手和我这个老家伙根据我们的经历完成的文章&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我的这个朋友把这篇文章取名叫Build Your Programming Technical Skills，我实在不知道用中文怎么翻译，但我在写的过程中，&lt;strong&gt;我觉得这很像一个打网游做任务升级的一个过程，所以取名叫“技术练级攻略”，题目有点大，呵呵，这个标题纯粹是为了好玩&lt;/strong&gt;。&lt;strong&gt;这里仅仅是在分享Mailper和我个人的学习经历。&lt;/strong&gt;（注：省去了我作为一个初学者曾经学习过的一些技术(今天明显过时了)，如：Delphi/Power builder，也省去了我学过的一些我觉得没意思的技术Lotus Notes/ActiveX/COM/ADO/ATL/.NET ……）&lt;/p&gt;

&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;

&lt;p&gt;你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，作业项目都看不出有什么实际作用，不如从工作中的需求出发）&lt;/p&gt;

&lt;p&gt;建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累而且还会在未来至少10年通用。&lt;/li&gt;
  &lt;li&gt;回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。&lt;/li&gt;
  &lt;li&gt;一定要动手，例子不管多么简单，建议至少自己手敲一遍看看是否理解了里头的细枝末节。&lt;/li&gt;
  &lt;li&gt;一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：你也许会很奇怪为什么下面的东西很偏Unix/Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。&lt;/li&gt;
  &lt;li&gt;越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。&lt;/li&gt;
  &lt;li&gt;微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《&lt;a href=&quot;https://coolshell.cn/articles/3008.html&quot;&gt;Windows编程革命史&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。&lt;/p&gt;

&lt;h4 id=&quot;启蒙入门&quot;&gt;启蒙入门&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1、 学习一门脚本语言，例如Python/Ruby&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）&lt;/li&gt;
  &lt;li&gt;遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果&lt;/li&gt;
  &lt;li&gt;跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量&lt;/li&gt;
  &lt;li&gt;学会用各种print之类简单粗暴的方式进行调试&lt;/li&gt;
  &lt;li&gt;学会用Google (phrase, domain, use reader to follow tech blogs)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vim / Emacs / Notepad++，学会如何配置代码补全，外观，外部命令等。&lt;/li&gt;
  &lt;li&gt;Source Insight (或 ctag)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码/配置文章/日志会更快更有效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、 熟悉Unix/Linux Shell和常见的命令行&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧&lt;/li&gt;
  &lt;li&gt;一定要少用少用图形界面。&lt;/li&gt;
  &lt;li&gt;学会使用man来查看帮助&lt;/li&gt;
  &lt;li&gt;文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip …&lt;/li&gt;
  &lt;li&gt;学会使用一些文本操作命令 sed/awk/grep/tail/less/more …&lt;/li&gt;
  &lt;li&gt;学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd…&lt;/li&gt;
  &lt;li&gt;了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息&lt;/li&gt;
  &lt;li&gt;了解正则表达式，使用正则表达式来查找文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《&lt;a href=&quot;http://blog.csdn.net/haoel/article/details/1533720&quot;&gt;其实Unix很简单&lt;/a&gt;》）学会使用Unix/Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、 学习Web基础（HTML/CSS/JS) + 服务器端技术 (LAMP)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;未来必然是Web的世界，学习WEB基础的最佳网站是&lt;a href=&quot;http://www.w3school.com.cn/&quot;&gt;W3School&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;学习HTML基本语法&lt;/li&gt;
  &lt;li&gt;学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）&lt;/li&gt;
  &lt;li&gt;学会用  Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。&lt;/li&gt;
  &lt;li&gt;学习使用Javascript操纵HTML元件。理解DOM和动态网页（&lt;a href=&quot;http://oreilly.com/catalog/9780596527402&quot;&gt;http://oreilly.com/catalog/9780596527402&lt;/a&gt;) 网上有免费的章节，足够用了。或参看 &lt;a href=&quot;http://www.w3school.com.cn/htmldom/index.asp&quot;&gt;DOM&lt;/a&gt; 。&lt;/li&gt;
  &lt;li&gt;学会用  Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）&lt;/li&gt;
  &lt;li&gt;在一台机器上配置&lt;a href=&quot;www.apache.org&quot;&gt;Apache &lt;/a&gt;或 &lt;a href=&quot;nginx.net&quot;&gt;Nginx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;学习&lt;a href=&quot;www.php.net&quot;&gt;PHP&lt;/a&gt;，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。&lt;/li&gt;
  &lt;li&gt;把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）&lt;/li&gt;
  &lt;li&gt;跟完一个名校的网络编程课程（例如：&lt;a href=&quot;http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php&quot;&gt;http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php&lt;/a&gt; ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上&lt;/li&gt;
  &lt;li&gt;学习一个javascript库（例如jQuery 或 ExtJS）+  Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。&lt;/li&gt;
  &lt;li&gt;HTTP: The Definitive Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)&lt;/li&gt;
  &lt;li&gt;做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）&lt;/li&gt;
  &lt;li&gt;买个域名，租个空间，做个自己的网站。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;进阶加深&quot;&gt;进阶加深&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1、 C语言和操作系统调用&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《&lt;a href=&quot;http://product.china-pub.com/197050&quot;&gt;计算机程序设计艺术&lt;/a&gt;》、《&lt;a href=&quot;http://product.china-pub.com/31701&quot;&gt;算法导论&lt;/a&gt;》和《&lt;a href=&quot;http://product.china-pub.com/209243&quot;&gt;编程珠玑&lt;/a&gt;》。&lt;/li&gt;
  &lt;li&gt;学习&lt;a href=&quot;https://coolshell.cn/articles/3723.html&quot;&gt;（麻省理工免费课程）计算机科学和编程导论&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;学习&lt;a href=&quot;https://coolshell.cn/articles/2474.html&quot;&gt;（麻省理工免费课程）C语言内存管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学习Unix/Linux系统调用（&lt;a href=&quot;http://product.china-pub.com/30181&quot;&gt;Unix高级环境编程&lt;/a&gt;），，了解系统层面的东西。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）&lt;/li&gt;
  &lt;li&gt;用fork/wait/waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。&lt;/li&gt;
  &lt;li&gt;用signal/kill/raise/alarm/pause/sigprocmask实现一个多进程间的信号量通信的程序。&lt;/li&gt;
  &lt;li&gt;学会使用gcc和gdb来编程和调试程序（参看我的《&lt;a href=&quot;blog.csdn.net/haoel/article/details/2879&quot;&gt;用gdb调试程序&lt;/a&gt;》）&lt;/li&gt;
  &lt;li&gt;学会使用makefile来编译程序。（参看我的《&lt;a href=&quot;blog.csdn.net/haoel/article/details/2886&quot;&gt;跟我一起写makefile&lt;/a&gt;》）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IPC和Socket的东西可以放到高级中来实践。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学习Windows SDK编程（&lt;a href=&quot;http://product.china-pub.com/52880&quot;&gt;Windows 程序设计 &lt;/a&gt;，&lt;a href=&quot;http://product.china-pub.com/3804&quot;&gt;MFC程序设计&lt;/a&gt;）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;写一个窗口，了解WinMain/WinProcedure，以及Windows的消息机制。&lt;/li&gt;
  &lt;li&gt;写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。&lt;/li&gt;
  &lt;li&gt;学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。&lt;/li&gt;
  &lt;li&gt;这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。&lt;/li&gt;
  &lt;li&gt;不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@&lt;a href=&quot;http://twitter.com/#!/virushuo&quot;&gt;virushuo&lt;/a&gt; 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac/iOS上学”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、学习Java&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java 的学习主要是看经典的Core Java 《&lt;a href=&quot;http://product.china-pub.com/208978&quot;&gt;Java 核心技术编程&lt;/a&gt;》和《&lt;a href=&quot;http://product.china-pub.com/34838&quot;&gt;Java编程思想&lt;/a&gt;》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）&lt;/li&gt;
  &lt;li&gt;学习JDK，学会查阅Java API Doc &lt;a href=&quot;http://download.oracle.com/javase/6/docs/api/&quot;&gt;http://download.oracle.com/javase/6/docs/api/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。&lt;/li&gt;
  &lt;li&gt;学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。&lt;/li&gt;
  &lt;li&gt;建一个Tomcat的网站，尝试一下JSP/Servlet/JDBC/MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、Web的安全与架构&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;学习HTML5，网上有很多很多教程，以前&lt;a href=&quot;https://coolshell.cn&quot;&gt;酷壳&lt;/a&gt;也介绍过很多，我在这里就不罗列了。&lt;/li&gt;
  &lt;li&gt;学习Web开发的安全问题（参考&lt;a href=&quot;https://coolshell.cn/articles/4914.html&quot;&gt;新浪微博被攻击的这个事&lt;/a&gt;，以及&lt;a href=&quot;http://guides.rubyonrails.org/security.html&quot;&gt;Ruby的这篇文章&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;学习HTTP Server的rewrite机制，Nginx的反向代理机制，&lt;a href=&quot;http://en.wikipedia.org/wiki/Fast_CGI&quot;&gt;fast-cgi&lt;/a&gt;（如：&lt;a href=&quot;http://php-fpm.org/&quot;&gt;PHP-FPM&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;学习Web的静态页面缓存技术。&lt;/li&gt;
  &lt;li&gt;学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;使用HTML5的canvas 制作一些Web动画。&lt;/li&gt;
  &lt;li&gt;尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。&lt;/li&gt;
  &lt;li&gt;把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4、学习关系型数据库&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你可以安装MSSQLServer或MySQL来学习数据库。&lt;/li&gt;
  &lt;li&gt;学习教科书里数据库设计的那几个范式，1NF，2NF，3NF，……&lt;/li&gt;
  &lt;li&gt;学习数据库的存过，触发器，视图，建索引，游标等。&lt;/li&gt;
  &lt;li&gt;学习SQL语句，明白表连接的各种概念（参看《&lt;a href=&quot;https://coolshell.cn/articles/3463.html&quot;&gt;SQL  Join的图示&lt;/a&gt;》）&lt;/li&gt;
  &lt;li&gt;学习如何优化数据库查询（参看《&lt;a href=&quot;https://coolshell.cn/articles/1846.html&quot;&gt;MySQL的优化&lt;/a&gt;》）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务&lt;/strong&gt;：设计一个论坛的数据库，至少满足3NF，使用SQL语句查询本周，本月的最新文章，评论最多的文章，最活跃用户。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5、一些开发工具&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;学会使用SVN或Git来管理程序版本。&lt;/li&gt;
  &lt;li&gt;学会使用JUnit来对Java进行单元测试。&lt;/li&gt;
  &lt;li&gt;学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《&lt;a href=&quot;http://blog.csdn.net/haoel/article/category/9200/2&quot;&gt;编程修养&lt;/a&gt;》，这样的东西你可以上网查一下，一大堆）。&lt;/li&gt;
  &lt;li&gt;推荐阅读《&lt;a href=&quot;http://product.china-pub.com/28351&quot;&gt;代码大全&lt;/a&gt;》《&lt;a href=&quot;http://product.china-pub.com/196374&quot;&gt;重构&lt;/a&gt;》《&lt;a href=&quot;http://product.china-pub.com/196266&quot;&gt;代码整洁之道&lt;/a&gt;》&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;高级深入&quot;&gt;高级深入&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1、C++ / Java 和面向对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“&lt;a href=&quot;https://coolshell.cn/articles/2287.html&quot;&gt;C++学习信心图&lt;/a&gt;” 和“&lt;a href=&quot;https://coolshell.cn/articles/2250.html&quot;&gt;21天学好C++&lt;/a&gt;”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;学习&lt;a href=&quot;https://coolshell.cn/articles/2474.html&quot;&gt;（麻省理工免费课程）C++面向对象编程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;读我的 “&lt;a href=&quot;https://coolshell.cn/articles/4119.html&quot;&gt;如何学好C++&lt;/a&gt;”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《&lt;a href=&quot;https://coolshell.cn/articles/12165.html&quot;&gt;C++虚函数表解析&lt;/a&gt;》或是《&lt;a href=&quot;https://coolshell.cn/articles/12176.html&quot;&gt;C++对象内存存局&lt;/a&gt;》，或是《&lt;a href=&quot;https://coolshell.cn/articles/12192.html&quot;&gt;C/C++返回内部静态成员的陷阱&lt;/a&gt;》那就非常不错了）&lt;/li&gt;
  &lt;li&gt;然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;用C++实现一个BigInt，支持128位的整形的加减乘除的操作。&lt;/li&gt;
  &lt;li&gt;用C++封装一个数据结构的容量，比如hash table。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用C++封装并实现一个智能指针（一定要使用模板）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;《&lt;a href=&quot;http://product.china-pub.com/25961&quot;&gt;设计模式&lt;/a&gt;》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《&lt;a href=&quot;http://product.china-pub.com/27862&quot;&gt;深入浅出设计模式&lt;/a&gt;》）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;使用工厂模式实现一个内存池。&lt;/li&gt;
  &lt;li&gt;使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。&lt;/li&gt;
  &lt;li&gt;使用命令模式实现一个命令行计算器，并支持undo和redo。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;学习STL的用法和其设计概念  – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;学习C++的一些类库的设计，如： MFC（看看候捷老师的《&lt;a href=&quot;http://product.china-pub.com/3565&quot;&gt;深入浅出MFC&lt;/a&gt;》） ，Boost, ACE,  CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《&lt;a href=&quot;http://blog.csdn.net/haoel/article/details/24058&quot;&gt;STL string类的写时拷贝技术&lt;/a&gt;》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）&lt;/li&gt;
  &lt;li&gt;Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看&lt;a href=&quot;https://coolshell.cn/articles/3320.html&quot;&gt;Java中的设计模式&lt;/a&gt;）。&lt;/li&gt;
  &lt;li&gt;推荐阅读《&lt;a href=&quot;http://product.china-pub.com/195040&quot;&gt;Effective Java&lt;/a&gt;》 and 《&lt;a href=&quot;http://product.china-pub.com/197212&quot;&gt;Java解惑&lt;/a&gt;》&lt;/li&gt;
  &lt;li&gt;学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。&lt;/li&gt;
  &lt;li&gt;Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。&lt;/li&gt;
  &lt;li&gt;学习使用Java做Web Service （&lt;a href=&quot;http://download.oracle.com/docs/cd/E17802_01/webservices/webservices/docs/2.0/tutorial/doc/&quot;&gt;官方教程在这里&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;**实践任务： **尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;深究C++（我深究C/C++了十来年了）&lt;/li&gt;
  &lt;li&gt;学习Java的各种设计模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、加强系统了解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;重要阅读下面的几本书：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《&lt;a href=&quot;http://product.china-pub.com/197413&quot;&gt;Unix编程艺术&lt;/a&gt;》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。&lt;/li&gt;
  &lt;li&gt;《&lt;a href=&quot;http://product.china-pub.com/196770&quot;&gt;Unix网络编程卷1，套接字&lt;/a&gt;》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select/poll/epoll的差别。&lt;/li&gt;
  &lt;li&gt;《&lt;a href=&quot;http://product.china-pub.com/35&quot;&gt;TCP/IP详解 卷1:协议&lt;/a&gt;》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP/IP的协议，运作原理以及如何TCP的调优。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。&lt;/li&gt;
  &lt;li&gt;写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写一个简易的HTTP服务器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;《&lt;a href=&quot;http://product.china-pub.com/196859&quot;&gt;Unix网络编程卷2，进程间通信&lt;/a&gt;》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;主要实践各种IPC进程序通信的方法。&lt;/li&gt;
  &lt;li&gt;尝试写一个管道程序，父子进程通过管道交换数据。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;学习《&lt;a href=&quot;http://product.china-pub.com/209058&quot;&gt;Windows核心编程&lt;/a&gt;》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event,  信号量，互斥量）、异步I/O，内存管理，DLL，这几大块搞精通。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。&lt;/li&gt;
  &lt;li&gt;有了多线程、多进程通信，TCP/IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;实践任务：&lt;/strong&gt;通过以上的所有知识，尝试&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I/O和网络I/O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）&lt;/li&gt;
  &lt;li&gt;了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、系统架构&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些&lt;a href=&quot;http://scholar.google.com.hk/scholar?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&amp;amp;hl=zh-CN&amp;amp;as_sdt=0&amp;amp;as_vis=1&amp;amp;oi=scholart&quot;&gt;关于负载均衡的文章&lt;/a&gt;读读）&lt;/li&gt;
  &lt;li&gt;多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN系统&lt;/a&gt; – 就近访问，内容边缘化。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Peer-to-peer&quot;&gt;P2P式系统&lt;/a&gt;，研究一下BT和电驴的算法。比如：&lt;a href=&quot;http://en.wikipedia.org/wiki/Distributed_hash_table&quot;&gt;DHT算法&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Virtualization&quot;&gt;虚拟化技术&lt;/a&gt;，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。&lt;/li&gt;
  &lt;li&gt;学习&lt;a href=&quot;http://thrift.apache.org/&quot;&gt;Thrift&lt;/a&gt;，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。&lt;/li&gt;
  &lt;li&gt;学习&lt;a href=&quot;http://hadoop.apache.org/&quot;&gt;Hadoop&lt;/a&gt;。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。&lt;/li&gt;
  &lt;li&gt;了解&lt;a href=&quot;http://en.wikipedia.org/wiki/NoSQL&quot;&gt;NoSQL数据库&lt;/a&gt;（有人说可能是一个&lt;a href=&quot;https://coolshell.cn/articles/3609.html&quot;&gt;过渡炒作的技术&lt;/a&gt;），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。&lt;strong&gt;不过，一定有漏的，也有不对的，还希望大家补充和更正&lt;/strong&gt;。（&lt;strong&gt;我会根据大家的反馈随时更新此文&lt;/strong&gt;）欢迎大家通过我的微博（&lt;a href=&quot;http://weibo.com/haoel&quot;&gt;@左耳朵耗子&lt;/a&gt;）和twitter（@&lt;a href=&quot;http://twitter.com/haoel&quot;&gt;haoel&lt;/a&gt;）和我交流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;—– 更新  2011/07/19 —–&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1）有朋友奇怪为什么我在这篇文章开头说了web+移动，却没有在后面提到iOS/Android的前端开发。因为我心里有一种感觉，移动设备上的UI最终也会被Javascript取代。大家可以用iPhone或Android看看google+，你就会明白了。&lt;/p&gt;

&lt;p&gt;2）有朋友说我这里的东西太多了，不能为了学习而学习，我非常同意。我在文章的前面也说了要思考。另外，千万不要以为我说的这些东西是一些新的技术，这份攻略里95%以上的全是基础。而且都是久经考验的基础技术。即是可以让你一通百通的技术，也是可以让你找到一份不错工作的技术。&lt;/p&gt;

&lt;p&gt;3）有朋友说学这些东西学完都40了，还不如想想怎么去挣钱。我想告诉大家，一是我今年还没有40岁，二是学无止境啊，三是我不觉得挣钱有多难，难的是怎么让你值那么多钱？无论是打工还是创业，是什么东西让你自己的价值，让你公司的价值更值钱？别的地方我不敢说，对于互联网或IT公司来说，技术实力绝对是其中之一。&lt;/p&gt;

&lt;p&gt;4）有朋友说技术都是工具，不应该如此痴迷这句话没有错，有时候我们需要更多的是抬起头来看看技术以外的事情，或者是说我们在作技术的时候不去思考为什么会有这个技术，为什么不是别的，问题不在于技术，问题在于我们死读书，读死书，成了技术的书呆子。&lt;/p&gt;

&lt;p&gt;5） 对于NoSQL，最近比较火，但我对其有点保守，所以，我只是说了解就可以。对于Hadoop，我觉得其在分布式系统上有巨大的潜力，所以需要学习。 对于关系型数据库，的确是很重要的东西，这点是我的疏忽，在原文里补充。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（全文完，转载时请注明作者和出处）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://cn.100offer.com/how-it-works/?utm_source=coolshell_cn&amp;amp;utm_medium=display&amp;amp;utm_campaign=coolshell_cn_20170918&amp;amp;utm_content=find_new_job&amp;amp;campaign_code=coolshell_cn&quot;&gt;&lt;img src=&quot;https://coolshell.cn/imgs/100offer_600_200.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://coolshell.cn//wp-content/uploads/2009/04/qrcode_for_gh_dd9d8c843f20_860-300x300.jpg&quot; alt=&quot;&quot; /&gt;
关注CoolShell微信公众账号可以在手机端搜索文章&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（转载本站文章请注明作者和出处 &lt;a href=&quot;https://coolshell.cn/&quot;&gt;酷 壳 – CoolShell&lt;/a&gt; ，请勿用于任何商业用途）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;——=== 访问 &lt;a href=&quot;http://coolshell.cn/404/&quot;&gt;酷壳404页面&lt;/a&gt; 寻找遗失儿童。 ===——&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jiathis.com/share?uid=1541368&quot;&gt;http://www.jiathis.com/share?uid=1541368&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;var jiathis_config={
	data_track_clickback:true,
	summary:””,
	hideMore:false
}&lt;/p&gt;

&lt;h3 id=&quot;相关文章&quot;&gt;相关文章&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/8088.html&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/1.jpg&quot; alt=&quot;对技术的态度&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://coolshell.cn/articles/8088.html&quot;&gt;对技术的态度&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/4102.html&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/17.jpg&quot; alt=&quot;如何学好C语言&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://coolshell.cn/articles/4102.html&quot;&gt;如何学好C语言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/17497.html&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2016/09/engineer-150x150.jpg&quot; alt=&quot;什么是工程师文化？&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://coolshell.cn/articles/17497.html&quot;&gt;什么是工程师文化？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/17583.html&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2016/12/people-150x150.jpg&quot; alt=&quot;技术人员的发展之路&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://coolshell.cn/articles/17583.html&quot;&gt;技术人员的发展之路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/12052.html&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/5.jpg&quot; alt=&quot;Leetcode 编程训练&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://coolshell.cn/articles/12052.html&quot;&gt;Leetcode 编程训练&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/11847.html&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2014/08/puzzle-150x150.png&quot; alt=&quot;谜题的答案和活动的心得体会&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;https://coolshell.cn/articles/11847.html&quot;&gt;谜题的答案和活动的心得体会&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</guid>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>DKNightVersion 源码学习</title>
        <description>&lt;h1 id=&quot;dknightversion-源码学习&quot;&gt;DKNightVersion 源码学习&lt;/h1&gt;

&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;建立一个单利存储类，存储颜色值，取颜色是根据主题取。&lt;/li&gt;
  &lt;li&gt;需要切换颜色的视图，设置颜色时，使用单例类存储视图和设置方法。&lt;/li&gt;
  &lt;li&gt;当切换颜色模板时，发出通知，遍历单利存储类的内容，修改颜色。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;学习的细节&quot;&gt;学习的细节&lt;/h3&gt;

&lt;p&gt;原理大概都是这样，关键是细节的处理。&lt;/p&gt;

</description>
        <pubDate>Wed, 08 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/11/08/DKNightVersion-SourceReading/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/08/DKNightVersion-SourceReading/</guid>
        
        <category>iOS</category>
        
        <category>源码</category>
        
        <category>内功</category>
        
        
      </item>
    
      <item>
        <title>Python编程快速上手 — 让繁琐工作自动化&lt;二&gt;</title>
        <description>&lt;h1 id=&quot;python编程快速上手--让繁琐工作自动化&quot;&gt;Python编程快速上手 — 让繁琐工作自动化&lt;/h1&gt;

&lt;h3 id=&quot;处理excel表格&quot;&gt;处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Excel&lt;/code&gt;表格&lt;/h3&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;openpyxl.load_workbook()&lt;/code&gt; 打开文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wb = openpyxl.load_workbook('python.xlsx')

# 获取所有表名的列表
wb.get_sheet_names()
# 根据名字获取列表
sheet = wb.get_sheet_by_name('Yunis000')

# A1 单元格
c = sheet['A1']

# B10 单元格
c2 = sheet.cell(row=10, column=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;从表中取得行和列&quot;&gt;从表中取得行和列&lt;/h4&gt;

&lt;p&gt;可以将 Worksheet 对象切片，取得电子表格中一行、一列或一个矩形区域中的所有 Cell 对象。然后可以循环遍历这个切片中的所有单元格&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(tuple(sheet['A1':'C3'])) #((&amp;lt;Cell 'Yunis000'.A1&amp;gt;, &amp;lt;Cell 'Yunis000'.B1&amp;gt;, &amp;lt;Cell 'Yunis000'.C1&amp;gt;), (&amp;lt;Cell 'Yunis000'.A2&amp;gt;, &amp;lt;Cell 'Yunis000'.B2&amp;gt;, &amp;lt;Cell 'Yunis000'.C2&amp;gt;), (&amp;lt;Cell 'Yunis000'.A3&amp;gt;, &amp;lt;Cell 'Yunis000'.B3&amp;gt;, &amp;lt;Cell 'Yunis000'.C3&amp;gt;))



for rowOfCellObjects in sheet['A1':'C3']:
    for cellObj in rowOfCellObjects:
        print(cellObj.coordinate, cellObj.value)
    print('--- END OF ROW ---')

# A1 111111111
# B1 None
# C1 None
# --- END OF ROW ---
# A2 None
# B2 None
# C2 None
# --- END OF ROW ---
# A3 None
# B3 None
# C3 None
# --- END OF ROW ---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cellObj.coordinate&lt;/code&gt; cell 坐标
&lt;code class=&quot;highlighter-rouge&quot;&gt;cellObj.value&lt;/code&gt; cell 值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.导入 openpyxl 模块。
2.调用 openpyxl.load_workbook()函数。
3.取得 Workbook 对象。
4.调用 get_active_sheet()或 get_sheet_by_name()工作簿方法。 
5.取得 Wor ksheet 对象。
6.使用索引或工作表的 cell()方法，带上 row 和 column 关键字参数。 
7.取得 Cell 对象。
8.读取 Cell 对象的 value 属性。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;保持时间计划任务和启动程序&quot;&gt;保持时间、计划任务和启动程序&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;time.time()函数
    &lt;ul&gt;
      &lt;li&gt;Unix 纪元是编程中经常参考的时间:1970 年 1 月 1 日 0 点，即协调世界时(UTC) ，time.time()函数返回自那一刻以来的秒数，是一个浮点值(回想一下，浮 点值只是一个带小数点的数)。这个数字称为 UNIX 纪元时间戳。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;time.sleep()函数
    &lt;ul&gt;
      &lt;li&gt;如果需要让程序暂停一下，就调用 time.sleep()函数，并传入希望程序暂停的秒数.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;round()函数
    &lt;ul&gt;
      &lt;li&gt;在处理时间时，你会经常遇到小数点后有许多数字的浮点值。为了让这些值更 易于处理，可以用 Python 内置的 round()函数将它们缩短，该函数按照指定的精度 四舍五入到一个浮点数。只要传入要舍入的数字，再加上可选的第二个参数，指明 需要传入到小数点后多少位。如果省略第二个参数，round()将数字四舍五入到最接 近的整数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;time.sleep(seconds)函数让程序暂停 seconds 参数指定的秒数。&lt;/li&gt;
  &lt;li&gt;datetime.datetime(year, month, day, hour, minute, second)函数返回参数指定的时刻的 datetime 对象。如果没有提供 hour、minute 或 second 参数，它们默认为 0。&lt;/li&gt;
  &lt;li&gt;datetime.datetime.now()函数返回当前时刻的 datetime 对象。&lt;/li&gt;
  &lt;li&gt;datetime.datetime.fromtimestamp(epoch)函数返回 epoch 时间戳参数表示的时刻的 datetime 对象&lt;/li&gt;
  &lt;li&gt;datetime.timedelta(weeks,days,hours,minutes,seconds,milliseconds, microseconds)函数返回一个表示一段时间的 timedelta 对象。该函数的关键字参数都是可选的，不包括 month 或 year。&lt;/li&gt;
  &lt;li&gt;total_seconds()方法用于 timedelta 对象，返回 timedelta 对象表示的秒数。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time

def calcProd():
    product = 1
    for i in range(1,100000):
        product = product * i
    return product

startTime = time.time()
prod = calcProd()
endTime = time.time()
print('The result is %s digits long.' % (len(str(prod))))
print('Took %s seconds to calculate.' % (endTime - startTime))
time.sleep(5)

now = time.time()
print(now) #1509609194.070355
print(round(now,2)) #1509609194.07
print(round(now,4)) #1509609194.0704

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;超级秒表&quot;&gt;超级秒表&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time

print('Press ENTER to begin. Afterwards, press ENTER to &quot;click&quot; the stopwatch. Press Ctrl-C to quit.')

input()
print('Started.')
# 开始时间
startTime = time.time()
# 结束时间
lastTime = startTime
lapNum = 1

try:
    while True:
        # 开始输入  当敲击回车键时  输入结束
        input()
        # 计算本次输入最后的时间
        lapTime = round(time.time() - lastTime, 2)
        # 计算总时间
        totalTime = round(time.time() - startTime, 2)
        print('Lap #%s: %s (%s)' % (lapNum, totalTime, lapTime), end='')
        lapNum += 1
        # 从新设置下次计时的时间
        lastTime = time.time() # reset the last lap time
except KeyboardInterrupt:
    # Handle the Ctrl-C exception to keep its error message from displaying.
    print('\nDone.')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;多线程&quot;&gt;多线程&lt;/h4&gt;

&lt;p&gt;创建一个线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import threading, time

print('Start of program.')

def takeANap():
    time.sleep(2)
    print('Wake up!')

def threadArgs(arg,arg1):
    time.sleep(3)
    print(str(arg) + '  ' + str(arg1))

threadObj = threading.Thread(target=takeANap)
threadObj.start()

threadArgs = threading.Thread(target=threadArgs,args=['Yunis','三十一'])
threadArgs.start()

print('End of program.')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;项目多线程-xkcd-下载程序&quot;&gt;项目:多线程 XKCD 下载程序&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import requests, sys, webbrowser, bs4,os,threading

# 进入同级目录下
currentFilePath = sys.path[0]
os.chdir(currentFilePath)
os.makedirs('xkcd', exist_ok=True)

def downloadXkcd(startComic, endComic):
    for urlNumber in range(startComic, endComic):
        # Download the page.
        print('Downloading page http://xkcd.com/%s...' % (urlNumber))
        res = requests.get('http://xkcd.com/%s' % (urlNumber))
        res.raise_for_status()
        soup = bs4.BeautifulSoup(res.text)
        # Find the URL of the comic image.
        comicElem = soup.select('#comic img')
        if comicElem == []:
            print('Could not find comic image.')
        else:
            comicUrl = comicElem[0].get('src')
            comicUrl = 'http:' + comicUrl
            # Download the image.
            print('Downloading image %s...' % (comicUrl))
            res = requests.get(comicUrl)
            res.raise_for_status()
            # Save the image to ./xkcd.
            imageFile = open(os.path.join('xkcd',os.path.basename(comicUrl)), 'wb')
            for chunk in res.iter_content(100000):
                imageFile.write(chunk)
            imageFile.close()


# a list of all the Thread objects
downloadThreads = []
# loops 14 times, creates 14 threads
for i in range(0, 1400, 100):
     downloadThread = threading.Thread(target=downloadXkcd, args=(i, i + 99))
     downloadThreads.append(downloadThread)
     downloadThread.start()
for downloadThread in downloadThreads:
    downloadThread.join()
print('Done.')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;从-python-启动其他程序&quot;&gt;从 Python 启动其他程序&lt;/h3&gt;

&lt;p&gt;利用内建的 subprocess 模块中的 Popen()函数，Python 程序可以启动计算机中的 其他程序(Popen()函数名中的 P 表示 process，进程)。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;subprocess.Popen(['open', '/Applications/Firefox.app/'])&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time, subprocess
print('Start')
timeLeft = 5
while timeLeft &amp;gt; 0:
    print('Left')
    print(timeLeft, end='')
    time.sleep(1)
    timeLeft = timeLeft - 1

print('Play')
subprocess.Popen(['open', '/Users/Yunis/Documents/Github/LearnPython/Python/Time/01.mp3'])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;发送电子邮件&quot;&gt;发送电子邮件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#coding: utf-8
import smtplib
from email.mime.text import MIMEText
from email.header import Header



sender = 'xxx@163.com'
receiver = 'xxx@qq.com'
subject = '大家好'
smtpserver = 'smtp.163.com'
username = 'xxx'
password = 'xxxx'

msg = MIMEText('你这是什么情况','plain','utf-8')#中文需参数‘utf-8'，单字节字符不需要
msg['Subject'] = Header(subject, 'utf-8')
msg['From'] = 'Yunis&amp;lt;yunis_song@163.com&amp;gt;'
msg['To'] = &quot;Yunis&amp;lt;332963965@qq.com&amp;gt;&quot;


try:
    smtp = smtplib.SMTP()
    smtp.connect('smtp.163.com',25)
    smtp.login(username, password)
    smtp.sendmail(sender, receiver, msg.as_string())

    print (&quot;邮件发送成功&quot;)
    smtp.quit()
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
    print (smtplib.SMTPException.message)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%BA%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/30/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%BA%8C/</guid>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>Python编程快速上手 — 让繁琐工作自动化&lt;一&gt;</title>
        <description>&lt;h1 id=&quot;python编程快速上手--让繁琐工作自动化&quot;&gt;Python编程快速上手 — 让繁琐工作自动化&lt;/h1&gt;
&lt;h3 id=&quot;基础概念&quot;&gt;基础概念&lt;/h3&gt;
&lt;h4 id=&quot;导入模块&quot;&gt;导入模块&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;import string
import random,sys,os


&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from random import *
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;使用这种形式的 import 语句，调用 random 模块中的函数时不需要 random.前缀。 但是，使用完整的名称会让代码更可读，所以最好是使用普通形式的 import 语句。&lt;/p&gt;

&lt;h4 id=&quot;声明函数&quot;&gt;声明函数&lt;/h4&gt;
&lt;h5 id=&quot;不带参数&quot;&gt;不带参数&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def Hello():
    print(&quot;----hello world.----&quot;)

Hello()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;带有参数&quot;&gt;带有参数&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;输出中文需要在开头加入&lt;code class=&quot;highlighter-rouge&quot;&gt;# -*- coding: UTF-8 -*-&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;#coding=utf-8&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def Hello(name):
    print(&quot;----hello world.----&quot; + name)

Hello(&quot;Yunis&quot;)
Hello(&quot;三十一&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;带有多个参数&quot;&gt;带有多个参数&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def Hello(name,age):
    print( name + &quot; is &quot; + str(age) + &quot; years old this year&quot;)

Hello(&quot;Yunis&quot;,18)
Hello(&quot;三十一&quot;,25)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;关键字参数-和-print&quot;&gt;关键字参数 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;print()&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  print('Hello')
  print('World')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello 
World
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;print()&lt;/code&gt;函数自动在传入的字符串末尾 添加了换行符。
可以通过 end 关键字参数，设置这个末尾。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print('Hello', end='')
print('World')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类似地，如果向 print()传入多个字符串值,该函数就会自动用一个空格分隔它们。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print('cats', 'dogs', 'mice') 
&amp;gt;&amp;gt;&amp;gt; cats dogs mice
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以传入 &lt;code class=&quot;highlighter-rouge&quot;&gt;sep&lt;/code&gt; 关键字参数，替换掉默认的分隔字符.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print('cats', 'dogs', 'mice', sep=',')
&amp;gt;&amp;gt;&amp;gt; cats,dogs,mice
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;作用域&quot;&gt;作用域&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;全局作用域中的代码不能使用任何局部变量;&lt;/li&gt;
  &lt;li&gt;但是，局部作用域可以访问全局变量;&lt;/li&gt;
  &lt;li&gt;一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量。
  ⁃	* 如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果需要在一个函数内修改全局变量，就使用 global 语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def spam():
    global eggs
    eggs = 'spam'
      
eggs = 'global'
spam()
print(eggs)//spam
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;如果变量在全局作用域中使用(即在所有函数之外)，它就总是全局变量。&lt;/li&gt;
  &lt;li&gt;如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。&lt;/li&gt;
  &lt;li&gt;否则，如果该变量用于函数中的赋值语句，它就是局部变量。&lt;/li&gt;
  &lt;li&gt;但是，如果该变量没有用在赋值语句中，它就是全局变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;异常处理&quot;&gt;异常处理&lt;/h4&gt;
&lt;p&gt;错误可以由 try 和 except 语句来处理。那些可能出错的语句被放在 try 子句中。 如果错误发生，程序执行就转到接下来的 except 子句开始处。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def spam(divideBy):
    try:
        return 42 / divideBy 
    except ZeroDivisionError:
        print('Error: Invalid argument.')
        
print(spam(2))
print(spam(12))
print(spam(1))

#Error: Invalid argument. 
#None
print(spam(0))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;列表&quot;&gt;列表&lt;/h4&gt;

&lt;h5 id=&quot;下标取值&quot;&gt;下标取值&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spam = ['cat', 'bat','dog']
print(spam[0])  #cat
print(spam[-1]) #dog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;cat&lt;/th&gt;
      &lt;th&gt;bat&lt;/th&gt;
      &lt;th&gt;dog&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;正向&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;负向&lt;/td&gt;
      &lt;td&gt;-3&lt;/td&gt;
      &lt;td&gt;-2&lt;/td&gt;
      &lt;td&gt;-1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;切片获取子列表&quot;&gt;切片获取子列表&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spam = ['cat', 'bat','dog']

print(spam[:-1])  #['cat', 'bat']
print(spam[0:-1]) #['cat', 'bat']
print(spam[0:1])  #['cat']
print(spam[:1])   #['cat']
print(spam[0:2])  #['cat', 'bat']
print(spam[0:3])  #['cat', 'bat', 'dog']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;列表链接复制&quot;&gt;列表链接、复制&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 操作符可以连接两个列表，得到一个新列表。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spam = ['cat', 'bat','dog'] + [1,2,3]
print(spam)  #['cat', 'bat', 'dog', 1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;多重赋值技巧&quot;&gt;多重赋值技巧&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spam = ['cat', 'bat','dog']
x,y,z = spam
print(x)  #cat
print(y)  #bat
print(z)  #dog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;元组-字符串-列表--转换&quot;&gt;元组 、字符串 、列表  转换&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; tuple(['cat', 'dog', 5]) 
 ('cat', 'dog', 5)
&amp;gt;&amp;gt;&amp;gt; list(('cat', 'dog', 5)) 
 ['cat', 'dog', 5]
&amp;gt;&amp;gt;&amp;gt; list('hello')
['h', 'e', 'l', 'l', 'o']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自动化任务&quot;&gt;自动化任务&lt;/h3&gt;

&lt;h4 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h4&gt;
&lt;p&gt;Python 中所有正则表达式的函数都在 re 模块中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 匹配0次或者一次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 匹配0次或者多次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 匹配1次或者多次&lt;/li&gt;
  &lt;li&gt;{n}匹配 n 次前面的分组。&lt;/li&gt;
  &lt;li&gt;{n,}匹配 n 次或更多前面的分组。&lt;/li&gt;
  &lt;li&gt;{,m}匹配零次到 m 次前面的分组。&lt;/li&gt;
  &lt;li&gt;{n,m}匹配至少 n 次、至多 m 次前面的分组。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n,m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;*?&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;+?&lt;/code&gt;对前面的分组进行非贪心匹配。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^spam&lt;/code&gt; 意味着字符串必须以 spam 开始。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spam$&lt;/code&gt;意味着字符串必须以 spam 结束。&lt;/li&gt;
  &lt;li&gt;.匹配所有字符，换行符除外。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\d&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\w&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;\s&lt;/code&gt; 分别匹配数字、单词和空格。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\D&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\W &lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;\S&lt;/code&gt; 分别匹配出数字、单词和空格外的所有字符。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[abc]&lt;/code&gt;匹配方括号内的任意字符(诸如 a、b 或 c)。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[^abc]&lt;/code&gt;匹配不在方括号内的任意字符。
    &lt;h5 id=&quot;用-sub方法替换字符串&quot;&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sub()&lt;/code&gt;方法替换字符串&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; namesRegex = re.compile(r'Agent \w+')
&amp;gt;&amp;gt;&amp;gt; namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.') 

'CENSORED gave the secret documents to CENSORED.'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候，你可能需要使用匹配的文本本身，作为替换的一部分。在 sub()的第一 个参数中，可以输入\1、\2、\3……。表示“在替换中输入分组 1、2、3……的文本”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; agentNamesRegex = re.compile(r'Agent (\w)\w*')
&amp;gt;&amp;gt;&amp;gt; agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')

A**** told C**** that E**** knew B**** was a double agent.'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;读写文件&quot;&gt;读写文件&lt;/h4&gt;
&lt;h5 id=&quot;文件及文件路径&quot;&gt;文件及文件路径&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;相对路径：相对于程序的当前工作目录。&lt;/li&gt;
  &lt;li&gt;绝对路径：总是从根文件开始。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;os.makedirs()&lt;/code&gt; 创建文件夹&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用 os.path.abspath(path)将返回参数的绝对路径的字符串。这是将相对路径转 换为绝对路径的简便方法。&lt;/li&gt;
  &lt;li&gt;调用 os.path.isabs(path)，如果参数是一个绝对路径，就返回 True，如果参数是 一个相对路径，就返回 False。&lt;/li&gt;
  &lt;li&gt;调用 os.path.relpath(path, start)将返回从 start 路径到 path 的相对路径的字符串。 如果没有提供 start，就使用当前工作目录作为开始路径。&lt;/li&gt;
  &lt;li&gt;调用 os.path.getsize(path)将返回 path 参数中文件的字节数。&lt;/li&gt;
  &lt;li&gt;调用 os.listdir(path)将返回文件名字符串的列表，包含 path 参数中的每个文件 (请注意，这个函数在 os 模块中，而不是 os.path)。&lt;/li&gt;
  &lt;li&gt;检查路径有效性
    &lt;ul&gt;
      &lt;li&gt;如果 path 参数所指的文件或文件夹存在，调用 os.path.exists(path)将返回 True， 否则返回 False&lt;/li&gt;
      &lt;li&gt;如果 path 参数存在，并且是一个文件，调用 os.path.isfile(path)将返回 True，否 则返回 False&lt;/li&gt;
      &lt;li&gt;如果 path 参数存在，并且是一个文件夹，调用 os.path.isdir(path)将返回 True， 否则返回 False。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===
在 Python 中，读写文件有 3 个步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt; 函数，返回一个 File 对象。&lt;/li&gt;
  &lt;li&gt;调用 File 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;方法。&lt;/li&gt;
  &lt;li&gt;调用 File 对象的&lt;code class=&quot;highlighter-rouge&quot;&gt; close()&lt;/code&gt;方法，关闭该文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helloFile = open('/Users/your_home_folder/hello.txt')

读文件
helloContent = helloFile.read()

写文件
baconFile = open('bacon.txt', 'w')
baconFile.write('Hello world!\n')
baconFile.close()




&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;项目-生成随机试卷及答案&quot;&gt;项目： 生成随机试卷及答案&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;创建35个试卷文件及对应的答案文件。&lt;/li&gt;
  &lt;li&gt;为每一个试卷随机生成50道题目，次序随机。&lt;/li&gt;
  &lt;li&gt;为每一个问题提供一个正确答案和三个错误答案，次序随机。&lt;/li&gt;
  &lt;li&gt;将测试题目写入试卷文件，将对应的答案写入相应的答案文件中。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import random
import os

# 进入工作目录
os.chdir('/Users/Yunis/Desktop/学习/Python/random')
# 打印当前工作目录
print(&quot;当前工作目录为 %s&quot;%(os.getcwd()))

# 首都以及首都集合字典 习题集及答案
capitals = {'Alabama': 'Montgomery', 'Alaska': 'Juneau', 'Arizona': 'Phoenix','Arkansas': 'Little Rock', 'California': 'Sacramento', 'Colorado': 'Denver', 'Connecticut': 'Hartford', 'Delaware': 'Dover', 'Florida': 'Tallahassee', 'Georgia': 'Atlanta', 'Hawaii': 'Honolulu', 'Idaho': 'Boise', 'Illinois': 'Springfield', 'Indiana': 'Indianapolis', 'Iowa': 'Des Moines', 'Kansas': 'Topeka', 'Kentucky': 'Frankfort', 'Louisiana': 'Baton Rouge', 'Maine': 'Augusta', 'Maryland': 'Annapolis', 'Massachusetts': 'Boston', 'Michigan': 'Lansing', 'Minnesota': 'Saint Paul', 'Mississippi': 'Jackson', 'Missouri': 'Jefferson City', 'Montana': 'Helena', 'Nebraska': 'Lincoln', 'Nevada': 'Carson City', 'New Hampshire': 'Concord', 'New Jersey': 'Trenton', 'New Mexico': 'Santa Fe', 'New York': 'Albany', 'North Carolina': 'Raleigh',
'North Dakota': 'Bismarck', 'Ohio': 'Columbus', 'Oklahoma': 'Oklahoma City', 'Oregon': 'Salem', 'Pennsylvania': 'Harrisburg', 'Rhode Island': 'Providence', 'South Carolina': 'Columbia', 'South Dakota': 'Pierre', 'Tennessee': 'Nashville', 'Texas': 'Austin', 'Utah': 'Salt Lake City', 'Vermont': 'Montpelier', 'Virginia': 'Richmond', 'Washington': 'Olympia', 'West Virginia': 'Charleston', 'Wisconsin': 'Madison', 'Wyoming': 'Cheyenne'}

# 循环35次 因为要出35分试卷
for quizNum in range(35):
    quizFile = open('capitalsquiz%s.txt' % (quizNum + 1), 'w')
    answerKeyFile = open('capitalsquiz_answers%s.txt' % (quizNum + 1), 'w')
    quizFile.write('Name:\n\nDate:\n\nPeriod:\n\n')
    quizFile.write((' ' * 20) + 'State Capitals Quiz (Form %s)' % (quizNum + 1))
    quizFile.write('\n\n')
    # 获取字典 keys
    states = list(capitals.keys())
    # 用于将一个列表中的元素打乱。
    random.shuffle(states)

    # 每份试卷有50道题目
    for questionNum in range(50):
        # Get right and wrong answers.
        correctAnswer = capitals[states[questionNum]]
        # 获取答案列表
        wrongAnswers = list(capitals.values())
        # 删除正确的答案选项
        del wrongAnswers[wrongAnswers.index(correctAnswer)]
        # 从错误的答案选项随机选出3个错误的答案
        wrongAnswers = random.sample(wrongAnswers, 3)
        # 给当前题目设置答案集合
        answerOptions = wrongAnswers + [correctAnswer]
        # 打乱 答案顺序
        random.shuffle(answerOptions)
        # 在试卷文件 写入 题号 以及题目
        quizFile.write('%s. What is the capital of %s?\n' % (questionNum + 1,states[questionNum]))
        # 在试卷文件 写入答案选项
        for i in range(4):
            quizFile.write(' %s. %s\n' % ('ABCD'[i], answerOptions[i]))
        quizFile.write('\n')
        # 把正确答案的题号以及正确答案写入答案文件
        answerKeyFile.write('%s. %s\n' % (questionNum + 1, 'ABCD'[
        answerOptions.index(correctAnswer)]))

    # 关闭试卷文件
    quizFile.close()
    # 关闭答案文件
    answerKeyFile.close()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;项目-多重剪贴板&quot;&gt;项目： 多重剪贴板&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.pyw&lt;/code&gt; 扩展名意味着 Python 运行该程序时，不会显示终端窗口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
# mcb.pyw - Saves and loads pieces of text to the clipboard.
#  Usage: py.exe mcb.pyw save &amp;lt;keyword&amp;gt; - Saves clipboard to keyword.
#         py.exe mcb.pyw &amp;lt;keyword&amp;gt; - Loads keyword to clipboard.
#         py.exe mcb.pyw list - Loads all keywords to clipboard.
import shelve, pyperclip, sys
# .pyw 扩展名意味着 Python 运行该程序时，不会显示终端窗口

# 进入工作目录
os.chdir('/Users/Yunis/Desktop/学习/Python/mcb')
# 打印当前工作目录
print(&quot;当前工作目录为 %s&quot;%(os.getcwd()))

# shelve是一额简单的数据存储方案，他只有一个函数就是open()，这个函数接收一个参数就是文件名，然后返回一个shelf对象，你可以用他来存储东西，就可以简单的把他当作一个字典，当你存储完毕的时候，就调用close函数来关闭

# 建立一个存储容器
mcbShelf = shelve.open('mcb')

# 判断参数有几个，
if len(sys.argv) == 3:
    # 判断第2个参数是否为save
    if sys.argv[1].lower() == 'save' :
        # 把粘贴板的值保存在 mcbShelf
        mcbShelf[sys.argv[2]] = pyperclip.paste()
    elif  sys.argv[1].lower() == 'del' :
        # 删除关键字对应的值
        mcbShelf.pop(sys.argv[2])
elif len(sys.argv) == 2:
    if sys.argv[1].lower() == 'list':
        # 把容器中保存的key 填充到粘贴板
        pyperclip.copy(str(list(mcbShelf.keys())))
    elif sys.argv[1] in mcbShelf:
        # 根据传的参数，把容器中对应key的值取出来放置在粘贴板中
        pyperclip.copy(mcbShelf[sys.argv[1]])
# 关闭
mcbShelf.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;组织文件&quot;&gt;组织文件&lt;/h4&gt;
&lt;h5 id=&quot;shutil-模块&quot;&gt;shutil 模块&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;shutil.copy(source, destination)
    &lt;ol&gt;
      &lt;li&gt;将路径 source 处的文件复制到路径 destination 处的文件夹(source 和 destination 都是字符串)&lt;/li&gt;
      &lt;li&gt;如果 destination 是一个文件名，它将 作为被复制文件的新名字。&lt;/li&gt;
      &lt;li&gt;该函数返回一个字符串，表示被复制文件的路径。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;shutil.copytree(source, destination)
    &lt;ol&gt;
      &lt;li&gt;将路径source处的文件 夹，包括它的所有文件和子文件夹，复制到路径 destination 处的文件夹。&lt;/li&gt;
      &lt;li&gt;source 和 destination 参数都是字符串。&lt;/li&gt;
      &lt;li&gt;该函数返回一个字符串，是新复制的文件夹的路径。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;shutil.move(source, destination)
    &lt;ol&gt;
      &lt;li&gt;将路径 source 处的文件夹移动到路径 destination，并返回新位置的绝对路径的字符串。&lt;/li&gt;
      &lt;li&gt;如果 destination 指向一个文件夹，source 文件将移动到 destination 中，并保持 原来的文件名。&lt;/li&gt;
      &lt;li&gt;destination 路径也可以指定一个文件名。source 文件被移动 并改名。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;用 os.unlink(path)将删除 path 处的文件。&lt;/li&gt;
  &lt;li&gt;调用 os.rmdir(path)将删除 path 处的文件夹。该文件夹必须为空，其中没有任
何文件和文件夹。&lt;/li&gt;
  &lt;li&gt;调用 shutil.rmtree(path)将删除 path 处的文件夹，它包含的所有文件和文件夹都会被删除。&lt;/li&gt;
  &lt;li&gt;os.walk()函数 被传入一个字符串值，即一个文件夹的路径。你可以在一个 for 循环语句中使用 os.walk()函数，遍历目录树，就像使用 range()函数遍历一个范围的 数字一样。
    &lt;ol&gt;
      &lt;li&gt;当前文件夹名称的字符串。&lt;/li&gt;
      &lt;li&gt;当前文件夹中子文件夹的字符串的列表。&lt;/li&gt;
      &lt;li&gt;当前文件夹中文件的字符串的列表。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import os
for folderName, subfolders, filenames in os.walk('/Users/Yunis/Desktop/学习/Python'):
    print('The current folder is ' + folderName)
    for subfolder in subfolders:
        print('SUBFOLDER OF ' + folderName + ': ' + subfolder)
    for filename in filenames:
        print('FILE INSIDE ' + folderName + ': '+ filename)
    print('')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;zipfile-模块&quot;&gt;zipfile 模块&lt;/h5&gt;

&lt;h6 id=&quot;读取-zip-文件&quot;&gt;读取 ZIP 文件&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;# -*- coding: UTF-8 -*-
import os,zipfile

os.chdir('/Users/Yunis/Desktop/学习/Python/zipfile')
exampleZip = zipfile.ZipFile('t.txt.zip')
# 获取压缩文件集合
print(exampleZip.namelist())
# 获取指定文件信息
spamInfo = exampleZip.getinfo('t.txt')
# 文件真实大小
print(spamInfo.file_size)
# 文件压缩后的大小
print(spamInfo.compress_size)
exampleZip.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;从-zip-文件中解压缩&quot;&gt;从 ZIP 文件中解压缩&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;extractall()
    &lt;ul&gt;
      &lt;li&gt;extractall()方法从 ZIP 文件中解压缩所有文件和文件夹&lt;/li&gt;
      &lt;li&gt;可以向 extractall()传递的一个文件夹名称，它将文件解压缩到那个文件夹，而不是当前工作 目录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;extract()
    &lt;ul&gt;
      &lt;li&gt;extract()方法从 ZIP 文件中解压缩单个文件&lt;/li&gt;
      &lt;li&gt;传递给 extract()的字符串，必须匹配 namelist()返回的字符串列表中的一个。&lt;/li&gt;
      &lt;li&gt;extract()传递第二个参数，将文件解压缩到指定的文件夹，而不是当 前工作目录。如果第二个参数指定的文件夹不存在，Python 就会创建它。&lt;/li&gt;
      &lt;li&gt;extract() 的返回值是被压缩后文件的绝对路径。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import os,zipfile
os.chdir('/Users/Yunis/Desktop/学习/Python/zipfile')
exampleZip = zipfile.ZipFile('t.txt.zip')
# 解压缩所用文件和文件夹 'Yunis' 为路径参数，表示解压缩到这个路径，参数为空表示解压缩到当前路径
# exampleZip.extractall('Yunis')
# 解压缩 单个't.txt' 文件到 'SSY' 路径下，路径为空解压到当前路径
exampleZip.extract('t.txt','SSY')
exampleZip.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;创建和添加到-zip-文件&quot;&gt;创建和添加到 ZIP 文件&lt;/h5&gt;

&lt;p&gt;要创建你自己的压缩 ZIP 文件，必须以“写模式”打开 ZipFile 对象，即传入’w’ 作为第二个参数(这类似于向 open()函数传入’w’，以写模式打开一个文本文件)。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exampleZip = zipfile.ZipFile('t.txt.zip','w')&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import os,zipfile
os.chdir('/Users/Yunis/Desktop/学习/Python/zipfile')
# 创建压缩文件
newZip = zipfile.ZipFile('new.zip','w')
# 把 t.txt 文件 写入 压缩文件内 compress_type ：压缩方式
newZip.write('t.txt', compress_type=zipfile.ZIP_DEFLATED)
newZip.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;将带有美国风格日期的文件改名为欧洲风格日期&quot;&gt;将带有美国风格日期的文件改名为欧洲风格日期&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import shutil,os,re

def renameDatesInpath(path):
    # 获取文件路径下的文件集合
    # print(path)
    # 创建正则表达式
    datePattern = re.compile(r'^(.*?)((0|1)\d)-((0|1|2|3)\d)-((19|20)\d\d)(.*?)$')

    # 获取文件路径下的文件集合
    for amerFilename in os.listdir(path):
        # 正则表达式对象匹配结果
        # Regex 对象的 search()方法查找传入的字符串，寻找该正则表达式的所有匹配。如 果字符串中没有找到该正则表达式模式，search()方法将返回 None。如果找到了该模式， search()方法将返回一个 Match 对象。Match 对象有一个 group()方法，它返回被查找字 符串中实际匹配的文本
        mo = datePattern.search(amerFilename)
        # 如果这个文件没有匹配，开始匹配下个文件
        if mo == None :
            continue
        # re.compile(r'^(.*?)((0|1)\d)-((0|1|2|3)\d)-((19|20)\d\d)(.*?)$')
        # group index
        # datePattern = re.compile(r'^(1)((2)3)-((4)5)-((6)7)(8)$')

        # 获取 Match 对象 对应的字符串
        beforePart = mo.group(1)
        monthPart = mo.group(2)
        dayPart = mo.group(4)
        yearPart = mo.group(6)
        afterPart = mo.group(8)
        # 组成新的文件名
        euroFilename = beforePart + dayPart + '-' + monthPart + '-' + yearPart + afterPart


        absWorkingDir = os.path.abspath(path)
        amerFilename = os.path.join(absWorkingDir, amerFilename)
        euroFilename = os.path.join(absWorkingDir, euroFilename)
        print('Renaming &quot;%s&quot; to &quot;%s&quot;...' % (amerFilename, euroFilename))
        shutil.move(amerFilename, euroFilename) # uncomment after testing

renameDatesInpath('/Users/Yunis/Desktop/学习/Python/date')

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;从-web-抓取信息&quot;&gt;从 Web 抓取信息&lt;/h4&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;requests&lt;/code&gt; 下载文件，并保存到硬盘。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用 requests.get()下载该文件。&lt;/li&gt;
  &lt;li&gt;用’wb’调用 open()，以写二进制的方式打开一个新文件。&lt;/li&gt;
  &lt;li&gt;利用 Respose 对象的 iter_content()方法做循环。&lt;/li&gt;
  &lt;li&gt;在每次迭代中调用 write()，将内容写入该文件。&lt;/li&gt;
  &lt;li&gt;调用 close()关闭该文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: UTF-8 -*-
import requests,os,sys

currentFilePath = sys.path[0]
webFilePath = os.path.join(currentFilePath, &quot;file&quot;)
os.chdir(webFilePath)
print(os.getcwd())
res = requests.get(&quot;http://static.open-open.com/lib/uploadImg/20160623/20160623173015_416.png&quot;)
playFile = open('python.jpg', 'wb')
for chunk in res.iter_content(100000):
    playFile.write(chunk)
playFile.close()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;用-beautifulsoup-模块解析-html&quot;&gt;用 BeautifulSoup 模块解析 HTML&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;传递给 select()方法的选择器&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;将匹配…&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('div')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有名为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('#author')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; 属性为 &lt;code class=&quot;highlighter-rouge&quot;&gt;author&lt;/code&gt; 的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('.notice')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CSS class&lt;/code&gt; 属性名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;notice&lt;/code&gt; 的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('div span')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素之内的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('div &amp;gt; span')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有直接在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素之内的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素，中间没有其他元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('input[name]')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有名为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt;，并有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; 属性，其值无所谓的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;soup.select('input[type=&quot;button&quot;]')&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;所有名为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt;，并有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt; 属性，其值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt; 的元素&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这段代码将带有 id=&quot;author&quot;的元素，从示例 HTML 中找出来

elems = exampleSoup.select('#author')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;im-feeling-lucky-百度-查找&quot;&gt;“I’m Feeling Lucky” 百度 查找&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://yunissong.github.io/2017/10/26/Python%E5%B0%8F%E5%B7%A5%E5%85%B7-%E6%A0%B9%E6%8D%AE%E8%BE%93%E5%85%A5%E5%85%B3%E9%94%AE%E5%AD%97%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E7%AC%AC%E4%B8%80%E9%A1%B5/&quot;&gt;Python小工具-根据输入关键字自动打开百度搜索结果的第一页&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;项目下载所有-xkcd-漫画&quot;&gt;项目:下载所有 XKCD 漫画&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://yunissong.github.io/2017/10/27/Python%E5%B0%8F%E5%B7%A5%E5%85%B7-%E4%B8%8B%E8%BD%BD%E6%89%80%E6%9C%89XKCD%E6%BC%AB%E7%94%BB/&quot;&gt;下载所有 XKCD 漫画&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/29/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/29/Python%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%B8%80/</guid>
        
        <category>Python</category>
        
        
      </item>
    
  </channel>
</rss>
