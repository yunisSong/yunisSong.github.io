---
layout:     post
title:      Python编程快速上手 — 让繁琐工作自动化
subtitle:   在不断填坑中前进。。
date:       2017-10-12
author:     三十一
header-img: img/post-bg-nextgen-web-pwa.jpg
header-mask: 0.3
catalog:    true
tags:
   - Python
---

# Python编程快速上手 — 让繁琐工作自动化
### 基础概念
#### 导入模块

```Python
import string
import random,sys,os


```

```
from random import *
```
使用这种形式的 import 语句，调用 random 模块中的函数时不需要 random.前缀。 但是，使用完整的名称会让代码更可读，所以最好是使用普通形式的 import 语句。


#### 声明函数
##### 不带参数

```
def Hello():
    print("----hello world.----")

Hello()
```

##### 带有参数
>输出中文需要在开头加入`# -*- coding: UTF-8 -*-` 或者 `#coding=utf-8`

```
def Hello(name):
    print("----hello world.----" + name)

Hello("Yunis")
Hello("三十一")
```

##### 带有多个参数

```
def Hello(name,age):
    print( name + " is " + str(age) + " years old this year")

Hello("Yunis",18)
Hello("三十一",25)
```

#### 关键字参数 和 `print()`


```
  print('Hello')  print('World')
```

输出为：

```
Hello 
World
```

这是因为 `print()`函数自动在传入的字符串末尾 添加了换行符。
可以通过 end 关键字参数，设置这个末尾。


```
print('Hello', end='')print('World')
```

输出为：

```
HelloWorld
```

类似地，如果向 print()传入多个字符串值,该函数就会自动用一个空格分隔它们。

```
>>> print('cats', 'dogs', 'mice') 
>>> cats dogs mice
```

可以传入 `sep` 关键字参数，替换掉默认的分隔字符.

```
>>> print('cats', 'dogs', 'mice', sep=',')
>>> cats,dogs,mice
```

#### 作用域

* 全局作用域中的代码不能使用任何局部变量;* 但是，局部作用域可以访问全局变量;* 一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量。* 如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。

如果需要在一个函数内修改全局变量，就使用 global 语句。

```Python
def spam():    global eggs    eggs = 'spam'      
eggs = 'global'spam()print(eggs)//spam
```

1. 如果变量在全局作用域中使用(即在所有函数之外)，它就总是全局变量。 
2. 如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。 
3. 否则，如果该变量用于函数中的赋值语句，它就是局部变量。 
4. 但是，如果该变量没有用在赋值语句中，它就是全局变量。


#### 异常处理
错误可以由 try 和 except 语句来处理。那些可能出错的语句被放在 try 子句中。 如果错误发生，程序执行就转到接下来的 except 子句开始处。

```Python
def spam(divideBy):    try:        return 42 / divideBy 
    except ZeroDivisionError:        print('Error: Invalid argument.')
        print(spam(2))print(spam(12))print(spam(1))

#Error: Invalid argument. 
#Noneprint(spam(0))
```

#### 列表

##### 下标取值
```
spam = ['cat', 'bat','dog']
print(spam[0])  #cat
print(spam[-1]) #dog
```

|| cat | bat | dog |
|---| --- | --- | --- |
|正向| 0 | 1 | 2 |
|负向| -3 | -2 | -1 |


##### 切片获取子列表

```
spam = ['cat', 'bat','dog']

print(spam[:-1])  #['cat', 'bat']
print(spam[0:-1]) #['cat', 'bat']
print(spam[0:1])  #['cat']
print(spam[:1])   #['cat']
print(spam[0:2])  #['cat', 'bat']
print(spam[0:3])  #['cat', 'bat', 'dog']
```

##### 列表链接、复制
`+` 操作符可以连接两个列表，得到一个新列表。

```
spam = ['cat', 'bat','dog'] + [1,2,3]
print(spam)  #['cat', 'bat', 'dog', 1, 2, 3]
```
##### 多重赋值技巧


```
spam = ['cat', 'bat','dog']
x,y,z = spam
print(x)  #cat
print(y)  #bat
print(z)  #dog
```


##### 元组 、字符串 、列表  转换


```
>>> tuple(['cat', 'dog', 5]) 
 ('cat', 'dog', 5)>>> list(('cat', 'dog', 5)) 
 ['cat', 'dog', 5]>>> list('hello')['h', 'e', 'l', 'l', 'o']
```

### 自动化任务


#### 正则表达式
Python 中所有正则表达式的函数都在 re 模块中。

* `?` 匹配0次或者一次
* `*` 匹配0次或者多次
* `+` 匹配1次或者多次
* {n}匹配 n 次前面的分组。* {n,}匹配 n 次或更多前面的分组。* {,m}匹配零次到 m 次前面的分组。* {n,m}匹配至少 n 次、至多 m 次前面的分组。* `{n,m}?`或`*?`或`+?`对前面的分组进行非贪心匹配。* `^spam` 意味着字符串必须以 spam 开始。* `spam$`意味着字符串必须以 spam 结束。* .匹配所有字符，换行符除外。* `\d`、`\w` 和`\s` 分别匹配数字、单词和空格。* `\D`、`\W `和`\S` 分别匹配出数字、单词和空格外的所有字符。* `[abc]`匹配方括号内的任意字符(诸如 a、b 或 c)。* `[^abc]`匹配不在方括号内的任意字符。
##### 用 `sub()`方法替换字符串


```Python
>>> namesRegex = re.compile(r'Agent \w+')>>> namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.') 

'CENSORED gave the secret documents to CENSORED.'
```


有时候，你可能需要使用匹配的文本本身，作为替换的一部分。在 sub()的第一 个参数中，可以输入\1、\2、\3......。表示“在替换中输入分组 1、2、3......的文本”。

```>>> agentNamesRegex = re.compile(r'Agent (\w)\w*')>>> agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')
A**** told C**** that E**** knew B**** was a double agent.'
```

