<p>#swift 学习（4）</p>

<h6 id="1闭包-closure">1，闭包 （Closure）</h6>

<blockquote>
  <p>Closures are so named because they have the ability to “close over” the variables and constants within the closure’s own scope. This simply means that a closure can access, store and manipulate the value of any variable or constant from the surrounding context. Variables and constants within the body of a closure are said to have been captured by the closure.</p>
</blockquote>

<p>闭包可以理解为是一个没有方法名的方法。形状类似于：</p>

<blockquote>
  <p>(parameterList) -&gt; returnType</p>
</blockquote>

<blockquote>
  <p>(参数列表) -&gt; 返回值类型</p>
</blockquote>

<p><strong>如何创建</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>var multiplyClosure: (Int, Int) -&gt; Int

multiplyClosure = { (a: Int, b: Int) -&gt; Int in
    return a * b
}

multiplyClosure = { (a, b) in
    a*b
}

multiplyClosure = {
    $0 * $1
}
let result = multiplyClosure(3, 2)
print(result)

</code></pre>
</div>

<p><strong>尾随闭包</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>func operateOnNumbers(_ a: Int, _ b: Int,
                      operation: (Int, Int) -&gt; Int) -&gt; Int {
    let result = operation(a, b)
    print(result)
    return result
}
//正常调用
operateOnNumbers(2, 21, operation: {
    (a:Int,b:Int) -&gt;Int in a * b
})
//正常调用
operateOnNumbers(2, 21, operation: multiplyClosure)

//尾随闭包 带参数实现
operateOnNumbers(2, 21){ (a:Int,b:Int) -&gt; Int in
    a * b
}
//尾随闭包
operateOnNumbers(2, 21){
    $0 * $1
}
</code></pre>
</div>

<p><strong>使用闭包进行自定义排序</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>
let names = ["ZZZZZZ", "BB", "A", "CCCcccccccC", "EEEEE"]
//基本用法
names.sorted()

//自定义排序算法
names.sorted {
    $0.characters.count &gt; $1.characters.count
}
</code></pre>
</div>

<p>sorted 函数</p>

<div class="highlighter-rouge"><pre class="highlight"><code> public func sorted(by areInIncreasingOrder: (Element, Element) -&gt; Bool) -&gt; [Element]
</code></pre>
</div>

<p><strong>其中(Element, Element) -&gt; Bool 闭包</strong></p>

<p>swift中大量的使用了这种闭包的语法，可以使开发人员方便的自定义方法。</p>

<p><strong>使用闭包进行迭代</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>var prices = [1.5, 10, 4.99, 2.30, 8.19]

let largePrices = prices.filter { (a) -&gt; Bool in
    a &gt; 5
}
let largePrices01 = prices.filter {
    return $0 &gt; 5
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>public func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; [Element]

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>let listArray = ["你好,","我是","你的","益达"];
let nomal0 = listArray.reduce("", {(a : String,b : String) -&gt; String in return a + b})
print("nomal0 = \(nomal0)")

let nomal1 = listArray.reduce("", {(a : String,b : String) -&gt; String in a + b})
print("nomal1 = \(nomal1)")

let nomal2 = listArray.reduce("", {(a,b) in a + b})
print("nomal2 = \(nomal2)")

let nomal3 = listArray.reduce("") {
    (a,b) in a + b
}
print("nomal3 = \(nomal3)")
let nomal4 = listArray.reduce("") {
    $0 + $1
}
print("nomal4 = \(nomal4)")
</code></pre>
</div>

<p><em>上述方法结果一样。</em></p>

<div class="highlighter-rouge"><pre class="highlight"><code>let namesAndAges = ["Yunis":28,"Yunlia":18,"Tom":13,"Jack":8,"King":15]
let lessThan18 = namesAndAges.filter {
    return $0.value &lt; 18
}
print(lessThan18)//[("Jack", 8), ("Tom", 13), ("King", 15)]

let namesList = lessThan18.map {
    return $0.key
}
print(namesList)//["Jack", "Tom", "King"]
</code></pre>
</div>

