<p>#swift 学习（8）Class</p>

<h6 id="reference-types"><strong>Reference types</strong></h6>
<p>Struts 是值类型  class 是引用类型
类不会提供自动自动初始化方法，需要自己实现。
类里面的存储类型必须在初始化方法结束之前完成赋值。</p>
<blockquote>
  <p>In Swift, a structure is an immutable value. A class, on the other hand, is a mutable reference.
在swift中 Struts 是一个不可变的值，Class是可变的引用。</p>
</blockquote>

<p>struct 的赋值是copy  class的赋值是指针指向的。具体见下方代码。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
class Person {
    var name : String
    init(_ name : String) {
        self.name = name
    }
}
var t1 = Person.init("Yunis")
var t2 = t1
print(t1.name)//Yunis
print(t2.name)//Yunis
t1.name = "Change"
print(t1.name)//Change
print(t2.name)//Change


struct Contact {
    var name: String
}
var t3 = Contact.init(name: "Yunis")
var t4 = t3
print(t3.name)//Yunis
print(t4.name)//Yunis
t3.name = "Change"
print(t3.name)//Change
print(t4.name)//Yunis
</code></pre>
</div>

<h6 id="堆和栈区别-the-heap-vs-the-stack"><strong>堆和栈区别 The heap vs. the stack</strong></h6>
<blockquote>
  <p>The system uses the stack to store anything on the immediate thread of execution; it is tightly managed and optimized by the CPU. When a function creates a variable, the stack stores that variable and then destroys it when the function exits. Since the stack is so well organized, it’s very efficient, and thus quite fast.
系统使用栈来存储在执行的即时线程上的任何东西;它由CPU严格管理和优化。当函数创建一个变量时，堆栈存储该变量，然后在函数退出时将其销毁。由于栈是如此良好的组织，它是非常高效的，因此相当快。</p>
</blockquote>

<blockquote>
  <p>The system uses the heap to store data referenced by other objects. The heap is generally a large pool of memory from which the system can request and dynamically allocate blocks of memory. The heap doesn’t automatically destroy its objects like the stack does; additional work is required to do that. This makes creating and removing data on the heap a slower process, compared to on the stack.
系统使用堆来存储其他对象引用的数据。堆通常是一个大的内存池，系统可以从内存池中请求和动态分配内存块。堆不会像堆栈那样自动破坏它的对象;需要额外的工作来做到这一点。相比与堆栈，创建和删除堆上的数据是一个较慢的过程。</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>class Person {
    var name : String
    var lastName : String
    init(_ name : String,_ lastName : String) {
        self.name = name
        self.lastName = lastName
    }
    var FullName : String {
        return"\(name) \(lastName)"
    }
    
}

var variable = Person.init("Yunis","Last")
</code></pre>
</div>
<p><img src="/media/14882645981379/14882717990005.jpg" alt="" /></p>

<blockquote>
  <p>When you create an instance of a class, your code requests a block of memory on the heap to store the instance itself; that’s the first name and last name inside the instance on the right side of the diagram. It stores the address of that memory in your named variable on the stack; that’s the reference stored on the left side of the diagram.</p>

  <p>当你创建一个类的实例的时间，会向系统申请在堆上的一块内存用来存储类的实例，包括name 和 lastName。同时在栈上存储内存地址。</p>
</blockquote>

<h6 id="object-identity"><strong>Object identity</strong></h6>

<div class="highlighter-rouge"><pre class="highlight"><code>
var t1 = Person.init("Yunis","Last")
var t2 = t1
var t3 = Person.init("Yunis","Last")

t1 === t2//true
t1 === t3//true
t2 === t3//true

t2 = t3

t1 === t2//true
t1 === t3//true
t2 === t3//true


t1.FullName == t2.FullName//true
t1.FullName == t3.FullName//true
t2.FullName == t3.FullName//true

</code></pre>
</div>

<blockquote>
  <p>Jut as the == operator checks if two values are equal, the === identity operator
compares the memory address of two references.</p>

</blockquote>

<p>== 是比较两个值是否一致，=== 是比较两个引用地址是否一致。</p>

<h6 id="structures">Structures</h6>
<ul>
  <li>用于表示值</li>
  <li>隐式的值copy</li>
  <li>数据不可变</li>
  <li>内存分配速度快（栈）</li>
</ul>

<h6 id="classes">Classes</h6>
<ul>
  <li>用于表示对象</li>
  <li>隐式的对象共享</li>
  <li>数据可变</li>
  <li>内存分配较慢（堆）</li>
</ul>

<h6 id="key-points"><strong>Key points</strong></h6>

<ul>
  <li>和structures一样，类是具有方法和属性的命名类型（named type）</li>
  <li>类通过指针共享对象</li>
  <li>类的实例叫做对象（objects）</li>
  <li>对象是可变的</li>
</ul>

<p>===========</p>

<h6 id="继承inheritance"><strong>继承（inheritance）</strong></h6>

<p>通过继承，子类可以完全继承自父类的全部属性和方法。
子类定义的属性和方法只要子类用于，父类不拥有。
swift 和oc 一样都是单一继承，只能继承一个其他类。
继承没有层级，子类的父类也可以是另外一个类的子类。</p>
<h6 id="多态-polymorphism"><strong>多态 （Polymorphism）</strong></h6>
<blockquote>
  <p>In brief, polymorphism is a programming languages ability to treat an object differently based on context.
简而言之，多态性是一种基于上下文以不同方式处理对象的编程语言能力。</p>
</blockquote>

<p>作用：
把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</p>

<h6 id="runtime-hierarchy-checks"><strong>Runtime hierarchy checks</strong></h6>

<p>• as: Cast to a specific type that is known at compile time to succeed, such as casting to a supertype.
• as?: An optional downcast (to a subtype). If the downcast fails, the result of the expression will be nil.
• as!: A forced downcast. If the downcast fails, the program will crash. Use this rarely, and only when you are certain the cast will never fail.</p>

