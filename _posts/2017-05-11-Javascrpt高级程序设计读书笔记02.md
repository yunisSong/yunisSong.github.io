---
layout:     post
title:      Javascrpt高级程序设计读书笔记02
subtitle:   在不断填坑中前进。。
date:       2017-05-11
author:     三十一
header-img: img/post-bg-js-version.jpg
header-mask: 0.3
catalog:    true
tags:
   - JavaScript
---

# Javascrpt高级程序设计读书笔记02

## 变量、作用域和内存问题
### 基本类型和引用类型的值
`JavaScript` 存在两种不同的数据类型的值：`基本类型值` 和 `引用类型值`。
`基本类型值` 指的是简单的数据段，为 `引用类型值` 指那些可能由多个值构成的对象。
引用类型的值是保存在内存中的对象，`JavaScript` 不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间。操作对象时，实际是操作对象的引用而不是实际对象。（这种说法并不严格，当复制保存对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。）
#### 动态的属性
可以在 引用类型 创建后，对他添加属性和方法。
#### 复制变量值
基本数据类型的复制是直接复制了一份值，引用数据类型，是复制了引用对象的指针，而不是引用对象本身。

```
 var obj1 = new Object();    var obj2 = obj1;    obj1.name = "Nicholas";    alert(obj2.name);  //"Nicholas"
```

#### 传递参数
JavaScript 中的参数都是按照值传递的。

#### 检查类型
要检查一个变量是不是基本的数据类型，使用 `typeof` 是最佳的工具。而通常我们需要的是知道这个对象是什么类型的对象，这个时间，就需要使用 `instanceof` 操作符。

```
result = variable instanceof constructor

alert(person instanceof Object); //变量 person 是 Object 吗？
alert(colors instanceof Array); //变量 colors 是 Array 吗？
alert(pattern instanceof RegExp); //变量 pattern 是 RegExp 吗？

```
## 执行环境及作用域

在一个页面中，第一次载入JS代码时创建一个全局执行环境，全局执行环境是最外围的执行环境，在Web浏览器中，全局执行环境被认为是window对象。因此，所有的全局变量和函数都是作为window对象的属性和方法创建的。
每进入一个执行环境，都会建立一个 `变量对象（Variable Object）`，环境中定义的变量和函数都保存在这个对象中。虽然我们编写的代码无法直接访问它，但是解析器在处理数据时在后台使用它。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，当函数执行完毕，栈将环境弹出，把控制权返还给之前的执行环境。
当代码在一个执行环境中执行时，会创建 `变量对象(Variable Object)` 的一个 `作用域链(Scope Chain)`,  `作用域链(Scope Chain)` 的用途是保证对执行环境有权访问的所有变量和函数的有序访问。 `作用域链(Scope Chain)` 的顶端始终是当前执行代码所在环境的`变量对象(Variable Object)`。

```
        var color = "blue";
        function changeColor() {
            var anotherColor = "red";
            function swapColors() {
                var tempColor = anotherColor;
                anotherColor = color;
                color = tempColor;
                //这里可以访问 color anotherColor和tempColor
            }
            //  这里可以访问color anotherColor，但不能访问tempColor
            swapColors();
        }
        //这里只能访问 color
        changeColor();
```
**如果这个环境是函数（如 swapColors()），则将其活动对象（activation object)作为变量对象。活动对象在最开始时只包含一个变量，就是函数内部的arguments对象。作用域链中的下一个Variable Object来自该函数(swapColors())的包含环境（也就是changeColor())，而再下一个Variable object来自再下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的Variable Object始终是作用域链中的最后一个对象**。


[了解JavaScript的执行上下文](http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/)

![ScopeChain](/img/in-post/ScopeChain.png)

* 全局环境有1个变量color和1个函数changecolor()。
* changecolor()函数的局部环境中具有1个anothercolor属性和1个swapcolors函数，当然，changecolor函数中可以访问自身以及它外围（也就是全局环境）中的变量。
* swapcolor()函数的局部环境中具有1个变量tempcolor。在该函数内部可以访问上面的2个环境（changecolor和window）中的所有变量，因为那2个环境都是它的父执行环境。

 通过上面的分析，我们可以得知内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间是线性、有次序的。每个环境都可以向上搜索作用域链，以便查询变量和函数名；但任何环境不能通过向下搜索作用域链条而进入另一个执行环境。对于上述例子的swapcolor()函数而言，其作用域链包括：swapcolor()的变量对象、changecolor（）变量对象和全局对象。swapcolor（）的局部环境开始先在自己的Variable Object中搜索变量和函数名，找不到，则向上搜索changecolor作用域链。。。。。以此类推。但是，changecolor()函数是无法访问swapcolor中的变量。

### 延长作用域链
`javascript` 的执行环境的类型共有两种：全局和局部（函数）。不过可以通过别的方法来延长作用域链。

1. try-catch语句的catch块
2. with语句



> 对于catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。在IE8及之前的javascript实现中，存在一个与标准不一样的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9中修复了这个问题。也就是说，在IE9以后的版本中，只能在catch的内部访问到错误对象。

```
person={name:"yhb",age:22,height:175,wife:{name:"lwy",age:21}};  
with(person.wife){  
    console.log(name);  
}  
```
with语句将person.wife添加到当前作用域链的头部，所以输出的就是：“lwy".
with语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。

### 没有块级作用域
在其他语言中，由 `{}` 包含的代码块有自己的作用域，但是 `JavaScript` 不支持块级作用域。

```
if (true) {
    // color 会被加入离它最近的执行环境中。     var color = "blue";}
alert(color);    //"blue"
```
#### 声明变量
```
function add(num1, num2) {    var sum = num1 + num2;    return sum; 
}var result = add(10, 20); //30alert(sum); //由于sum 不是有效的变量，因此会导致错误。


function add(num1, num2) {
    //如果不添加 var 关键字，sum 会被添加到全局环境中。    sum = num1 + num2;    return sum; 
}var result = add(10, 20); //30 
alert(sum); //30 
        
```
#### 查找标识符
```
var scope="global";  
function t(){  
    console.log(scope);  //输出undefined
    var scope="local"  
    console.log(scope); //输出  local
}  
t(); 
```

第一句输出的是： "undefined"，而不是 "global"
第二讲输出的是："local"
  你可能会认为第一句会输出："global",因为代码还没执行var scope="local",所以肯定会输出“global"。
  我说这想法完全没错，只不过用错了对象。我们首先要区分`Javascript`的函数作用域与我们熟知的C/C++等的块级作用域。
  在C/C++中，花括号内中的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的。而`Javascript`压根没有块级作用域，而是函数作用域.
所谓函数作用域就是说：-》变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。
所以根据函数作用域的意思，可以将上述代码重写如下：

```
var scope="global";  
function t(){  
    var scope;  
    console.log(scope);  
    scope="local"  
    console.log(scope);  
}  
t(); 
```
## 垃圾搜集
`JavaScript` 具有自动垃圾收集机制，采用的是 `标记清除(mark-and-sweep)`,当变量进入环境，就将标量标记为 “进入环境”，理论上来说，只要被标记为 “进入环境” 就不会释放变量占用的内存，而当变量离开环境是，将其标记为 “离开环境”。


## 小结
* `JavaScript` 变量可以用来保存两种类型的值：基本类型和引用类型。
* 基本类型在内存中占用固定大小，因此被保存在栈内存中。
* 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。
* 引用类型的值是对象，保存在堆内存中。
* 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。
* 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。
* 确定一个值是那种基本的类型可以使用 `typeof` 操作符，而确定一个值是哪种引用类型可以使用 `instanceof` 操作符。

所有的变量都存在于一个执行环境（也就是作用域）当中，这个执行环境决定了变量的声明周期，以及哪部分代码可以访问其中的变量。以下是关于执行环境总结：

* 执行环境有全局执行环境和函数执行环境。
* 每一次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。
* 函数的局部环境不仅有权访问函数作用域的变量，而且有权访问其包含环境（父环境），乃至全局环境。
* 全局环境只能访问全局环境中定义的变量和函数，不能直接访问局部环境的任何数据。
* 变量的执行环境有助于确定应该何时释放内存。

`JavaScript` 是一门自动回收垃圾的语言，开发人员不用关心内存分配和回收的问题。

* 离开作用域的值将被自动标记为可以回收，因此 将在垃圾回收期间被删除。
* ”标记清除“是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后在回收其内存。
* 另一种垃圾收集算法是”引用计数“，这种算法的思想是跟踪记录所有值被引用的次数。 `JavaScript` 引擎目前都不再使用这种算法，但在IE 中访问非原生的 `JavaScript` 对象（如 `DOM` 元素）时，这种算法仍然可能导致问题。
* 但代码中出现循环引用时的，”引用计数”的算法就会导致问题。
* 解除变量的引用不仅有助于消除循环引用的现象，而且对垃圾回收也有好处。为了确保有效的回收内存，应该及时的解除不在使用的全局变量、全局对象属性已经循环引用变量的引用。


