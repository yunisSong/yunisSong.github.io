---
layout:     post
title:      "swift 学习（3）基础"
subtitle:   "在不断填坑中前进。。"
date:       2017-03-01 12:00:00
author:     "三十一"
header-img: "img/post-bg-nextgen-web-pwa.jpg"
header-mask: 0.3
catalog:    true
tags:
    - Swift
---
# swift 学习（3）

###### 1，Optionals

> Swift introduces a whole new type, optional, that handles the possibility a value could be nil. If you’re handling a non-optional type, then you’re guaranteed to have a value and don’t need to worry about the existence of a valid value. Similarly, if you are using an optional type then you know you must handle the nil case. It removes the ambiguity introduced by using sentinel values.
   
> Optionals are Swift’s solution to the problem of representing both a value and the absence of a value. An optional type is allowed to reference either a value or nil.

Optionals 相当于一个容器，里面可以存放一个确切存在的值或者nil。

```
var errorCode: Int?
errorCode = 100
print(errorCode)//Optional(100)
errorCode = nil
print(errorCode)//nil
```

可见当errorCode 有值时，打印的是Optional(100) 并不是我们想要的 100这个值，如何获得呢。

 **!**
 
 可以使用!强制获得。但当值为nil的时间会报错。
 
 ```
 var errorCode: Int?
errorCode = 100
print(errorCode!)// 100
errorCode = nil
print(errorCode!)//报错
 ```
**安全的做法**
 **??**
 
 使用？？给一个默认值。当只为nil时使用默认值。
 
 ```
 var errorCode: Int?
errorCode = 100
print(errorCode!)//Optional(100)
errorCode = nil
print(errorCode ?? 0)//0
 ```
 
 **Optional binding**
 
> Swift includes a feature known as optional binding, which lets you safely access the value inside an optional. You use it like so:

 ```
 var authorName: String? = "Matt Galloway"
 if let unwrappedAuthorName = authorName {  print("Author is \(unwrappedAuthorName)")} else {  print("No author.")}
 ```
 
###### 2，数组

相同类型的数据的有序集合。
> An array is an ordered collection of values of the same type. The elements in the array are zero-indexed, which means the index of the first element is 0, the index of the second element is 1 and so on. Knowing this, you can work out that the last element’s index is the number of values in the array minus 1.

**创建数组**

```
let evenNumbers = [2, 4, 6, 8]
var subscribers: [String] = []
let allZeros = [Int](repeating: 0, count: 5)
let allY = [String](repeating: "Y", count: 5)
let allZerosInferred = Array(repeating: 0, count: 5)
```
**判断数组是否为空**

```
var players = ["Alice", "Bob", "Cindy", "Dan"]

if !players.isEmpty {
    print(players)
}

if players.count > 0 {
    print(players)
}

```
推荐使用isEmpty 方法，isEmpty 应该是只要判断数组中有元素，就直接返回值了，而count会把数组中所有的元素都统计一遍，然后返回。如果数组的元素非常非常多，就很耗时间了。


**读取操作**



```
var currentPlayer = players.first
print(currentPlayer)// > Optional("Alice")

print(players.last)// > Optional("Dan")


currentPlayer = players.min()print(currentPlayer)// > Optional("Alice")
```

使用下表读取

```
var players = ["Alice", "Bob", "Cindy", "Dan"]
var firstPlayer = players[0]
var firstPlayer01 = players.first
print(firstPlayer)//Alice
print(firstPlayer01)//Optional("Alice")

```

使用rang读取

```

var players = ["Alice", "Bob", "Cindy", "Dan"]
var firstPlayer = players[0]
var firstPlayer01 = players.first
print(firstPlayer)//Alice
print(firstPlayer01)//Optional("Alice")

let upcomingPlayers = players[1...2]
print(upcomingPlayers)
// > ["Bob", "Cindy"]
```


**操作数组**

```
players.append("Eli")
players += ["Gina"]
players.insert("Frank", at: 5)
var removedPlayer = players.removeLast()
removedPlayer = players.remove(at: 2)
players[0] = "100"

print(players)//["100", "Bob", "Dan", "Eli", "Frank"]
players[0...1] = ["Donna", "Craig", "Brian", "Anna"]
print(players)//["Donna", "Craig", "Brian", "Anna", "Dan", "Eli", "Frank"]
```

**迭代**

```
for player in players {
    print(player)
//    Donna
//    Craig
//    Brian
//    Anna
//    Dan
//    Eli
//    Frank
}


for (index, player) in players.enumerated() {
    print("\(index + 1). \(player)")
//    1. Donna
//    2. Craig
//    3. Brian
//    4. Anna
//    5. Dan
//    6. Eli
//    7. Frank
}
```

###### 3，字典

> A dictionary is an unordered collection of pairs, where each pair is comprised of a key and a value.

字典包含键、值，键是唯一的，不同的键指向的值可以相同。键必须是同一类型，值也是同一类型。

**创建字典**

```
var namesAndScores = ["Anna": 2, "Brian": 2, "Craig": 8, "Donna": 6]print(namesAndScores)// > ["Craig": 8, "Anna": 2, "Donna": 6, "Brian": 2]
var pairs: [String: Int] = [:]
```

**判断是否为空**

isEmpty

count

推荐使用  isEmpty 理由通array

**读取**

```
var pairs: [String: Int] = [:]
var namesAndScores = ["Anna": 2, "Brian": 2, "Craig": 8, "Donna": 6]
print(namesAndScores["Anna"] ?? "测试")
print(namesAndScores["不存在Key"] ?? "测试")
```

**Modifying dictionaries**

```
bobData.updateValue("CA", forKey: "state")
bobData["city"] = "San Francisco"
```

上面两个方法的区别是updateValue 会把原有的key的值返回回来，如果之前没有这个key对应的值，返回nil。

```
bobData.removeValue(forKey: "city")
bobData["city"] = nil
```
上面两个方法的区别是removeValue 会把原有的key的值返回回来，如果之前没有这个key对应的值，返回nil。

**迭代**

```
for (player, score) in namesAndScores {
    print("\(player) - \(score)")
}
```

