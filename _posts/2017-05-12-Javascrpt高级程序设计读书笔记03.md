---
layout:     post
title:      Javascrpt高级程序设计读书笔记03
subtitle:   在不断填坑中前进。。
date:       2017-05-12
author:     三十一
header-img: img/post-bg-js-version.jpg
header-mask: 0.3
catalog:    true
tags:
   - Javascrpt
---

# Javascrpt高级程序设计读书笔记03
## 引用类型
引用类型是一种数据结构，用于将数据和功能组织在一起。通常也被称为类。引用类型的对象本身是放置在堆中的，对象引用是存在栈中的。
### 堆、栈
[堆栈的区别](http://www.cnblogs.com/jeffchen/archive/2006/12/28/605689.html)
堆（Heap）栈（Stack）

1、内存分配方面：

    堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。

    栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

2、申请方式方面：

    堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。

    栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。

3、系统响应方面：

    堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

4、大小限制方面：

    堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

    栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

5、效率方面：

    堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

    栈：由系统自动分配，速度较快。但程序员是无法控制的。

6、存放内容方面：

    堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

    栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

7、存取效率方面：

    堆：char *s1 = "Hellow Word"；是在编译时就确定的；

    栈：char s1[] = "Hellow Word"； 是在运行时赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。
### Object 类型
目前看到的大多数引用类型值都是 `Object` 类型的实例。OC 里面的 `NSObject` 一样。
`Object` 实例有两种创建方式，第一张是使用 `new` 操作符后跟 `Object` 构造函数：

```
var person = new Object();
```
另一种就是使用字面量表示法。目的是简化创建过程中包含大量属性的对象。

```
var person = {
    name : "Yunis",
    age : 16
}

var person = {}; // new Object()  
person.name = "Nicholas";person.age = 29;
```

一般来说，访问对象的属性使用都是点语法，但是 `JavaScript` 中可以使用方括号来访问对象的属性：

```
alert(person["name"]);//Yunis
alert(person.name);//Yunis
```

通过方括号访问属性，还有另外一个用处，有些属性中包含导致语法错误的字符、或者关键字、保留字：

```
person["first name"] = "Yunis";
```
一般来说，尽量使用点语法访问属性。

### Array 类型
`JavaScript` 中的数组与其他语言的数组有很大的不同。
`JavaScript` 中数组中每一项都可以保存任何类型的数据。就是不同于其他语言，一个数组对象中，可以同时存在 字符串、数字、对象和数组等。`JavaScript` 的数组还可以动态调整大小，可以随着数据的添加自动增长。 `Array` 的创建方式：

```
//创建一个空数组
var colors = new Array();

//这个是创建一个包含3个元素的数组
var colors = new Array("red", "blue", "green");

//这个是创建一个长度为20 的数组
var colors = new Array(20);
```

创建的过程可以省略 `new` 关键字：

```
//创建一个空数组
var colors = Array();

//这个是创建一个包含3个元素的数组
var colors = Array("red", "blue", "green");

//这个是创建一个长度为20 的数组
var colors = Array(20);
```

也可以使用字面量创建：


```
//创建一个空数组
var colors = [];

//这个是创建一个包含3个元素的数组
var colors = ["red","blue","green"];


❗️❗️❗️❗️❗️各个浏览器的处理也不一致，不哟啊使用下面的写法❗️❗️❗️❗️
//❗️❗️❗️ 这样会创建一个包含两个数组的数组，一个数组长度是2，一个数组长度是3. ❗️❗️❗️ 
var colors = [2,3，];

//❗️❗️❗️ 这样会创建一个长度是4或者5的数组 ❗️❗️❗️ 
var colors = [,,,,];
```


与其他语言不通，数组读取超过了初始化的长度，不会报错。
    
```  
var colors = ["u","j",];
alert(colors[100]); // "undefined"

```

并且 数组的 length 属性 不是只读的，是可以修改的。

```
var colors = ["u","j",];
colors.length = 100;
alert(colors.length); // 100

var colors = ["a","b","c","d","e"];
//设置长度后，位于这个长度后的数据都会被清空，变为 undefined
colors.length = 2;
alert(colors); // a,b


//可以使用 length 属性 方便的在数组尾部添加数据
//因为数组的最后一项的索引始终是 length - 1 ，因此下一项的索引就是 length。
var colors = ["red", "blue", "green"];
colors[colors.length] = "black";//"red", "blue", "green","black"
colors[colors.length] = "brown";//"red", "blue", "green","black","brown"




//如果我们超出当前数组的 长度添加一个元素
var colors = ["red", "blue", "green"];
colors[99] = "black";
//长度就变成了 100  但是 索引 3 - 98 之间值都是 undefined
alert(colors.length); // 100
```

#### 检测数组
对于一个网页、或者一个全局作用域而言，使用 `instanceof` 操作符就可以得到满意的结果：

```
//判断 value 是不是数组
if (value instanceof Array){ 
    // 是，执行相应的操作}
```
但是在多个框架或者说多个不同的全局执行环境，就存在了不同版本的 Array 的构造函数，`instanceof` 就无法正确的工作了，需要使用 `Array.isArray()` 方法。


```
//判断 value 是不是数组

if (Array.isArray(value)){
    // 是，执行相应的操作}
```

#### 转换方法
可以使用 join() 方法使用不同的分割符来构建字符串。

```
var colors = ["red", "green", "blue"];
alert(colors.join(","));       //red,green,blue
alert(colors.join("||"));      //red||green||blue
```

#### 栈方法
`JavaScript` 中的数组可以表现的跟栈一样。栈的访问规则是后进先出（LIFO，Last-In-First-Out），也就是最后添加的数据会最早被移除。在栈中的推入和弹出操作只会发生在栈的顶部。`JavaScript` 为数组提供了 `push()` 和 `pop()` 方法。

`push()` 方法可以接受任意数量的参数，把他们逐个添加到数组尾部，并返回修改后的数组长度。
`pop()` 方法从数组末尾移除最后一项，并修改数组长度，然后返回移除的项。

```
var colors = new Array();
var count = colors.push("red", "green");
alert(colors); //red,green

alert(count); //2
count = colors.push("black");
alert(count);     //3
var item = colors.pop();
alert(item);      //"black"
alert(colors.length);   //2




var colors = new Array("测试数据占位","测试数据占位01");
var count = colors.push("red", "green");
alert(colors); //测试数据占位,测试数据占位01,red,green

alert(count); //4
count = colors.push("black");
alert(count);     //5
var item = colors.pop();
alert(item);      //"black"
alert(colors.length);   //4


```

#### 队列方法

数组也可以像队列一样使用，队列的访问规则是先进先出（FIFO，First-In-First-Out）。从队列的首部移除项，尾部添加项。

` shift()` 能够移除数组中的第一个项并返回该项，同时数组长度加1.

结合之前的 `push()` 方法，就可以像使用队列一样使用数组了。


```
//创建数组
var colors = new Array();
//推入两项 colors 变为  red green
var count = colors.push("red", "green");
alert(count); //2
//推入一项 colors 变为  red green black
count = colors.push("black");
alert(count);     //3

//取得第一项并移除 colors 变为  green black
var item = colors.shift();
alert(item); //"red"
alert(colors.length); //2
```

`unshift()`  与 ` shift()` 方法相反，可以在数组前面添加任意多个项并返回新数组的长度。因此 `unshift()` 和 `pop()` 方法也可以以相反的方向模拟队列。

```
 var colors = new Array();
 var count = colors.unshift("red", "green");
 alert(colors);//red green

 alert(count); //2
 count = colors.unshift("black","llll");
 alert(colors);//black llll red green

 alert(count);//4
 var item = colors.pop();
 alert(item);//green
 alert(colors.length);//3
```

#### 重排序方法
`reverse()` 反转数组[1,2,3] -> [3,2,1]
`sort()` 默认排序是按照每一项的 Unicode 编码排序的。

```        
var colors = new Array("b","c","1","3","a","z","f");
colors.sort();
alert(colors);//1,3,a,b,c,f,z



var colors = new Array("b","c","1","111","3","a","z","f");
colors.sort();
alert(colors);//1,111,3,a,b,c,f,z
```

可以自己写一个比较规则的函数当做参数传递给 `sort()`

```

function compare(value1, value2) {
    if (Number(value1) < Number(value2)) {
        return -1;
    } else if (Number(value1) > Number(value2)) {
        return 1;
    } else {                    
        return 0; 
    }                
}

var colors = new Array("1","2","5","4","3","22","11","9");
colors.sort(compare);
alert(colors);//1,2,3,4,5,9,11,22
   
   
           
var colors = new Array("b","c","1","111","3","a","z","f");
colors.sort(compare);
//❗️❗️❗️❗️  这到底是为什么。。有点晕
alert(colors);//b,c,1,3,111,a,z,f
```

`sort()` 有点坑爹啊。

#### 操作方法
##### `concat()`
`concat()` 可以根据单签数组中的所有项创建一个新的数组。这个方法会先创建一个当前数组的副本，然后将他接收的参数添加到这个副本的末尾，组合返回新构建的数组。

```
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors);     //red,green,blue
alert(colors2);    //red,green,blue,yellow,black,brown
```
##### `slice()`
`slice()` 方法可以根据当前数组的一项或者多项创建一个新数组。可以接受一个或者两个参数（返回项的起始和结束位置）。如果只有一个参数，则该方法返回从改参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之前的项，但不包括结束位置的项。

```
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);
alert(colors2);   //green,blue,yellow,purple
alert(colors3);   //green,blue,yellow
```

##### `splice()`
`splice()` 方法是数组中很强大的方法，有多中用法，主要的用法有3种：

* 删除 可以删除任意数量的项，只需要指定两个参数：要删除的第一项的位置和要删除的项数。例如：`splice(0,2)` 会删除数组的前两项。
* 插入 可以向指定位置插入任意数量的项，需要提供3个参数：起始位置、0（要删除的项个数）和要插入的项。如果需要插入多个项，可以再传入第4、5.以及任意多个项。例如：`splice(2,0,"red","green")` 会从当前数组的位置2开始插入 `"red"` 和  `"green"`。
* 替换 可以向指定位置插入任意数量的项，切同时删除任意数量的项。需要提供3个参数：起始位置、要删除的项个数 和 要插入的项，插入的项数不必与删除的项数相同。

`splice()` 方法始终会返回一个数组，该数组包含从原始数组中删除的项，如果没有删除返回一个空数组。

```
//删除
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1);
alert(colors); // green,blue
alert(removed); // red 

//插入
removed = colors.splice(1, 0, "yellow", "orange");
alert(colors); // green,yellow,orange,blue
alert(removed); //返回一个空的数组

//替换
removed = colors.splice(1, 1, "red", "purple");
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow 
```

#### 位置方法

`indexOf()` 方法是从数组的开始位置向后查找
`lastIndexOf()` 方法是从数组的末尾位置向前查找。
这两个方法都接收两个参数：要查找的项和 表示查找起点位置的索引（可选）。

```
var numbers = [1,2,3,4,5,4,3,2,1];

alert(numbers.indexOf(4));        //3
alert(numbers.indexOf(4, 4));     //5

alert(numbers.lastIndexOf(4)); //5
alert(numbers.lastIndexOf(4, 4)); //3
```

#### 迭代方法
JavaScript 提供了5个迭代方法。每个方法都接收两个参数：**要在每一项上运行的函数** 和 **运行该函数的作用域对象**（可选，影响 `this` 的值）。


* every() 对数组中每一项都运行特定函数，如果改函数每一项都返回 true，则返回true。
* some() 对数组中每一项都运行特定函数，如果改函数有任意一项返回 true，则返回true。
* forEach() 对数组的每一项运行特定函数。没有返回值。
* filter() 对数组的每一项运行特定函数。返回该函数会返回 true 的选项组成的数组。
* map() 对数组的每一项运行特定函数。返回每次函数调用的结果组成的数组。

```JavaScript
var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){    return (item > 2);});
alert(everyResult); //false


var someResult = numbers.some(function(item, index, array){    return (item > 2);});
alert(someResult); //true



var filterResult = numbers.filter(function(item, index, array){    return (item > 2);
});
alert(filterResult); //[3,4,5,4,3]



var mapResult = numbers.map(function(item, index, array){    return item * 2;});
alert(mapResult);  //[2,4,6,8,10,8,6,4,2]


numbers.forEach(function(item, index, array){
    //对每一项进行处理 for 循环});
```

#### 归并方法

 `JavaScript` 提供了两个归并数组的方法 `reduce()` 和 `reduceRight()`。都会迭代数组中的所有项区别是，`reduce()` 是从数组的第一项开始，`reduceRight()` 是从数组的最后一项开始。
 
 
```
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){    return prev + cur;});


第1次执行 prev 是1，cur 是2.
第2次执行 prev 是3，cur 是3.
第3次执行 prev 是6，cur 是4.
...
最后的结果

alert(sum); //15



var sum = values.reduceRight(function(prev, cur, index, array){    return prev + cur;});
第1次执行 prev 是5，cur 是4.
第2次执行 prev 是9，cur 是3.
第3次执行 prev 是12，cur 是2.
...
最后的结果

alert(sum);

```


### Date 类型
创建一个日期对象：

```
var now = new Date();
```
调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获取当前日期和时间。

代码来说明一切：

```
// 2005 年 5月 5日 下午 5点55分55秒
//这里5月是因为月份是基于0 为其实月份，即：0 表示一月。
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));

//计算执行时间
var start = Date.now();doSomething();
var stop = Date.now(),
    result = stop   start;
```
### RegExp 类型
JavaScript 通过 RegExp 来支持正则表达式。

```
var expression = / pattern / flags ;
```
pattern 代表正则表达式。
flags 代表正则表达式flags .

* g 全局（global）模式，匹配所有。
* i case-insensitive，不区分大小写。
* m 表示多行（multiline）模式。在达到一行文本的末尾是还会继续查找下一行中是否存在与模式匹配的项。


```
//匹配所有的 “at”
var pattern1 = /at/g;

//匹配第一个 bat 或者 cat，不区分大小写var pattern2 = /[bc]at/i;

//匹配所有以 at 结尾的3个字符的集合，不区分大小写
var pattern3 = /.at/gi;
```


在 JavaScript 使用正则表达式下列字符需要使用转义字符
`( [ { \ ^ $ | ) ? * + .]}`


```
//匹配第一个 “bat” 或者 “cat” 不区分大小写
var pattern1 = /[bc]at/i;

//匹配第一个"[bc]at" ，不区分大小写
var pattern2 = /\[bc\]at/i;

//匹配所有以 at 结尾的3个字符的集合，不区分大小写
var pattern3 = /.at/gi;

//匹配所有 “.at”，不区分大小写
var pattern4 var pattern4 = /\.at/gi;
```

待续。。。。看到头晕 5.4

###  Function 类型
 函数也是对象，函数名 实际上就是指向函数对象的指针，不会与某个函数绑定。
 
 
```
function sum (num1, num2) {    return num1 + num2;}
var sum = function(num1, num2){    return num1 + num2;};

alert(sum(10,10));        //20

var anotherSum = sum;alert(anotherSum(10,10)); //20

sum = null;alert(anotherSum(10,10)); //20
```
 
####  没有重载
 将函数名称想象为指针，就很好理解了为什么 JavaScript 中没有函数重载的概念了。
 
```
function addSomeNumber(num){    return num + 100;}function addSomeNumber(num) {
    return num + 200;}

var result = addSomeNumber(100); //300

var addSomeNumber = function (num){    return num + 100;};

addSomeNumber = function (num) { 
    return num + 200;};
var result = addSomeNumber(100); //300
```

#### 函数声明 和 函数表达式
解析器在向执行环境中加载数据时，对函数声明和函数表达式不是相同的处理，解析器会先读取函数声明，并使其在执行任何代码之前可用（可用访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正的被解释执行。下面的代码完全可以正确的执行：

```
alert(sum(10,10));function sum(num1, num2){    return num1 + num2;}
```

这是因为在代码执行之前，解析器就已经通过一个名为 函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。读取并将函数声明添加到执行环境中。对代码求值时， JavaScript 引擎 在第一遍会声明函数并将它们放到代码树的顶部。

```
alert(sum(10,10));var sum = function(num1, num2){    return num1 + num2;};
```

上面代码会在运行期产生错误，原因是函数位于一个初始化语句中，而不是一个函数声明中。

#### 作为值的函数
`JavaScript` 中 函数名本身就是变量，所以函数可以当做值来传递，还可以当做另一个函数的结果返回。
#### 函数的内部属性
在函数内部有两个特殊的对象：`arguments` 和 `this` 。`arguments` 主要是用来保存函数的参数，这个对象还有一个名叫 `callee` 的属性，这个属性是一个指针，指向拥有 `arguments` 的函数。

```

function factorial(num){        if (num <=1) {            return 1;        } else {            return num * factorial(num-1)        }}

function factorial(num){    if (num <=1) {        return 1;    } else {        return num * arguments.callee(num-1)} }
```

函数内部还有一个特殊对象是 `this`，`this`引用的是函数的执行环境对象。

```
window.color = "red";var o = { color: "blue" };function sayColor(){    alert(this.color);}sayColor();     //"red"o.sayColor = sayColor;
o.sayColor();   //"blue"
```

#### 函数的属性和方法

`length` 表示函数希望接收的命名参数的个数。
`prototype` 保存了对象的所有实例方法。但是不能枚举。

每个函数还包括两个非继承来的方法： `apply()` 和 `call()`，这两个方法的用途是在给特定的作用域调用函数，实际上等于设置函数体内 `this` 对象的值。

`apply()` 接收两个参数：一个是在其中运行函数的作用域，另一方是参数数组。其中第二个参数可以是 `Array` 的实例，也可以是 `arguments` 对象。

```
function sum(num1, num2){    return num1 + num2;}

function callSum1(num1, num2){    return sum.apply(this, arguments);//传入 arguments 对象}

function callSum2(num1, num2){    return sum.apply(this, [num1, num2]); //传入数组}

alert(callSum1(10,10));   //20alert(callSum2(10,10));   //20
```

`call()` 函数必须明确的传入每一个参数。

`apply()` 和 `call()` 真正强大是地方是能够扩充函数赖以运行的作用域。


```
window.color = "red";var o = { color: "blue" };
function sayColor(){    alert(this.color);}
sayColor(); //red

sayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue
```


使用 `apply()` 和 `call()` 扩充作用域的好处是对象不需要与方法有任何的耦合关系。

JavaScript 5 中 定义了 `bind()`，这个方法会创建一个函数的实例，其 this 值会被绑定到传给 `bind()` 函数的值。

```
window.color = "red";var o = { color: "blue" };

function sayColor(){    alert(this.color);}

var objectSayColor = sayColor.bind(o);objectSayColor();    //blue
```

#### 基本包装类型
为了方便操作基本类型值，JavaScript 提供了3个特殊的引用类型： `Boolean`、`Number` 和 `String`。

```
var s1 = "some text";var s2 = s1.substring(2);



```

上面的代码中 s1 包含一个字符串，属于基本类型值，第二行中就使用了 s1 的 substring() 方法，理论上来说，s1属于基本类型，基本类型不是对象，不应该有方法。这是因为，为了我们更直观的进行操作，后台自动帮助我们完成了处理。当第二行代码访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会自动完成下列操作：

1. 创建一个 String 类型的实例；
2. 在实例上调用指定的方法；
3. 销毁这个实例。

具体的代码可以想象成下面的代码：

```
var s1 = new String("some text");var s2 = s1.substring(2);s1 = null;
```


引用类型和基本包装类型的主要区别就是对象的生存周期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中的，而自动创建的基本包装类型的对象，则只存在于一行代码的瞬间，然后立即被销毁。

```
var s1 = "some text";s1.color = "red";alert(s1.color);   //undefined
```
**String 方法 待续 编辑器已经卡的不行了**


## 小结
对象在 `JavaScript` 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象。

* 引用类型已传统的面向对象程序设计中的类相似，但实现不同；
* `Object` 是一个基础类型，其他所用类型都从 `Object` 继承了基本的行为；
* `Array` 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
* `Date` 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
* `RegExp` 类型是 `JavaScript` 支持正则表达式的一个借口，提供最基本的和一些高级的正则表达式功能。

函数是 `function` 类型的实例，因此函数也是对象。所以函数也拥有方法。
因为有了基本包装类型，所以 `JavaScript` 中的基本类型可以被当做对象来访问。三种基本 包装类型分别是：`Boolean` 、`Number` 和 `String`。以下是它们的共同特征：

* 每个包装类型都映射到同名的基本类型；
* 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；
* 操作基本类型值的语句一经执行完毕，就会立即销毁创建的包装对象。

