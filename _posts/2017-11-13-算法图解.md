---
layout:     post
title:      算法图解
subtitle:   在不断填坑中前进。。
date:       2017-11-13
author:     三十一
header-img: img/post-bg-nextgen-web-pwa.jpg
header-mask: 0.3
catalog:    true
tags:
   - 内功
---

# 算法图解
### 算法简介
#### 对数 
 对数运算是幂运算的逆运算。
![](media/15105545936376/15105546056701.jpg)


#### 二分查找如何实现

```
def binary_search(array,item):
    low = 0
    high = len(array) - 1
    print("large index is %d"%high)

    while low <= high:
        mid = int((low + high)/2)
        guess = array[mid]
        print("Mid is %d"%mid)
        print("guess is %d"%guess)
        if  guess == item:
            return mid
        elif guess < item:
            low = mid + 1
            print("+++++++low is %d"%low)
        elif guess > item:
            high = mid - 1
            print("-------high is %d"%high)
        else:
            return None
myList = [1,3,7,9,12,23,45,67,89,123,244,345,456,1234]
print(binary_search(myList,23))
```

#### 运行时间
> 每次介绍算法时，我都将讨论其运行时间。一般而言，应选择效率最高的算 法，以最大限度地减少运行时间或占用空间。
> 简单查找逐个地检查数 字，如果列表包含100个数字，最多需要猜100次。如果列表包含40亿个数字，最 多需要猜40亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为线性 时间(linear time)。
> 二分查找则不同。如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?二分查找的运行时间为对数时间(或log时间)。

![](media/15105545936376/15105591801136.jpg)


#### 大 O 表示法

1. 大O表示法是一种特殊的表示法，指出了算法的速度有多快。
2. 大O表示法 让你能够比较操作数，它指出了算法运行时间的增速。
3. 大O表示法指出了最糟情况下的运行时间。
4. 算法的速度指的并非时间，而是操作数的增速。
5. 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
6. 算法的运行时间用大O表示法表示。
7. O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多

下面按从快到慢的顺序列出了经常会遇到的5种大O运行时间。

* [ ]  **O(log n)**，也叫对数时间，这样的算法包括二分查找。* [ ]  **O(n)**，也叫线性时间，这样的算法包括简单查找。* [ ]  **O(n * log n)**，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 
* [ ]  **O(n2)**，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。* [ ]  **O(n!)**，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

![](media/15105545936376/15106259079062.jpg)


### 选择排序
#### 内存的工作原理

> 假设你去看演出，需要将东西寄存。寄存处有一个柜子，柜子有很多抽屉。
> 每个抽屉可放一样东西，你有两样东西要寄存，因此要了两个抽屉。
> 你将两样东西存放在这里。
> 现在你可以去看演出了!这大致就是计算机内存的工作原理。计算机就像是很多抽屉的集合体，每个抽屉都有地址。
> 需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。

#### 数组和链表
* 数组 ：所有元素在内存中都是相连的，添加需要重新申请内存。
* 链表 ：链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。使用链表时，根本就不需要移动元素。链表的优势在插入元素方面。
* 插入元素：使用链表时，只需要修改前面那个元素指向的地址就可以插入元素，数组的话，就需要把元素后面的元素全部向后移动，如果没有足够的时间的话，还得将数组复制到其他地方。
* 删除元素：使用链表时，只需要修改前一个元素指向的地址就行了，使用数组的话，删除元素后面的元素都需要向前移。

|  | 优点 |   缺点 |
| --- |  --- | --- |
| 数组 |  查找方便  |  必须使用连续的存储空间，添加元素需要从新分配内存  |
| 链表 |  可以使用分割开的内存，添加元素方便  |  查找慢，必须重头开始一个个地址的查。  |

常见的数组和链表操作的运行时间
    
![](media/15105545936376/15106419508468.jpg)

#### 选择排序

时间：O(n²)



```

# 找出当前数组最小的数字的index
def findSmallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1,len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

# 选择排序  O(n²)
def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest_index = findSmallest(arr)
        # arr.pop(smallest_index) 移除指定位置的元素，并返回这个元素
        newArr.append(arr.pop(smallest_index))
    return newArr


print (selectionSort([5, 3, 6, 2, 10]))

```

