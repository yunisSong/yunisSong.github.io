---
layout:     post
title:      正则表达式必知必会
subtitle:   在不断填坑中前进。。
date:       2017-08-07
author:     三十一
header-img: img/post-bg-nextgen-web-pwa.jpg
header-mask: 0.3
catalog:    true
tags:
   - 内功
   - 正则表达式
---

# 正则表达式必知必会
### 匹配单个字符

#### 匹配纯文本
相当于文本查找的功能（CMD + F）。但是一般的正则表达式引擎默认返回第一个匹配结果。
#### 大小写匹配
#### 匹配任意字符
使用 . 来匹配任意字符。
譬如：使用 `yunis.` 来匹配，`yunis1`，`yunis2`，`yunis3`都是符合搜索结果的。
#### 匹配特殊字符
如果需要匹配特殊字符（ `.` 等）就需要使用元字符（ `\` 反斜杠）来对他进行转义。
譬如：使用 `yunis\.` 来匹配， `yunis.` 是符合匹配结果的。
### 匹配一组字符
#### 匹配多个字符串中的任意一个
譬如：使用 `[abc]hhhh` 进行匹配。`ahhhh`,`bhhhh`,`chhhh` 都是符合条件的搜索结果。
#### 例如字符集合区间
譬如：使用`[a-c]hhh` 进行匹配，`ahhhh`,`bhhhh`,`chhhh` 都是符合条件的搜索结果。
使用 `[0-9]hhh` 进行匹配 `0hhh`，`1hhh`，`2hhh` 。。。 `9hhh` 都是符合条件的搜索结果。

* A-Z 匹配 A 到 Z 的所有大写字母。
* a-z 匹配 a 到 z 的所有小写字母。
* A-F 匹配 A 到 F 的所有大写字母。
* A-z 匹配从 `ASCII` 字符 A 到 `ASCII` 字符 z 的所有字母。
* 同一个字符集合里面可以给出多个字符区间。譬如 `[A-Za-z0-9]` 可以匹配任何字母和数字。 

#### 取非匹配
可以使用元字符 `^` 来标明你想对一个字符集合取非匹配结果。
譬如：使用 `a[\^0-9]` 进行匹配, as,ab,ac 都是符合调剂的搜索结果，a0，a1,a2不是符合条件的搜索结果。
### 使用元字符
#### 对特殊字符使用转义
如果想匹配元字符需要使用 `\` 反斜杠来转义。
譬如：匹配 `\` 本身就需要转义，需要使用 `\\`来匹配 `\`。
    匹配 `[` 需要使用 `\[` 来进行匹配。
    
#### 匹配空白字符
* `\f` 换页符
* `\n` 换行符
* `\r` 回车符
* `\t` 制表符（Tab）
* `\v` 垂直制表符
#### 匹配数字

* `\d` 匹配任意一个数字字符 等价于 `[0-9]`
* `\D` 匹配任意一个非数字字符 等价于 `[^0-9]`
#### 匹配字母与数字

* `\w` 匹配任意一个字母、数字或者下划线字符，等价于 `[a-zA-z0-9_]`
* `\W` 匹配任何一个非字母、数字或者下划线字符，等价于 `[^a-zA-z0-9_]`

#### 匹配空白字符
* `\s` 任意一个空白符 ，等价于 `[\f\n\r\t\v]`
* `\S` 任意一个非空白符 ，等价于 `[^\f\n\r\t\v]`


### 重复匹配
#### 匹配一个或多个字符
想要匹配同一个字符或者字符集合的多次重复，只需要简单的给这个字符或字符集合加上一个 `+` 字符作为后缀就行了。
`+` 匹配一个或者多个字符（至少一个，不匹配零个字符的情况）。譬如 a 匹配 a 本身，a+ 将匹配一个或多个连续出现的 a 。类似的 ,`[0-9]` 匹配任意一个数字，`[0-9]+` 匹配一个或多个连续的数字。

匹配邮箱：`[\w.]+@[\w.]\.\w+`
一般来说，在字符集合里面的元字符将被解释为普通字符，不需要被转义，但转义了也没有坏处。 `[\w.]` 与 `[\w\\.]` 是一样的。

`+` 是一个元字符。如果需要匹配 + 本身，需要转义。

#### 匹配零个或者多个字符
`+` 匹配一个或者多个字符，`*` 匹配零个或者多个字符。
`*` 是元字符，匹配他本身需要转义。
#### 匹配零个或者一个字符
`?` 元字符 `?` 的意思是匹配一个字符一次或者零次。
譬如：`https?` 进行匹配，`http` 和 `https` 都是符合条件的搜索结果。
#### 匹配重复次数

* `+` 和 `*` 匹配的字符个数没有上限。我们无法为他们将匹配的字符个数设定一个最大值。
* `+` 、`*`和 `？` 至少匹配零个或者一个字符。无法为他们匹配的字符个数设定一个最小值。
* 如果只使用 `+` 和 `*` 我们无法将他们匹配的字符个数设定为一个精确的数字。

##### 为重复匹配设定一个精确的值
使用 `{6}` 表示前一个字符匹配6次。
譬如 `y{6}` 进行匹配，`yyyyyy` 是符合条件的匹配结果。
##### 为重复匹配设定一个区间
譬如使用 `y{2,4}` 进行匹配，`yy`,`yyy`,`yyyy` 都是符合条件的搜索结果。
##### 为重复匹配设定一个最小重复数字
譬如使用 `y{2,}` 进行匹配，`yy`,`yyy`,`yyyy`，`yyyyyyyyyyyy` 都是符合条件的搜索结果。
这个正则的意思是y至少重复2次。
##### 防止过度匹配
下面一段文本 `<b>1234</b>qweqweqweqweqweqweqw<b>5678</b>`
当我们使用 `<b>.*</b>` 进行匹配时，我们希望得到的是 `<b>1234</b>` 和 `<b>5678</b>` ，但是我们得到的是 `<b>1234</b>qweqweqweqweqweqweqw<b>5678</b>`。

这是因为什么呢？
因为 `*` 和 `+` 都是 `贪婪型` 的元字符，它们进行匹配时的模式是多多益善而不是适可而止。它们会尽可能的从一段文本的开头一直匹配到这段文本的结尾，而不是从文本的开头匹配到第一个匹配时为止。

当不需要这种贪婪型模式时怎么办？使用它们的懒惰型版本，懒惰型版本会尽可能少的匹配字符。

| 贪婪型元字符 | 懒惰型元字符 |
| --- | --- |
| `*` | `*?` |
| `+` | `+?` |
| `{n,}` | `{n,}?` |

当我们使用 `<b>.*?</b>` 进行匹配时，就能得到的是 `<b>1234</b>` 和 `<b>5678</b>` 的匹配结果。



### 位置匹配
#### 单词边界
文本 `dog hjhjdogkjhkj hhh dogs.` 当我们使用 `dog` 进行匹配时，我们只希望匹配到第一个单词 `dog`，但是匹配的结果是 **dog** hjhj**dog**kjhkj hhh **dog**s.

这个时间就需要使用单词边界来限定了，单词边界由限定符 `\b` 表示。

当我们使用 `\bdog\b` 来匹配时，只会匹配到第一个 `dog` 单词。
#### 字符串边界
`^` 匹配一个字符串的开始。
`$` 匹配一个字符串的结尾。
`(?m)` 匹配一行的开始。
### 使用子表达式
### 回溯引用：前后一致匹配
### 前后查找
### 嵌入条件

