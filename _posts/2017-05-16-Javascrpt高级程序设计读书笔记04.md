---
layout:     post
title:      Javascrpt高级程序设计读书笔记04
subtitle:   在不断填坑中前进。。
date:       2017-05-16
author:     三十一
header-img: img/post-bg-js-version.jpg
header-mask: 0.3
catalog:    true
tags:
   - JavaScript
---

# 面向对象的程序设计
面向对象（Object-Oriented,OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建多个具有相同属性和方法的对象。 `JavaScript` 中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。

`JavaScript` 中对对象的定义为：`无序属性是集合，其属性可以包含基本值、对象或者函数。`严格的讲，就相当于说对象是一组没有特定顺序的值。


 [JavaScript“并非”一切皆对象](http://www.cnblogs.com/myvin/p/4660138.html) 这篇文章写的挺好的。

## 理解对象
创建自定义对象最简单的方法就是创建一个 Object 的实例，然后为它添加属性和方法。

```
var person = new Object();    person.name = "Nicholas";    person.age = 29;    person.job = "Software Engineer";    person.sayName = function(){        alert(this.name);};
```
 或者使用字面量创建：
 
 ```
var person = {    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName: function() {        alert(this.name);    } 
};
 ```

### 属性类型
`JavaScript` 中有两种属性：数据属性和访问器属性。
[JavaScript 属性类型（数据属性 访问器属性）](http://www.cnblogs.com/oneplace/p/5492476.html) 这篇文章写的很好。
#### 数据属性
数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个描述行为的特性。

* [[Configurable]] 表示是否可以通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值是 `true`。
* [[Enumerable]]  是否可以通过枚举返回属性。默认是 `true`。
* [[Writable]] 表示是否能够修改这个属性的值。默认是 `true`。
* [[Value]] 包含这个属性的数据值。读取属性值的时间从这个位置读，写入属性值的时间，把新值保存子啊这个位置。默认是 `undefined` 。

要修改属性默认特性。必须使用 `Object.defineProperty()` 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象、其中。描述符（descriptor）对象的属性必须是： configurable、enumerable、writable 和 value 。设置其中的一个或者多个值，可以修改对应的特性值。

```JavaScript
//writable 是否可以修改属性
var person = {};Object.defineProperty(person, "name", {    writable: false,    value: "Nicholas"});

alert(person.name); //"Nicholas"
person.name = "Greg"; alert(person.name); //"Nicholas"
```

```JavaScript
var person = {};Object.defineProperty(person, "name", {    configurable: false,    value: "Nicholas"});alert(person.name); //"Nicholas" 
delete person.name; 
alert(person.name); //"Nicholas"
```



```JavaScript
var person = {};Object.defineProperty(person, "name", {    configurable: false,    value: "Nicholas"});
//一旦对一个属相设置为configurable 为 false，就再也不能将它变为原来的可配置了。//抛出异常 Object.defineProperty(person, "name", {    configurable: true,    value: "Nicholas"});
```

#### 访问器属性
访问器属性不包括数据值。在读取访问器属性时，会调用 getter 函数，在写入的时间，会调用 setter 函数。访问器属性有4个特性：

* [[Configurable]]表示是否可以通过 `delete` 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认值是 `true`。
* [[Enumerable]] 是否可以通过枚举返回属性。默认是 `true`。
* [[Get]] 在读取属性时调用的函数。默认值是 undefined。
* [[Set]] 在写入属性时调用的函数。默认值是 undefined。

访问器属性不能直接定义，必须使用 `Object.defineProperty()` 来定义。

```
var book = {    _year: 2004,    edition: 1 
};

Object.defineProperty(book, "year", {    get: function(){        return this._year;    },    set: function(newValue){        if (newValue > 2004) {            this._year = newValue;            this.edition += newValue - 2004;        } 
    }});
book.year = 2005; 
alert(book.edition); //2
```

### 定义多个属性
由于对象定义多个属性的可能性很大，可以利用 `Object.defineProperties()` 方法一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或者修改的属性一一对应。


```
var person = { 
  _name: "Scott", 
  _age: 24, 
  _tel: 86247 
}; 
Object.defineProperties(person,{ 
  name:{ 
    get: function(){ 
      return this._name; 
    } 
  }, 
  age:{ 
    set: function(p){ 
      this._age = p; 
    } 
  }, 
  tel:{ 
    get:function(){ 
      return this._tel; 
    }, 
    set: function(p){ 
      this._tel = p; 
    } 
  } 
});
```

### 读取属性的特性
可以使用 `Object.getOwnPropertyDescriptor()` 方法获取给定属性的描述符。这个方法接收的是两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 `configurable` 、`enumerable` 、`get` 和 `set`。如果是数据属性，这个对象的属性有 `configurable `、`enumerable` 、`writable` 和 `value`。

```
var person = { 
  _name: "Scott", 
  _age: 24, 
  _tel: 86247 
}; 
Object.defineProperties(person,{ 
  name:{ 
    get: function(){ 
      return this._name; 
    } 
  }, 
  age:{ 
    set: function(p){ 
      this._age = p; 
    } 
  }, 
  tel:{ 
    get:function(){ 
      return this._tel; 
    }, 
    set: function(p){ 
      this._tel = p; 
    } 
  } 
}); 
var descripter = Object.getOwnPropertyDescripter(person,"tel"); 
console.log(descripter.value);  //undefined 
console.log(descripter.enumerable);  //false 
console.log(typeof descripter.get);  //"function"
```
上面的代码中获取了person对象的tel属性，由于其是一个访问器属性，所以其value为undefined，enumerable为false，而get为指向getter函数的一个指针。

## 创建对象

### 工厂模式

```
function createPerson(name, age, job){    var o = new Object();    o.name = name;    o.age = age;
    o.job = job;    o.sayName = function(){        alert(this.name);    };    return o; 
}var person1 = createPerson("Nicholas", 29, "Software Engineer");var person2 = createPerson("Greg", 27, "Doctor");
```
函数 `createPerson()` 能够接受参数构建一个包含必要信息的 `Person` 对象。可以无数次调用这个函数，而每一次都会返回一个包含三个属性、一个方法的对象。
工厂模式虽然解决了创建多个相识对象的问题，却没有解决对象识别的问题。因为全部都是 `Object`，不像 `Date`、`Array` 等，因此出现了构造函数模式。
### 构造函数模式
JavaScript 中的构造函数可用来创建特定类型的对象。也可以创建自定义构造函数，从而定义自定义对象的属性和方法。

```
function Person(name, age, job){        this.name = name;        this.age = age;        this.job = job;        this.sayName = function(){            alert(this.name);        }; 
}var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");
```

在这个例子中 `Person()` 函数取代了  `createPerson()` 函数，与  `createPerson()` 不同有：

* 没有显示的创建对象；
* 直接将属性和方法赋值给了 this 对象；
* 没有 return 语句。
* `Person()` 是大写字母 `P` 开头。这是惯例，构造函数始终以一个大写字母开头。
* 使用 `new` 创建对象
* 能够识别对象（这正是构造函数模式胜于工厂模式的地方）


以这种构造函数创建对象会经过 4 个步骤：

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象。

前面例子中 person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 `constructor` 属性（构造函数），改属性指向了 `Person`。

```JavaScript
alert(person1.constructor == Person); //true
alert(person2.constructor == Person); //true

alert(person1 instanceof Object);  //truealert(person1 instanceof Person);  //truealert(person2 instanceof Object);  //truealert(person2 instanceof Person);  //true
```

创建自定义的构造函数可以将它的实例标识为一种特定的类型，这正是构造函数模式比工厂模式好的地方。

#### 将构造函数当做函数
构造函数与其他函数的唯一区别就是调用方式不同。
任何函数，只要通过 new 操作符调用，就可以作为构造函数。
前面例子中定义的 `Person()` 函数就可以使用下方的任何一种方式调用：

```
//当做构造函数调用var person = new Person("Nicholas", 29, "Software Engineer"); 
person.sayName(); //"Nicholas"//当做普通函数调用  Person("Greg", 27, "Doctor"); //添加到window
window.sayName(); //"Greg"// 在另一个函数的作用域调用var o = new Object();Person.call(o, "Kristen", 25, "Nurse"); 
o.sayName(); //"Kristen"
```

#### 构造函数的问题
构造函数的组要问题就是每个方法都要在每个实例上重新创建一遍。已这种方式创建函数，会导致不同的作用域链和标识符解析，但创建 `Function` 新实例的机制仍然相同。因此，不同实例上同名函数式不相等的。

```
alert(person1.sayName == person2.sayName);  //false
```
然而创建两个完成同样任务的 `Function` 实例是没有必要的，况且有 `this` 对象。根本不需要再执行代码钱就把函数绑定到特定对象上。因此，我们可以将函数移到对象外面：

```
function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = sayName;}function sayName(){    alert(this.name);}var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");
```

这样一来 person1 与 person2 访问的都是同一个函数，可是问题又来了，在全局作用域中定义了一个实际只想让 Person 使用的函数，显示让全局作用域有些名副其实，更让人无法接受的是在全局作用域中定义了许多仅供特定对象使用的方法，浪费空间不说，显然失去了面向对象封装性了，因此可以通过原型来解决此问题。

### 原型模式
我们创建的每一个函数都有一个 `prototype(原型)` 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。**使用原型对象的好处就是可以让所有对象实例共享它所包含的属性及方法。**

```
function Person(){}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function(){    alert(this.name);};var person1 = new Person();person1.sayName();   //"Nicholas"var person2 = new Person();
person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName);  //true
```

这样创建出来的对象的这些属性和方法是所有实例共享的。

更简单的原型语法

```
function Person(){}Person.prototype = {    name : "Nicholas",    age : 29,    job: "Software Engineer",    sayName : function () {        alert(this.name);    }};
```

#### 理解原型对象
只要创建了一个函数，就会根据特定规则为该函数创建一个 `prototype` 属性，这个属性指向了函数的原型对象。在默认的情况下，所有的原型对象都自动获取一个 `constructor(构造函数)` 属性，这个属性包含一个指向 `prototype` 属性所在函数的指针。比较直观的关系看下图。
![](/img/in-post/Javascrpt高级程序设计读书笔记/JS原型对象.png)

当为实例对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。添加这个属性后只会阻止我们访问原型中的那个属性，但是不会修改原型中的属性。不过可以通过 delete 操作符完全删除实例属性，然后就可以访问原型对象中的属性。

```
function Person(){}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function(){    alert(this.name);};var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert(person1.name);//"Greg" 来自实例alert(person2.name);//"Nicholas"  来自原型delete person1.name;alert(person1.name);//"Nicholas" 来自原型      
        ```

可以通过 `hasOwnProperty()` 函数来判断是访问的实例属性还是原型属性。

```
function Person(){
}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function(){  alert(this.name);
}; 
  
var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty("name"));  //falseperson1.name = "Greg";alert(person1.name); //"Greg"
alert(person1.hasOwnProperty("name")); //truealert(person2.name); //"Nicholas"
alert(person2.hasOwnProperty("name")); //falsedelete person1.name;alert(person1.name); //"Nicholas"  
alert(person1.hasOwnProperty("name")); //false
```
原型模式也不是没有缺点，首先，它省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值，这样非常不方便，但这还是不是原型的最大问题，原型模式的最大问题在于共享的本性所导致的，由于共享，因此因此一个实例修改了引用，另一个也随之更改了引用。因此我们通常不单独使用原型，而是结合原型模式与构造函数模式。

### 组合使用构造函数模式和原型模式
创建自定义对象最常见的方法是使用 `构建函数模式` + `原型模式`，构建函数用于定义实例属性，原型模式用于定义方法 和 共享的属性。这样每个实例都有一份自己的实例属性，但同时又共享着对方法的引用，最大程度节省了内存。

```
function Person(name, age, job){this.name = name; 3 this.age = age;this.job = job;this.friends = ["Shelby", "Court"]; 2  }Person.prototype = {    constructor : Person,    sayName : function(){        alert(this.name);    }}
var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");person1.friends.push("Van");alert(person1.friends);    //"Shelby,Count,Van"alert(person2.friends);    //"Shelby,Count"alert(person1.friends === person2.friends);//falsealert(person1.sayName === person2.sayName);//true
```
这种模式在 `ECMAScript` 中是使用最广泛、认同度最高的一种创建自定义对象的方法。
### 动态原型模式
动态原型模式与上面的 `构建函数模式` + `原型模式` 并没有什么区别，只是把所有的信息都封装在了构造函数中。

```
function Person(name, age, job){    //属性    this.name = name; 
    this.age = age; 
    this.job = job;
    //方法
    //判断是否已经初始化方法    if (typeof this.sayName != "function"){
            Person.prototype.sayName = function(){            alert(this.name);        }; 
    }
}
```

> 使用动态原型时，不能使用对象的字面量重写原型，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。


### 寄生构造函数模式
先看段代码，看下区别。

```
//工厂模式
function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o; 
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");


//构造函数模式
function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            alert(this.name);
        }; 
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");


//寄生构造函数模式
function SpecialArray(){
    //创建数组    var values = new Array();
    //添加值    values.push.apply(values, arguments);    //添加方法      values.toPipedString = function(){        return this.join("|");    };
    //返回数组    return values;}

var colors = new SpecialArray("red", "blue", "green");alert(colors.toPipedString()); //"red|blue|green"
```

寄生构造函数模式中返回的对象与构造函数或者与构造函数的原型属性之间没有关系。不能依赖 `instanceof` 操作符来确定对象类型。**尽量不要使用这种模式。**

### 稳妥构造函数模式

这种模式最大的豪好处是除了调用提供的方法，没有别的方式访问其数据成员。

```
function Person(name, age, job) {
    var o = new Object();
 
    // private members
    var nameUC = name.toUpperCase();

    // public members
    o.sayName = function() {
        alert(name);
    };
    o.sayNameUC = function() {
        alert(nameUC);
    };

    return o;
}
var person = Person("Nicholas", 32, "software Engineer");

person.sayName(); // "Nicholas"
person.sayNameUC(); // "NICHOLAS"

alert(person.name);  // undefined
alert(person.nameUC);  // undefined
```
凡是想设为 private 的成员都不要挂到 Person 返回的对象 o 的属性上面，挂上了就是 public 的了。


## 继承
许多 oo 语言都支持两种继承方式，接口继承（相对于OC 来说，就是协议，不知道理解的对不对） 和 实现继承。
接口继承 只继承方法签名，实现继承则继承实际的方法。
但是 `JavaScript` 中函数没有签名，没办法实现接口继承。只支持实现继承，而且实现继承是通过原型链实现的。
#### 原型链
`JavaScript` 中描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
构造函数、原型和失恋的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例包含一个指向原型对象的内部指针。

如果我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上诉关系依然成立，如此层层递进，就构成了实例和原型的链条。这就是原型链的基本概念。（好绕啊。。。）

>函数的原型对象 `constructor` 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 `proto`，该指针指向上一层的原型对象，而上一层的原型对象的结构依然类似，这样利用 `proto` 一直指向 `Object` 的原型对象上，而 `Object` 的原型对象用 `Object.proto = null` 表示原型链的最顶端，如此变形成了 `JavaScript` 的原型链继承，同时也解释了为什么所有的 `JavaScript` 对象都具有 `Object` 的基本方法。

```
function SuperType(){        this.property = true;}

SuperType.prototype.getSuperValue = function(){
    return this.property;};function SubType(){    this.subproperty = false;}SubType.prototype = new SuperType();SubType.prototype.getSubValue = function (){    return this.subproperty;};var instance = new SubType();alert(instance.getSuperValue()); //true```
上面的代码实例、构造函数和原型之间的关系如下图展示：
![](/img/in-post/Javascrpt高级程序设计读书笔记/JS原型链.png)

下面这张图很清晰的展示了原型链：
![](/img/in-post/Javascrpt高级程序设计读书笔记/JS原型继承.png)

![](/img/in-post/Javascrpt高级程序设计读书笔记/JS原型与构造函数关系.png)

##### 原型链的问题
原型链虽然强大，可以用来实现继承，但是也存在一些问题。最主要的问题来自包含引用类型值的原型。
引用类型值的原型属性会被所有的实例共享，在通过原型实现继承时，原型实际上会成为另一个类型的实例。于是，原先的实例属性就变成现在的原型属性了。

```
function SuperType(){        this.colors = ["red", "blue", "green"];
}
function SubType(){}SubType.prototype = new SuperType();
var instance1 = new SubType();instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black" 

var instance2 = new SubType(); 
alert(instance2.colors); //"red,blue,green,black"
```
#### 借用构造函数
为了解决原型中包含引用类型值所带来的问题，可以使用一种叫 `借用构造函数(constructor stealing)` 的技术（有时间也叫伪造对象或者经典继承）。这种技术的基本思想相当简单，即在子类型构建函数的内部调用超类型构造函数。

```function SuperType(){    this.colors = ["red", "blue", "green"]; function SubType(){//    SuperType    SuperType.call(this);}var instance1 = new SubType();instance1.colors.push("black");alert(instance1.colors);    //"red,blue,green,black"var instance2 = new SubType();alert(instance2.colors);    //"red,blue,green"
```
代码中 `SuperType.call(this);` 借调了超类型的构造函数，我们实际上是在新创建  `SubType` 实例的环境下调用了 `SuperType` 的构造方法。


借用构造函数可以在子类型构造函数想超类型构造函数传递参数。
```
function SuperType(name){    this.name = name;}function SubType(){    //继承SuperType，同时还传递了参数 
    SuperType.call(this, "Nicholas");    //实例属性    this.age = 29;}var instance = new SubType();alert(instance.name);    //"Nicholas";alert(instance.age);     //29
```
如果仅仅使用借用构造函数，也无法避免构造函数模式存在的问题：方法都在构造函数定义，因此就没办法函数复用了。而且在超类原型中定义的方法，对于子类是不可见的，结果所有类型都只能使用构造函数模式，所有，很少单独 `使用借用构造函数` 的技术。


#### 组合继承
`组合继承（combination inheritance ）` 有时候也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥两者之长的一种继承模式。背后的思想是，借助原型链来实现对原型属性和方法的继续，使用 借用构造函数 来实现对实例属性的继承。这样既通过原型上定义方法实现了函数复用，有能够保证每个实例有自己的属性。

```
function SuperType(name){    this.name = name;    this.colors = ["red", "blue", "green"];}
 SuperType.prototype.sayName = function(){    alert(this.name);
}

function SubType(name, age){
    //继承属性
    SuperType.call(this, name);    this.age = age;}

//继承方法
SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){    alert(this.age);};

var instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");   alert(instance1.colors);instance1.sayName();instance1.sayAge();


var instance2 = new SubType("Greg", 27);alert(instance2.colors);instance2.sayName();instance2.sayAge();
```

组合是继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，是 JavaScript 中最常见的继承模式。
#### 原型式继承
原型式继承本身的实现是很简单的，但是其牵涉到的概念以及原理却不好说明白。原型的本质是就是一个对象.
原型式继承更能节约内存，原型链读取成员的方式使得所有克隆出来的对象都共享每个属性与方法的唯一一份实例。只有在直接设置了某个克隆出来的对象的属性或者方法时，情况才会发生改变，但是原型式继承的这种优势在某些情况下因为其对继承而来的成员的读与写的不对等性，在有共享的引用型属性时，这种优势又会变为原型式继承的一种劣势.

```
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
var person = {        name: "Nicholas",        friends: ["Shelby", "Court", "Van"]    };    var anotherPerson = object(person);    anotherPerson.name = "Greg";    anotherPerson.friends.push("Rob");    var yetAnotherPerson = object(person);    yetAnotherPerson.name = "Linda";    yetAnotherPerson.friends.push("Barbie");    alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"w
```
#### 寄生式继承

```
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
function createAnother(original{ 
    varclone=object(original); 
    clone.sayHi = function(){        alert("hi");    };    return clone; }
 
 
var person = {    name: "Nicholas",    friends: ["Shelby", "Court", "Van"]};var anotherPerson = createAnother(person);anotherPerson.sayHi(); //"hi"
```
#### 寄生组合式继承

还没搞懂。。先往下面看。。。
```
function SuperType(name){    this.name = name;    this.colors = ["red", "blue", "green"];}SuperType.prototype.sayName = function(){    alert(this.name);};function SubType(name, age){    SuperType.call(this, name);    this.age = age;}SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function(){    alert(this.age);};
```

# 小结
JavaScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，隐藏具有动态性而非严格意义上的实体。没有类的情况下，可以采用下列模式创建对象。

* 工厂模式  使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构建函数模式取代。
* 构造函数模式 可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。缺点是，每个成员都无法复用，包括函数。
* 原型模式 使用构造函数的 prototype 属性可以指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，使用原型模式定义共享的属性和方法。

`JavaScript` 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样子类型就能够访问超类型的属性和方法。这一点和基于类的继承很相似。再次亮出这张图：
![](/img/in-post/Javascrpt高级程序设计读书笔记/JS原型继承.png)

原型链的问题是对象实例共享的所有继承的属性和方法，因此不宜单独使用。
**借助原型链来实现对原型属性和方法的继续，使用 借用构造函数 来实现对实例属性的继承。这样既通过原型上定义方法实现了函数复用，有能够保证每个实例有自己的属性。**
此外，还可以选择下面的继承方式：

* 原型式继承 
* 寄生式继承
* 寄生组合式继承

